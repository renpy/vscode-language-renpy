/* eslint-disable no-useless-escape */
/* eslint-disable no-useless-backreference */
/* eslint-disable @typescript-eslint/no-non-null-assertion */

// THIS FILE HAS BEEN GENERATED BY THE `syntax-to-token-pattern.py` GENERATOR
// DO NOT EDIT THIS FILE DIRECTLY! INSTEAD RUN THE PYTHON SCRIPT.
// ANY MANUAL EDITS MADE TO THIS FILE WILL BE OVERWRITTEN. YOU HAVE BEEN WARNED.
// Last generated: 14/08/2024 16:34:44 (UTC+0)

import { MetaTokenType, KeywordTokenType, CharacterTokenType, EntityTokenType, OperatorTokenType, LiteralTokenType } from "./renpy-tokens";
import { TokenPattern } from "./token-pattern-types";

export const python: TokenPattern = {
    patterns: [
    ]
};

export const impossible: TokenPattern = {
    debugName: "impossible",

    // This is a special rule that should be used where no match is desired. It is not a good idea to match something like '1{0}' because in some cases that can result in infinite loops in token generation. So the rule instead matches and impossible expression to allow a match to fail and move to the next token.
    match: /$.^/gm,
};

export const statement: TokenPattern = {
    patterns: [
    ]
};

export const semicolon: TokenPattern = {
    patterns: [
        {
            debugName: "semicolon.patterns![0]",

            token: MetaTokenType.Deprecated, /*invalid.deprecated.semicolon.python*/
            match: /\;$/gm,
        },
    ]
};

export const comments: TokenPattern = {
    patterns: [
        {
            debugName: "comments.patterns![1]",

            token: MetaTokenType.Comment, /*comment.line.number-sign.python*/
            contentToken: MetaTokenType.TypehintComment, /*meta.typehint.comment.python*/
            begin: /(?:\#\s*(type:)\s*(?!$|\#))/dgm,
            beginCaptures: {
                0: { token: MetaTokenType.TypehintComment, /*meta.typehint.comment.python*/ },
                1: { token: MetaTokenType.TypehintDirective, /*comment.typehint.directive.notation.python*/ },
            },
            end: /(?:$|(?=\#))/gm,
            patterns: [
                {
                    debugName: "comments.patterns![1].patterns![0]",

                    token: MetaTokenType.TypehintIgnore, /*comment.typehint.ignore.notation.python*/
                    match: /ignore(?=\s*(?:$|\#))/gm,
                },
                {
                    debugName: "comments.patterns![1].patterns![1]",

                    token: MetaTokenType.TypehintType, /*comment.typehint.type.notation.python*/
                    match: /\b(?<!\.)(bool|bytes|float|int|object|str|List|Dict|Iterable|Sequence|Set|FrozenSet|Callable|Union|Tuple|Any|None)\b/g,
                },
                {
                    debugName: "comments.patterns![1].patterns![2]",

                    token: MetaTokenType.TypehintPunctuation, /*comment.typehint.punctuation.notation.python*/
                    match: /([\[\]\(\),\.\=\*]|(->))/g,
                },
                {
                    debugName: "comments.patterns![1].patterns![3]",

                    token: MetaTokenType.TypehintVariable, /*comment.typehint.variable.notation.python*/
                    match: /([a-zA-Z_]\w*)/g,
                },
            ]
        },
    ]
};

export const docstringStatement: TokenPattern = {
    debugName: "docstringStatement",

    // the string either terminates correctly or by the beginning of a new line (this is for single line docstrings that aren't terminated) AND it's not followed by another docstring
    begin: /(?<=^[ \t]*)(?=[rR]?(\'\'\'|\"\"\"|\'|\"))/gm,
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /((?<=\1)|^)(?!\s*[rR]?(\'\'\'|\"\"\"|\'|\"))/gm,
    patterns: [
    ]
};

export const docstring: TokenPattern = {
    patterns: [
        {
            debugName: "docstring.patterns![0]",

            token: MetaTokenType.Docstring, /*string.quoted.docstring.multi.python*/
            begin: /(\'\'\'|\"\"\")/dg,
            beginCaptures: {
                1: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
            },
            // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
            end: /(\1)/dg,
            endCaptures: {
                1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
            },
            patterns: [
            ]
        },
        {
            debugName: "docstring.patterns![1]",

            token: MetaTokenType.Docstring, /*string.quoted.docstring.raw.multi.python*/
            begin: /([rR])(\'\'\'|\"\"\")/dg,
            beginCaptures: {
                1: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
                2: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
            },
            // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
            end: /(\2)/dg,
            endCaptures: {
                1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
            },
            patterns: [
            ]
        },
        {
            debugName: "docstring.patterns![2]",

            token: MetaTokenType.Docstring, /*string.quoted.docstring.single.python*/
            begin: /(\'|\")/dg,
            beginCaptures: {
                1: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
            },
            // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
            end: /(\1)|(\n)/dg,
            endCaptures: {
                1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
            },
            patterns: [
            ]
        },
        {
            debugName: "docstring.patterns![3]",

            token: MetaTokenType.Docstring, /*string.quoted.docstring.raw.single.python*/
            begin: /([rR])(\'|\")/dg,
            beginCaptures: {
                1: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
                2: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
            },
            // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
            end: /(\2)|(\n)/dg,
            endCaptures: {
                1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
            },
            patterns: []
        }]
};

export const docstringGutsUnicode: TokenPattern = {
    patterns: [
    ]
};

export const docstringPrompt: TokenPattern = {
    debugName: "docstringPrompt",

    match: /(?:\s*((?:>>>|\.\.\.)\s)(?=\s*\S))/dg,
    captures: {
        1: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/ },
    },
};

export const statementKeyword: TokenPattern = {
    patterns: [
        {
            debugName: "statementKeyword.patterns![0]",

            token: KeywordTokenType.Def, /*storage.type.function.python*/
            match: /\b((async\s+)?\s*def)\b/g,
        },
        {
            debugName: "statementKeyword.patterns![1]",

            // if `as` is eventually followed by `:` or line continuation, it's probably control flow like:    with foo as bar, \
            //          Foo as Bar:      try:        do_stuff()      except Exception as e:        pass
            token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/
            match: /\b(?<!\.)as\b(?=.*[:\\])/g,
        },
        {
            debugName: "statementKeyword.patterns![2]",

            // other legal use of `as` is in an import
            token: KeywordTokenType.Import, /*keyword.control.import.python*/
            match: /\b(?<!\.)as\b/g,
        },
        {
            debugName: "statementKeyword.patterns![3]",

            token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/
            match: /\b(?<!\.)(async|continue|del|assert|break|finally|for|from|elif|else|if|except|pass|raise|return|try|while|with)\b/g,
        },
        {
            debugName: "statementKeyword.patterns![4]",

            match: /\b(?<!\.)(?:(global)|(nonlocal))\b/dg,
            captures: {
                1: { token: KeywordTokenType.Global, /*storage.modifier.declaration.global.python*/ },
                2: { token: KeywordTokenType.Nonlocal, /*storage.modifier.declaration.nonlocal.python*/ },
            },
        },
        {
            debugName: "statementKeyword.patterns![5]",

            token: KeywordTokenType.Class, /*storage.type.class.python*/
            match: /\b(?<!\.)(class)\b/g,
        },
        {
            debugName: "statementKeyword.patterns![6]",

            match: /^\s*(case|match)(?=\s*([-+\w\d(\[{'":#]|$))\b/dgm,
            captures: {
                1: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/ },
            },
        },
    ]
};

export const newLine: TokenPattern = {
    debugName: "newLine",

    token: CharacterTokenType.NewLine, /*punctuation.new-line.renpy*/
    match: /\r\n|\r|\n/g,
};

export const whitespace: TokenPattern = {
    debugName: "whitespace",

    token: CharacterTokenType.Whitespace, /*punctuation.whitespace.python*/
    match: /[ \t]+/g,
};

export const expressionBare: TokenPattern = {
    // valid Python expressions w/o comments and line continuation
    patterns: [
        whitespace,
        newLine,
    ]
};

export const expressionBase: TokenPattern = {
    // valid Python expressions with comments and line continuation
    patterns: [
        comments,
        expressionBare,
    ]
};

export const expression: TokenPattern = {
    // All valid Python expressions
    patterns: [
        expressionBase,
        {
            debugName: "expression.patterns![2]",

            // Tokenize identifiers to help linters
            token: EntityTokenType.Identifier, /*variable.name.python*/
            match: /\b([a-zA-Z_]\w*)\b/g,
        },
    ]
};

export const memberAccess: TokenPattern = {
    debugName: "memberAccess",

    token: MetaTokenType.MemberAccess, /*meta.member.access.python*/
    contentToken: EntityTokenType.Identifier, /*variable.name.python*/
    begin: /(\.)\s*(?!\.)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.Dot, /*punctuation.separator.dot.python*/ },
    },
    end: /(?<=\S)(?=\W)|(^|(?<=\s))(?=[^\\\w\s])|$/gm,
    patterns: [
    ]
};

export const memberAccessBase: TokenPattern = {
    patterns: [
    ]
};

export const memberAccessAttribute: TokenPattern = {
    debugName: "memberAccessAttribute",

    // Highlight attribute access in otherwise non-specialized cases.
    token: MetaTokenType.DataAttribute, /*variable.name.python meta.data.attribute.python*/
    match: /\b([a-zA-Z_]\w*)\b/g,
};

export const specialNames: TokenPattern = {
    debugName: "specialNames",

    token: MetaTokenType.ConstantCaps, /*constant.other.caps.python*/
    match: /\b(_*[A-Z][_\d]*[A-Z])[A-Z\d]*(_\w*)?\b/g,
};

export const curlyBraces: TokenPattern = {
    debugName: "curlyBraces",

    begin: /\{/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.dict.begin.python*/ },
    },
    end: /\}/dg,
    endCaptures: {
        0: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.dict.end.python*/ },
    },
    patterns: [
        {
            debugName: "curlyBraces.patterns![0]",

            token: CharacterTokenType.Colon, /*punctuation.separator.dict.python*/
            match: /:/g,
        },
        expression,
    ]
};

export const list: TokenPattern = {
    debugName: "list",

    begin: /\[/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenSquareBracket, /*punctuation.definition.list.begin.python*/ },
    },
    end: /\]/dg,
    endCaptures: {
        0: { token: CharacterTokenType.CloseSquareBracket, /*punctuation.definition.list.end.python*/ },
    },
    patterns: [expression]
};

export const oddFunctionCall: TokenPattern = {
    debugName: "oddFunctionCall",

    // A bit obscured function call where there may have been an arbitrary number of other operations to get the function.E.g. "arr[idx](args)"
    token: MetaTokenType.FunctionCall, /*meta.function-call.python*/
    begin: /(?<=[\]\)"])\s*(?=\()/g,
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.python*/ },
    },
    patterns: [
    ]
};

export const roundBraces: TokenPattern = {
    debugName: "roundBraces",

    begin: /\(/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.python*/ },
    },
    end: /\)/dg,
    endCaptures: {
        0: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.python*/ },
    },
    patterns: [expression]
};

export const lineContinuation: TokenPattern = {
    patterns: [
        {
            debugName: "lineContinuation.patterns![0]",

            match: /(\\)\s*(\S.*$\n?)/dgm,
            captures: {
                1: { token: CharacterTokenType.Backslash, /*punctuation.separator.continuation.line.python*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.line.continuation.python*/ },
            },
        },
        {
            debugName: "lineContinuation.patterns![1]",

            begin: /(\\)\s*$\n?/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.Backslash, /*punctuation.separator.continuation.line.python*/ },
            },
            end: /(?=^\s*$)|(?!(\s*[rR]?(\'\'\'|\"\"\"|\'|\"))|((?<=\\\s*)$))/gm,
            patterns: []
        }]
};

export const assignmentOperator: TokenPattern = {
    debugName: "assignmentOperator",

    token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/
    match: /<<=|>>=|\/\/=|\*\*=|\+=|-=|\/=|@=|\*=|%=|~=|\^=|&=|\|=|=(?!=)/gm,
};

export const operator: TokenPattern = {
    debugName: "operator",

    match: /\b(?<!\.)(?:(and|or|not|in|is)|(for|if|else|await|(?:yield(?:\s+from)?)))(?!\s*:)\b|(<<|>>|&|\||\^|~)|(\*\*|\*|\+|-|%|\/\/|\/|@)|(!=|==|>=|<=|<|>)|(:=)/dgm,
    captures: {
        1: { token: MetaTokenType.LogicalOperatorKeyword, /*keyword.operator.logical.python*/ },
        2: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/ },
        3: { token: MetaTokenType.BitwiseOperatorKeyword, /*keyword.operator.bitwise.python*/ },
        4: { token: MetaTokenType.ArithmeticOperator, /*keyword.operator.arithmetic.python*/ },
        5: { token: MetaTokenType.ComparisonOperatorKeyword, /*keyword.operator.comparison.python*/ },
        6: { token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/ },
    },
};

export const punctuation: TokenPattern = {
    patterns: [
        {
            debugName: "punctuation.patterns![0]",

            token: CharacterTokenType.Colon, /*punctuation.separator.colon.python*/
            match: /:/g,
        },
        {
            debugName: "punctuation.patterns![1]",

            token: CharacterTokenType.Comma, /*punctuation.separator.element.python*/
            match: /,/g,
        },
    ]
};

export const literal: TokenPattern = {
    patterns: [
        {
            debugName: "literal.patterns![0]",

            token: MetaTokenType.ConstantLiteral, /*constant.language.python*/
            match: /\b(True|False|None|NotImplemented|Ellipsis)\b/g,
        },
    ]
};

export const number: TokenPattern = {
    patterns: [
        {
            debugName: "number.patterns![6]",

            token: MetaTokenType.Invalid, /*invalid.illegal.name.python*/
            match: /\b[0-9]+\w+/g,
        },
    ]
};

export const numberFloat: TokenPattern = {
    debugName: "numberFloat",

    token: LiteralTokenType.Float, /*constant.numeric.float.python*/
    match: /(?<!\w)(?:(?:\.[0-9](?:_?[0-9])*|[0-9](?:_?[0-9])*\.[0-9](?:_?[0-9])*|[0-9](?:_?[0-9])*\.)(?:[eE][+-]?[0-9](?:_?[0-9])*)?|[0-9](?:_?[0-9])*(?:[eE][+-]?[0-9](?:_?[0-9])*))([jJ])?\b/dg,
    captures: {
        1: { token: MetaTokenType.ImaginaryNumberStorageType, /*storage.type.imaginary.number.python*/ },
    },
};

export const numberDec: TokenPattern = {
    debugName: "numberDec",

    token: MetaTokenType.ConstantNumeric, /*constant.numeric.dec.python*/
    match: /(?<![\w.])(?:[1-9](?:_?[0-9])*|0+|[0-9](?:_?[0-9])*([jJ])|0([0-9]+)(?![eE.]))\b/dg,
    captures: {
        1: { token: MetaTokenType.ImaginaryNumberStorageType, /*storage.type.imaginary.number.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.dec.python*/ },
    },
};

export const numberHex: TokenPattern = {
    debugName: "numberHex",

    token: MetaTokenType.ConstantNumeric, /*constant.numeric.hex.python*/
    match: /(?<![\w.])(0[xX])(?:_?[0-9a-fA-F])+\b/dg,
    captures: {
        1: { token: MetaTokenType.NumberStorageType, /*storage.type.number.python*/ },
    },
};

export const numberOct: TokenPattern = {
    debugName: "numberOct",

    token: MetaTokenType.ConstantNumeric, /*constant.numeric.oct.python*/
    match: /(?<![\w.])(0[oO])(?:_?[0-7])+\b/dg,
    captures: {
        1: { token: MetaTokenType.NumberStorageType, /*storage.type.number.python*/ },
    },
};

export const numberBin: TokenPattern = {
    debugName: "numberBin",

    token: MetaTokenType.ConstantNumeric, /*constant.numeric.bin.python*/
    match: /(?<![\w.])(0[bB])(?:_?[01])+\b/dg,
    captures: {
        1: { token: MetaTokenType.NumberStorageType, /*storage.type.number.python*/ },
    },
};

export const numberLong: TokenPattern = {
    debugName: "numberLong",

    // this is to support python2 syntax for long ints
    token: MetaTokenType.ConstantNumeric, /*constant.numeric.bin.python*/
    match: /(?<![\w.])(?:[1-9][0-9]*|0)([lL])\b/dg,
    captures: {
        1: { token: MetaTokenType.NumberStorageType, /*storage.type.number.python*/ },
    },
};

export const regexp: TokenPattern = {
    patterns: [
    ]
};

export const string: TokenPattern = {
    patterns: [
    ]
};

export const stringUnicodeGuts: TokenPattern = {
    patterns: [
    ]
};

export const stringConsumeEscape: TokenPattern = {
    debugName: "stringConsumeEscape",

    match: /\\['"\n\\]/g,
};

export const stringRawGuts: TokenPattern = {
    patterns: [stringConsumeEscape]
};

export const stringRawBinGuts: TokenPattern = {
    patterns: [stringConsumeEscape]
};

export const stringEntity: TokenPattern = {
    patterns: []
};

export const fstringGuts: TokenPattern = {
    patterns: [
    ]
};

export const fstringRawGuts: TokenPattern = {
    patterns: [
        stringConsumeEscape]
};

export const fstringIllegalSingleBrace: TokenPattern = {
    debugName: "fstringIllegalSingleBrace",

    // it is illegal to have a multiline brace inside a single-line string
    begin: /(\{)(?=[^\n}]*$\n?)/dgm,
    beginCaptures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
    },
    end: /(\})|(?=\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
    },
    patterns: []
};

export const fstringIllegalMultiBrace: TokenPattern = {
    patterns: [
        impossible]
};

export const fExpression: TokenPattern = {
    // All valid Python expressions, except comments and line continuation
    patterns: [
        expressionBare,
        memberAccess,
        {
            debugName: "fExpression.patterns![2]",

            // Tokenize identifiers to help linters
            match: /\b([a-zA-Z_]\w*)\b/g,
        },
    ]
};

export const escapeSequenceUnicode: TokenPattern = {
    patterns: [
        {
            debugName: "escapeSequenceUnicode.patterns![0]",

            token: MetaTokenType.EscapeSequence, /*constant.character.escape.python*/
            match: /\\(u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8}|N\{[\w\s]+?\})/g,
        },
    ]
};

export const escapeSequence: TokenPattern = {
    debugName: "escapeSequence",

    token: MetaTokenType.EscapeSequence, /*constant.character.escape.python*/
    match: /\\(x[0-9A-Fa-f]{2}|[0-7]{1,3}|[\\"'abfnrtv])/g,
};

export const stringLineContinuation: TokenPattern = {
    debugName: "stringLineContinuation",

    token: MetaTokenType.ConstantLiteral, /*constant.language.python*/
    match: /\\$/gm,
};

export const stringFormatting: TokenPattern = {
    debugName: "stringFormatting",

    token: MetaTokenType.FormatPercent, /*meta.format.percent.python*/
    match: /(%(?:\([\w\s]*\))?[-+#0 ]*(?:\d+|\*)?(?:\.(?:\d+|\*))?(?:[hlL])?[diouxXeEfFgGcrsab%])/dg,
    captures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
    },
};

export const stringBraceFormatting: TokenPattern = {
    patterns: [
        {
            debugName: "stringBraceFormatting.patterns![0]",

            token: MetaTokenType.FormatBrace, /*meta.format.brace.python*/
            match: /({{|}}|(?:{\w*(\.[a-zA-Z_]\w*|\[[^\]'"]+\])*(![rsa])?(:\w?[<>=^]?[-+ ]?\#?\d*,?(\.\d+)?[bcdeEfFgGnosxX%]?)?}))/dgm,
            captures: {
                1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
                3: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
                4: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
            },
        },
        {
            debugName: "stringBraceFormatting.patterns![1]",

            token: MetaTokenType.FormatBrace, /*meta.format.brace.python*/
            match: /({\w*(\.[a-zA-Z_]\w*|\[[^\]'"]+\])*(![rsa])?(:)[^'"{}\n]*(?:\{[^'"}\n]*?\}[^'"{}\n]*)*})/dg,
            captures: {
                1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
                3: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
                4: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
            },
        },
    ]
};

export const fstringFormatting: TokenPattern = {
    patterns: [
    ]
};

export const fstringFormattingSingeBrace: TokenPattern = {
    debugName: "fstringFormattingSingeBrace",

    token: MetaTokenType.Invalid, /*invalid.illegal.brace.python*/
    match: /(}(?!}))/g,
};

export const importStatement: TokenPattern = {
    // Import statements used to correctly mark `from`, `import`, and `as`
    patterns: [
        {
            debugName: "importStatement.patterns![0]",

            begin: /\b(?<!\.)(from)\b(?=.+import)/dg,
            beginCaptures: {
                1: { token: KeywordTokenType.Import, /*keyword.control.import.python*/ },
            },
            end: /$|(?=import)/gm,
            patterns: [
                {
                    debugName: "importStatement.patterns![0].patterns![0]",

                    token: CharacterTokenType.Dot, /*punctuation.separator.dot.python*/
                    match: /\.+/g,
                },
                expression,
            ]
        },
        {
            debugName: "importStatement.patterns![1]",

            begin: /\b(?<!\.)(import)\b/dg,
            beginCaptures: {
                1: { token: KeywordTokenType.Import, /*keyword.control.import.python*/ },
            },
            end: /$/gm,
            patterns: [
                {
                    debugName: "importStatement.patterns![1].patterns![0]",

                    token: KeywordTokenType.Import, /*keyword.control.import.python*/
                    match: /\b(?<!\.)as\b/g,
                },
                expression,
            ]
        },
    ]
};

export const classDeclaration: TokenPattern = {
    patterns: [
        {
            debugName: "classDeclaration.patterns![0]",

            token: MetaTokenType.ClassDefinition, /*meta.class.python*/
            begin: /\s*(class)\s+(?=[a-zA-Z_]\w*\s*(?::|\())/dg,
            beginCaptures: {
                1: { token: KeywordTokenType.Class, /*storage.type.class.python*/ },
            },
            end: /(:)/dg,
            endCaptures: {
                1: { token: CharacterTokenType.Colon, /*punctuation.section.class.begin.python*/ },
            },
            patterns: []
        }]
};

export const className: TokenPattern = {
    patterns: [
        {
            debugName: "className.patterns![2]",

            token: EntityTokenType.ClassName, /*entity.name.type.class.python*/
            match: /\b([a-zA-Z_]\w*)\b/g,
        },
    ]
};

export const classInheritance: TokenPattern = {
    debugName: "classInheritance",

    token: MetaTokenType.ClassInheritance, /*meta.class.inheritance.python*/
    begin: /(\()/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.inheritance.begin.python*/ },
    },
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.inheritance.end.python*/ },
    },
    patterns: [
        {
            debugName: "classInheritance.patterns![0]",

            token: OperatorTokenType.Unpacking, /*keyword.operator.unpacking.arguments.python*/
            match: /(\*\*|\*)/g,
        },
        {
            debugName: "classInheritance.patterns![1]",

            token: CharacterTokenType.Comma, /*punctuation.separator.inheritance.python*/
            match: /,/g,
        },
        {
            debugName: "classInheritance.patterns![2]",

            token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/
            match: /=(?!=)/g,
        },
        {
            debugName: "classInheritance.patterns![3]",

            token: KeywordTokenType.Metaclass, /*support.type.metaclass.python*/
            match: /\bmetaclass\b/g,
        },
        expressionBase,
    ]
};

export const classKwarg: TokenPattern = {
    debugName: "classKwarg",

    match: /\b([a-zA-Z_]\w*)\s*(=)(?!=)/dg,
    captures: {
        1: { token: EntityTokenType.Identifier, /*entity.other.inherited-class.python variable.parameter.class.python*/ },
        2: { token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/ },
    },
};

export const inheritanceIdentifier: TokenPattern = {
    debugName: "inheritanceIdentifier",

    match: /\b([a-zA-Z_]\w*)\b/dg,
    captures: {
        1: { token: EntityTokenType.InheritedClassName, /*entity.other.inherited-class.python*/ },
    },
};

export const memberAccessClass: TokenPattern = {
    debugName: "memberAccessClass",

    token: MetaTokenType.MemberAccess, /*meta.member.access.python*/
    begin: /(\.)\s*(?!\.)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.Dot, /*punctuation.separator.dot.python*/ },
    },
    end: /(?<=\S)(?=\W)|$/gm,
    patterns: [
        memberAccessBase,
        inheritanceIdentifier,
    ]
};

export const lambda: TokenPattern = {
    patterns: [
        {
            debugName: "lambda.patterns![0]",

            match: /\b(lambda)\s*?(?=[,\n]|$)/dgm,
            captures: {
                1: { token: KeywordTokenType.Lambda, /*storage.type.function.lambda.python*/ },
            },
        },
        {
            debugName: "lambda.patterns![1]",

            token: MetaTokenType.LambdaFunction, /*meta.lambda-function.python*/
            contentToken: MetaTokenType.FunctionDefinition, /*meta.function.lambda.parameters.python*/
            begin: /\b(lambda)\b/dg,
            beginCaptures: {
                1: { token: KeywordTokenType.Lambda, /*storage.type.function.lambda.python*/ },
            },
            end: /(:)|(\n)/dg,
            endCaptures: {
                1: { token: CharacterTokenType.Colon, /*punctuation.section.function.lambda.begin.python*/ },
            },
            patterns: [
                {
                    debugName: "lambda.patterns![1].patterns![0]",

                    token: OperatorTokenType.PositionalParameter, /*keyword.operator.positional.parameter.python*/
                    match: /\//g,
                },
                {
                    debugName: "lambda.patterns![1].patterns![1]",

                    token: OperatorTokenType.Unpacking, /*keyword.operator.unpacking.parameter.python*/
                    match: /(\*\*|\*)/g,
                },
                {
                    debugName: "lambda.patterns![1].patterns![4]",

                    match: /([a-zA-Z_]\w*)\s*(?:(,)|(?=:|$))/dgm,
                    captures: {
                        1: { token: EntityTokenType.Identifier, /*variable.parameter.function.language.python*/ },
                        2: { token: CharacterTokenType.Comma, /*punctuation.separator.parameters.python*/ },
                    },
                },
                comments,
                lineContinuation,
            ]
        },
    ]
};

export const lambdaIncomplete: TokenPattern = {
    debugName: "lambdaIncomplete",

    token: KeywordTokenType.Lambda, /*storage.type.function.lambda.python*/
    match: /\blambda(?=\s*[,)])/g,
};

export const lambdaNestedIncomplete: TokenPattern = {
    debugName: "lambdaNestedIncomplete",

    token: KeywordTokenType.Lambda, /*storage.type.function.lambda.python*/
    match: /\blambda(?=\s*[:,)])/g,
};

export const lambdaParameterWithDefault: TokenPattern = {
    debugName: "lambdaParameterWithDefault",

    begin: /\b([a-zA-Z_]\w*)\s*(=)/dg,
    beginCaptures: {
        1: { token: EntityTokenType.Identifier, /*variable.parameter.function.language.python*/ },
        2: { token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/ },
    },
    end: /(,)|(?=:|$)/dgm,
    endCaptures: {
        1: { token: CharacterTokenType.Comma, /*punctuation.separator.parameters.python*/ },
    },
    patterns: [expression]
};

export const generator: TokenPattern = {
    debugName: "generator",

    // Match "for ... in" construct used in generators and for loops to correctly identify the "in" as a control flow keyword.
    begin: /\bfor\b/dg,
    beginCaptures: {
        0: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/ },
    },
    end: /\bin\b/dg,
    endCaptures: {
        0: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/ },
    },
    patterns: [expression]
};

export const functionDeclaration: TokenPattern = {
    debugName: "functionDeclaration",

    token: MetaTokenType.FunctionDefinition, /*meta.function.python*/
    begin: /\s*(?:\b(async)\s+)?\b(def)\s+(?=\w+\s*\()/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.Async, /*storage.type.function.async.python*/ },
        2: { token: KeywordTokenType.Def, /*storage.type.function.python*/ },
    },
    end: /(:|(?=[#'"\n]))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.Colon, /*punctuation.section.function.begin.python*/ },
    },
    patterns: [lineContinuation]
};

export const functionDefName: TokenPattern = {
    patterns: [
        {
            debugName: "functionDefName.patterns![2]",

            token: EntityTokenType.FunctionName, /*entity.name.function.python*/
            match: /\b([a-zA-Z_]\w*)\b/g,
        },
    ]
};

export const parameters: TokenPattern = {
    debugName: "parameters",

    token: MetaTokenType.FunctionDefinition, /*meta.function.parameters.python*/
    begin: /(\()/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.definition.parameters.begin.python*/ },
    },
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.parameters.end.python*/ },
    },
    patterns: [
        {
            debugName: "parameters.patterns![0]",

            token: OperatorTokenType.PositionalParameter, /*keyword.operator.positional.parameter.python*/
            match: /\//g,
        },
        {
            debugName: "parameters.patterns![1]",

            token: OperatorTokenType.Unpacking, /*keyword.operator.unpacking.parameter.python*/
            match: /(\*\*|\*)/g,
        },
        lambdaIncomplete,
        {
            debugName: "parameters.patterns![6]",

            match: /([a-zA-Z_]\w*)\s*(?:(,)|(?=[)#\n=]))/dg,
            captures: {
                1: { token: EntityTokenType.Identifier, /*variable.parameter.function.language.python*/ },
                2: { token: CharacterTokenType.Comma, /*punctuation.separator.parameters.python*/ },
            },
        },
        comments,
    ]
};

export const parameterSpecial: TokenPattern = {
    debugName: "parameterSpecial",

    match: /\b((self)|(cls))\b\s*(?:(,)|(?=\)))/dg,
    captures: {
        1: { token: EntityTokenType.Identifier, /*variable.parameter.function.language.python*/ },
        2: { token: EntityTokenType.Identifier, /*variable.parameter.function.language.special.self.python*/ },
        3: { token: EntityTokenType.Identifier, /*variable.parameter.function.language.special.cls.python*/ },
        4: { token: CharacterTokenType.Comma, /*punctuation.separator.parameters.python*/ },
    },
};

export const looseDefault: TokenPattern = {
    debugName: "looseDefault",

    begin: /(=)/dg,
    beginCaptures: {
        1: { token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/ },
    },
    end: /(,)|(?=\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.Comma, /*punctuation.separator.parameters.python*/ },
    },
    patterns: [expression]
};

export const annotatedParameter: TokenPattern = {
    debugName: "annotatedParameter",

    begin: /\b([a-zA-Z_]\w*)\s*(:)/dg,
    beginCaptures: {
        1: { token: EntityTokenType.Identifier, /*variable.parameter.function.language.python*/ },
        2: { token: CharacterTokenType.Colon, /*punctuation.separator.annotation.python*/ },
    },
    end: /(,)|(?=\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.Comma, /*punctuation.separator.parameters.python*/ },
    },
    patterns: [
        expression,
        {
            debugName: "annotatedParameter.patterns![1]",

            token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/
            match: /=(?!=)/g,
        },
    ]
};

export const returnAnnotation: TokenPattern = {
    debugName: "returnAnnotation",

    begin: /(->)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.Colon, /*punctuation.separator.annotation.result.python*/ },
    },
    end: /(?=:)/g,
    patterns: [expression]
};

export const itemAccess: TokenPattern = {
    patterns: [
        {
            debugName: "itemAccess.patterns![0]",

            token: MetaTokenType.ItemAccess, /*variable.name.python meta.item-access.python*/
            begin: /\b(?=[a-zA-Z_]\w*\s*\[)/g,
            end: /(\])/dg,
            endCaptures: {
                1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.python*/ },
            },
            patterns: [expression]
        },
    ]
};

export const itemName: TokenPattern = {
    patterns: [
        specialNames,
        {
            debugName: "itemName.patterns![3]",

            token: MetaTokenType.IndexedName, /*meta.indexed-name.python*/
            match: /\b([a-zA-Z_]\w*)\b/g,
        },
    ]
};

export const itemIndex: TokenPattern = {
    debugName: "itemIndex",

    contentToken: MetaTokenType.Arguments, /*meta.item-access.arguments.python*/
    begin: /(\[)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.definition.arguments.begin.python*/ },
    },
    end: /(?=\])/g,
    patterns: [
        {
            debugName: "itemIndex.patterns![0]",

            token: CharacterTokenType.Colon, /*punctuation.separator.slice.python*/
            match: /:/g,
        },
        expression,
    ]
};

export const decorator: TokenPattern = {
    debugName: "decorator",

    token: MetaTokenType.FunctionDefinition, /*meta.function.decorator.python*/
    begin: /(?<=^[ \t]*)(@)\s*(?=[a-zA-Z_]\w*)/dgm,
    beginCaptures: {
        1: { token: EntityTokenType.FunctionName, /*entity.name.function.decorator.python*/ },
        2: { token: CharacterTokenType.AtSymbol, /*punctuation.definition.decorator.python*/ },
    },
    end: /(\))(?:(.*?)(?=\s*(?:\#|$)))|(?=\n|\#)/dgm,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.decorator.python*/ },
    },
    patterns: [
    ]
};

export const decoratorName: TokenPattern = {
    patterns: [
        {
            debugName: "decoratorName.patterns![2]",

            token: EntityTokenType.FunctionName, /*entity.name.function.decorator.python*/
            match: /(?:[a-zA-Z_]\w*)|(\.)/dg,
            captures: {
                1: { token: CharacterTokenType.Dot, /*punctuation.separator.dot.python*/ },
            },
        },
        lineContinuation,
        {
            debugName: "decoratorName.patterns![4]",

            token: MetaTokenType.Invalid, /*invalid.illegal.decorator.python*/
            match: /\s*([^(a-zA-Z\s_\.#\\].*?)(?=\#|$)/dgm,
            captures: {
                1: { token: MetaTokenType.Invalid, /*invalid.illegal.decorator.python*/ },
            },
        },
    ]
};

export const callWrapperInheritance: TokenPattern = {
    debugName: "callWrapperInheritance",

    // same as a function call, but in inheritance context
    token: MetaTokenType.FunctionCall, /*meta.function-call.python*/
    begin: /\b(?=[a-zA-Z_]\w*\s*\()/g,
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.python*/ },
    },
    patterns: [
    ]
};

export const inheritanceName: TokenPattern = {
    patterns: [
        lambdaIncomplete,
        inheritanceIdentifier,
    ]
};

export const functionCall: TokenPattern = {
    debugName: "functionCall",

    // Regular function call of the type "name(args)"
    token: MetaTokenType.FunctionCall, /*meta.function-call.python*/
    begin: /\b(?=[a-zA-Z_]\w*\s*\()/g,
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.python*/ },
    },
    patterns: [
    ]
};

export const functionName: TokenPattern = {
    patterns: [
        {
            debugName: "functionName.patterns![1]",

            // Some color schemas support meta.function-call.generic scope
            token: MetaTokenType.FunctionCall, /*entity.name.function.call.python meta.function-call.generic.python*/
            match: /\b[a-zA-Z_]\w*\b/g,
        },
    ]
};

export const functionArguments: TokenPattern = {
    debugName: "functionArguments",

    contentToken: MetaTokenType.Arguments, /*meta.function-call.arguments.python*/
    begin: /(\()/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.definition.arguments.begin.python*/ },
    },
    end: /(?=\))(?!\)\s*\()/g,
    patterns: [
        {
            debugName: "functionArguments.patterns![0]",

            token: CharacterTokenType.Comma, /*punctuation.separator.arguments.python*/
            match: /(,)/g,
        },
        {
            debugName: "functionArguments.patterns![1]",

            match: /(?:(?<=[,(])|^)\s*(\*{1,2})/dgm,
            captures: {
                1: { token: OperatorTokenType.Unpacking, /*keyword.operator.unpacking.arguments.python*/ },
            },
        },
        lambdaIncomplete,
        {
            debugName: "functionArguments.patterns![4]",

            match: /\b([a-zA-Z_]\w*)(\s+)?(=)(?!=)/dg,
            captures: {
                1: { token: EntityTokenType.Identifier, /*variable.parameter.function-call.python*/ },
                2: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.python*/ },
                3: { token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/ },
            },
        },
        {
            debugName: "functionArguments.patterns![5]",

            token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/
            match: /=(?!=)/g,
        },
        expression,
        {
            debugName: "functionArguments.patterns![7]",

            match: /\s*(\))\s*(\()/dg,
            captures: {
                1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.python*/ },
                2: { token: CharacterTokenType.OpenParentheses, /*punctuation.definition.arguments.begin.python*/ },
            },
        },
    ]
};

export const builtinCallables: TokenPattern = {
    patterns: []
};

export const builtinPossibleCallables: TokenPattern = {
    patterns: [
        builtinCallables]
};

export const builtinExceptions: TokenPattern = {
    debugName: "builtinExceptions",

    token: MetaTokenType.BuiltinExceptionType, /*support.type.exception.python*/
    match: /\b(?<!\.)((Arithmetic|Assertion|Attribute|Buffer|BlockingIO|BrokenPipe|ChildProcess|(Connection(Aborted|Refused|Reset)?)|EOF|Environment|FileExists|FileNotFound|FloatingPoint|IO|Import|Indentation|Index|Interrupted|IsADirectory|NotADirectory|Permission|ProcessLookup|Timeout|Key|Lookup|Memory|Name|NotImplemented|OS|Overflow|Reference|Runtime|Recursion|Syntax|System|Tab|Type|UnboundLocal|Unicode(Encode|Decode|Translate)?|Value|Windows|ZeroDivision|ModuleNotFound)Error|((Pending)?Deprecation|Runtime|Syntax|User|Future|Import|Unicode|Bytes|Resource)?Warning|SystemExit|Stop(Async)?Iteration|KeyboardInterrupt|GeneratorExit|(Base)?Exception)\b/g,
};

export const builtinFunctions: TokenPattern = {
    patterns: [
        {
            debugName: "builtinFunctions.patterns![0]",

            token: EntityTokenType.FunctionName, /*support.function.builtin.python*/
            match: /\b(?<!\.)(__import__|abs|aiter|all|any|anext|ascii|bin|breakpoint|callable|chr|compile|copyright|credits|delattr|dir|divmod|enumerate|eval|exec|exit|filter|format|getattr|globals|hasattr|hash|help|hex|id|input|isinstance|issubclass|iter|len|license|locals|map|max|memoryview|min|next|oct|open|ord|pow|print|quit|range|reload|repr|reversed|round|setattr|sorted|sum|vars|zip)\b/g,
        },
        {
            debugName: "builtinFunctions.patterns![1]",

            token: EntityTokenType.Identifier, /*variable.legacy.builtin.python*/
            match: /\b(?<!\.)(file|reduce|intern|raw_input|unicode|cmp|basestring|execfile|long|xrange)\b/g,
        },
    ]
};

export const builtinTypes: TokenPattern = {
    debugName: "builtinTypes",

    token: MetaTokenType.BuiltinType, /*support.type.python*/
    match: /\b(?<!\.)(bool|bytearray|bytes|classmethod|complex|dict|float|frozenset|int|list|object|property|set|slice|staticmethod|str|tuple|type|super)\b/g,
};

export const magicFunctionNames: TokenPattern = {
    debugName: "magicFunctionNames",

    // these methods have magic interpretation by python and are generally calledindirectly through syntactic constructs
    match: /\b(__(?:abs|add|aenter|aexit|aiter|and|anext|await|bool|call|ceil|class_getitem|cmp|coerce|complex|contains|copy|deepcopy|del|delattr|delete|delitem|delslice|dir|div|divmod|enter|eq|exit|float|floor|floordiv|format|ge|get|getattr|getattribute|getinitargs|getitem|getnewargs|getslice|getstate|gt|hash|hex|iadd|iand|idiv|ifloordiv||ilshift|imod|imul|index|init|instancecheck|int|invert|ior|ipow|irshift|isub|iter|itruediv|ixor|le|len|long|lshift|lt|missing|mod|mul|ne|neg|new|next|nonzero|oct|or|pos|pow|radd|rand|rdiv|rdivmod|reduce|reduce_ex|repr|reversed|rfloordiv||rlshift|rmod|rmul|ror|round|rpow|rrshift|rshift|rsub|rtruediv|rxor|set|setattr|setitem|set_name|setslice|setstate|sizeof|str|sub|subclasscheck|truediv|trunc|unicode|xor|matmul|rmatmul|imatmul|init_subclass|set_name|fspath|bytes|prepare|length_hint)__)\b/dg,
    captures: {
        1: { token: EntityTokenType.FunctionName, /*support.function.magic.python*/ },
    },
};

export const magicVariableNames: TokenPattern = {
    debugName: "magicVariableNames",

    // magic variables which a class/module may have.
    match: /\b(__(?:all|annotations|bases|builtins|class|closure|code|debug|defaults|dict|doc|file|func|globals|kwdefaults|match_args|members|metaclass|methods|module|mro|mro_entries|name|qualname|post_init|self|signature|slots|subclasses|version|weakref|wrapped|classcell|spec|path|package|future|traceback)__)\b/dg,
    captures: {
        1: { token: EntityTokenType.Identifier, /*support.variable.magic.python*/ },
    },
};

export const magicNames: TokenPattern = {
    patterns: [
        magicFunctionNames,
        magicVariableNames,
    ]
};

export const illegalNames: TokenPattern = {
    debugName: "illegalNames",

    match: /\b(?:(and|assert|async|await|break|class|continue|def|del|elif|else|except|finally|for|from|global|if|in|is|(?<=\.)lambda|lambda(?=\s*[\.=])|nonlocal|not|or|pass|raise|return|try|while|with|yield)|(as|import))\b/dg,
    captures: {
        1: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/ },
        2: { token: KeywordTokenType.Import, /*keyword.control.import.python*/ },
    },
};

export const specialVariables: TokenPattern = {
    debugName: "specialVariables",

    match: /\b(?<!\.)(?:(self)|(cls))\b/dg,
    captures: {
        1: { token: EntityTokenType.Identifier, /*variable.language.special.self.python*/ },
        2: { token: EntityTokenType.Identifier, /*variable.language.special.cls.python*/ },
    },
};

export const ellipsis: TokenPattern = {
    debugName: "ellipsis",

    token: MetaTokenType.ConstantCaps, /*constant.other.ellipsis.python*/
    match: /\.\.\./g,
};

export const backticks: TokenPattern = {
    debugName: "backticks",

    token: MetaTokenType.Deprecated, /*invalid.deprecated.backtick.python*/
    begin: /\`/g,
    end: /(?:\`|(?<!\\)(\n))/g,
    patterns: [expression]
};

export const illegalOperator: TokenPattern = {
    patterns: [
        {
            debugName: "illegalOperator.patterns![0]",

            token: MetaTokenType.Invalid, /*invalid.illegal.operator.python*/
            match: /&&|\|\||--|\+\+/g,
        },
        {
            debugName: "illegalOperator.patterns![1]",

            token: MetaTokenType.Invalid, /*invalid.illegal.operator.python*/
            match: /[?$]/gm,
        },
        {
            debugName: "illegalOperator.patterns![2]",

            // We don't want `!` to flash when we're typing `!=`
            token: MetaTokenType.Invalid, /*invalid.illegal.operator.python*/
            match: /!\b/g,
        },
    ]
};

export const illegalObjectName: TokenPattern = {
    debugName: "illegalObjectName",

    // It's illegal to name class or function "True"
    token: MetaTokenType.Invalid, /*keyword.illegal.name.python*/
    match: /\b(True|False|None)\b/g,
};

export const illegalAnno: TokenPattern = {
    debugName: "illegalAnno",

    token: MetaTokenType.Invalid, /*invalid.illegal.annotation.python*/
    match: /->/g,
};

export const regexpBaseExpression: TokenPattern = {
    patterns: [
    ]
};

export const fregexpBaseExpression: TokenPattern = {
    patterns: [
        {
            debugName: "fregexpBaseExpression.patterns![2]",

            match: /\{.*?\}/g,
        },
    ]
};

export const fstringFormattingBraces: TokenPattern = {
    patterns: [
        {
            debugName: "fstringFormattingBraces.patterns![0]",

            // empty braces are illegal
            match: /({)(\s*?)(})/dg,
            captures: {
                1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.brace.python*/ },
                3: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
            },
        },
        {
            debugName: "fstringFormattingBraces.patterns![1]",

            token: MetaTokenType.EscapeSequence, /*constant.character.escape.python*/
            match: /({{|}})/g,
        },
    ]
};

export const regexpBaseCommon: TokenPattern = {
    patterns: [
        {
            debugName: "regexpBaseCommon.patterns![0]",

            token: CharacterTokenType.Dot, /*support.other.match.any.regexp*/
            match: /\./g,
        },
        {
            debugName: "regexpBaseCommon.patterns![1]",

            token: CharacterTokenType.Caret, /*support.other.match.begin.regexp*/
            match: /\^/gm,
        },
        {
            debugName: "regexpBaseCommon.patterns![2]",

            token: CharacterTokenType.DollarSymbol, /*support.other.match.end.regexp*/
            match: /\$/gm,
        },
        {
            debugName: "regexpBaseCommon.patterns![3]",

            token: OperatorTokenType.Quantifier, /*keyword.operator.quantifier.regexp*/
            match: /[+*?]\??/g,
        },
        {
            debugName: "regexpBaseCommon.patterns![4]",

            token: OperatorTokenType.Disjunction, /*keyword.operator.disjunction.regexp*/
            match: /\|/g,
        },
    ]
};

export const regexpQuantifier: TokenPattern = {
    debugName: "regexpQuantifier",

    token: OperatorTokenType.Quantifier, /*keyword.operator.quantifier.regexp*/
    match: /\{(\d+|\d+,(\d+)?|,\d+)\}/g,
};

export const fregexpQuantifier: TokenPattern = {
    debugName: "fregexpQuantifier",

    token: OperatorTokenType.Quantifier, /*keyword.operator.quantifier.regexp*/
    match: /\{\{(\d+|\d+,(\d+)?|,\d+)\}\}/g,
};

export const regexpBackreferenceNumber: TokenPattern = {
    debugName: "regexpBackreferenceNumber",

    token: MetaTokenType.Backreference, /*meta.backreference.regexp*/
    match: /(\\[1-9]\d?)/dg,
    captures: {
        1: { token: EntityTokenType.TagName, /*entity.name.tag.backreference.regexp*/ },
    },
};

export const regexpBackreference: TokenPattern = {
    debugName: "regexpBackreference",

    token: MetaTokenType.BackreferenceNamed, /*meta.backreference.named.regexp*/
    match: /(\()(\?P=\w+(?:\s+[a-zA-Z0-9]+)?)(\))/dg,
    captures: {
        1: { token: CharacterTokenType.OpenParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.begin.backreference.named.regexp*/ },
        2: { token: EntityTokenType.TagName, /*entity.name.tag.named.backreference.regexp*/ },
        3: { token: CharacterTokenType.CloseParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.end.backreference.named.regexp*/ },
    },
};

export const regexpFlags: TokenPattern = {
    debugName: "regexpFlags",

    token: MetaTokenType.ModifierFlagStorageType, /*storage.modifier.flag.regexp*/
    match: /\(\?[aiLmsux]+\)/g,
};

export const regexpEscapeSpecial: TokenPattern = {
    debugName: "regexpEscapeSpecial",

    token: MetaTokenType.EscapeSequence, /*support.other.escape.special.regexp*/
    match: /\\([AbBdDsSwWZ])/g,
};

export const regexpEscapeCharacter: TokenPattern = {
    debugName: "regexpEscapeCharacter",

    token: MetaTokenType.EscapeSequence, /*constant.character.escape.regexp*/
    match: /\\(x[0-9A-Fa-f]{2}|0[0-7]{1,2}|[0-7]{3})/g,
};

export const regexpEscapeUnicode: TokenPattern = {
    debugName: "regexpEscapeUnicode",

    token: MetaTokenType.EscapeSequence, /*constant.character.unicode.regexp*/
    match: /\\(u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/g,
};

export const regexpEscapeCatchall: TokenPattern = {
    debugName: "regexpEscapeCatchall",

    token: MetaTokenType.EscapeSequence, /*constant.character.escape.regexp*/
    match: /\\(.|\n)/g,
};

export const regexpEscapeSequence: TokenPattern = {
    patterns: [
        regexpEscapeSpecial,
        regexpEscapeCharacter,
        regexpEscapeUnicode,
        regexpBackreferenceNumber,
        regexpEscapeCatchall,
    ]
};

export const regexpCharecterSetEscapes: TokenPattern = {
    patterns: [
        {
            debugName: "regexpCharecterSetEscapes.patterns![0]",

            token: MetaTokenType.EscapeSequence, /*constant.character.escape.regexp*/
            match: /\\[abfnrtv\\]/g,
        },
        regexpEscapeSpecial,
        {
            debugName: "regexpCharecterSetEscapes.patterns![2]",

            token: MetaTokenType.EscapeSequence, /*constant.character.escape.regexp*/
            match: /\\([0-7]{1,3})/g,
        },
        regexpEscapeCharacter,
        regexpEscapeUnicode,
        regexpEscapeCatchall,
    ]
};

export const commentsStringSingleThree: TokenPattern = {
    debugName: "commentsStringSingleThree",

    token: MetaTokenType.Comment, /*comment.line.number-sign.python*/
    begin: /(\#)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.Hashtag, /*punctuation.definition.comment.python*/ },
    },
    end: /($|(?='''))/gm,
    patterns: [
    ]
};

export const commentsStringDoubleThree: TokenPattern = {
    debugName: "commentsStringDoubleThree",

    token: MetaTokenType.Comment, /*comment.line.number-sign.python*/
    begin: /(\#)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.Hashtag, /*punctuation.definition.comment.python*/ },
    },
    end: /($|(?="""))/gm,
    patterns: [
    ]
};

export const singleOneRegexpExpression: TokenPattern = {
    patterns: [
        regexpBaseExpression,
        regexpFlags,
        regexpBackreference,
    ]
};

export const singleOneRegexpCharacterSet: TokenPattern = {
    patterns: [
        {
            debugName: "singleOneRegexpCharacterSet.patterns![0]",

            match: /\[\^?\](?!.*?\])/gm,
        },
        {
            debugName: "singleOneRegexpCharacterSet.patterns![1]",

            token: MetaTokenType.CharacterSet, /*meta.character.set.regexp*/
            begin: /(\[)(\^)?(\])?/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.OpenSquareBracket, /*constant.other.set.regexp punctuation.character.set.begin.regexp*/ },
                2: { token: OperatorTokenType.Negation, /*keyword.operator.negation.regexp*/ },
                3: { token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/ },
            },
            end: /(\]|(?=\'))|((?=(?<!\\)\n))/dg,
            endCaptures: {
                1: { token: CharacterTokenType.CloseSquareBracket, /*constant.other.set.regexp punctuation.character.set.end.regexp*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
            },
            patterns: [
                regexpCharecterSetEscapes,
                {
                    debugName: "singleOneRegexpCharacterSet.patterns![1].patterns![1]",

                    token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/
                    match: /[^\n]/g,
                },
            ]
        },
    ]
};

export const singleOneRegexpNamedGroup: TokenPattern = {
    debugName: "singleOneRegexpNamedGroup",

    token: MetaTokenType.Named, /*meta.named.regexp*/
    begin: /(\()(\?P<\w+(?:\s+[a-zA-Z0-9]+)?>)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.begin.named.regexp*/ },
        2: { token: EntityTokenType.TagName, /*entity.name.tag.named.group.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.end.named.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [singleOneRegexpExpression]
};

export const singleOneRegexpComments: TokenPattern = {
    debugName: "singleOneRegexpComments",

    token: MetaTokenType.Comment, /*comment.regexp*/
    begin: /\(\?#/dg,
    beginCaptures: {
        0: { token: MetaTokenType.CommentBegin, /*punctuation.comment.begin.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: MetaTokenType.CommentEnd, /*punctuation.comment.end.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
    ]
};

export const singleOneRegexpLookahead: TokenPattern = {
    debugName: "singleOneRegexpLookahead",

    begin: /(\()\?=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookahead, /*keyword.operator.lookahead.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookahead.regexp punctuation.parenthesis.end.lookahead.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [singleOneRegexpExpression]
};

export const singleOneRegexpLookaheadNegative: TokenPattern = {
    debugName: "singleOneRegexpLookaheadNegative",

    begin: /(\()\?!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookaheadNegative, /*keyword.operator.lookahead.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookahead.negative.regexp punctuation.parenthesis.end.lookahead.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [singleOneRegexpExpression]
};

export const singleOneRegexpLookbehind: TokenPattern = {
    debugName: "singleOneRegexpLookbehind",

    begin: /(\()\?<=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookbehind, /*keyword.operator.lookbehind.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookbehind.regexp punctuation.parenthesis.end.lookbehind.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [singleOneRegexpExpression]
};

export const singleOneRegexpLookbehindNegative: TokenPattern = {
    debugName: "singleOneRegexpLookbehindNegative",

    begin: /(\()\?<!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookbehindNegative, /*keyword.operator.lookbehind.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.end.lookbehind.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [singleOneRegexpExpression]
};

export const singleOneRegexpConditional: TokenPattern = {
    debugName: "singleOneRegexpConditional",

    begin: /(\()\?\((\w+(?:\s+[a-zA-Z0-9]+)?|\d+)\)/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Conditional, /*keyword.operator.conditional.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.conditional.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.conditional.negative.regexp punctuation.parenthesis.end.conditional.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [singleOneRegexpExpression]
};

export const singleOneRegexpParenthesesNonCapturing: TokenPattern = {
    debugName: "singleOneRegexpParenthesesNonCapturing",

    begin: /\(\?:/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.begin.non-capturing.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.end.non-capturing.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [singleOneRegexpExpression]
};

export const singleOneRegexpParentheses: TokenPattern = {
    debugName: "singleOneRegexpParentheses",

    begin: /\(/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.end.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [singleOneRegexpExpression]
};

export const singleThreeRegexpExpression: TokenPattern = {
    patterns: [
        regexpBaseExpression,
        regexpFlags,
        regexpBackreference,
        commentsStringSingleThree,
    ]
};

export const singleThreeRegexpCharacterSet: TokenPattern = {
    patterns: [
        {
            debugName: "singleThreeRegexpCharacterSet.patterns![0]",

            match: /\[\^?\](?!.*?\])/gm,
        },
        {
            debugName: "singleThreeRegexpCharacterSet.patterns![1]",

            token: MetaTokenType.CharacterSet, /*meta.character.set.regexp*/
            begin: /(\[)(\^)?(\])?/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.OpenSquareBracket, /*constant.other.set.regexp punctuation.character.set.begin.regexp*/ },
                2: { token: OperatorTokenType.Negation, /*keyword.operator.negation.regexp*/ },
                3: { token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/ },
            },
            end: /(\]|(?=\'\'\'))/dg,
            endCaptures: {
                1: { token: CharacterTokenType.CloseSquareBracket, /*constant.other.set.regexp punctuation.character.set.end.regexp*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
            },
            patterns: [
                regexpCharecterSetEscapes,
                {
                    debugName: "singleThreeRegexpCharacterSet.patterns![1].patterns![1]",

                    token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/
                    match: /[^\n]/g,
                },
            ]
        },
    ]
};

export const singleThreeRegexpNamedGroup: TokenPattern = {
    debugName: "singleThreeRegexpNamedGroup",

    token: MetaTokenType.Named, /*meta.named.regexp*/
    begin: /(\()(\?P<\w+(?:\s+[a-zA-Z0-9]+)?>)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.begin.named.regexp*/ },
        2: { token: EntityTokenType.TagName, /*entity.name.tag.named.group.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.end.named.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        singleThreeRegexpExpression,
        commentsStringSingleThree,
    ]
};

export const singleThreeRegexpComments: TokenPattern = {
    debugName: "singleThreeRegexpComments",

    token: MetaTokenType.Comment, /*comment.regexp*/
    begin: /\(\?#/dg,
    beginCaptures: {
        0: { token: MetaTokenType.CommentBegin, /*punctuation.comment.begin.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: MetaTokenType.CommentEnd, /*punctuation.comment.end.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
    ]
};

export const singleThreeRegexpLookahead: TokenPattern = {
    debugName: "singleThreeRegexpLookahead",

    begin: /(\()\?=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookahead, /*keyword.operator.lookahead.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookahead.regexp punctuation.parenthesis.end.lookahead.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        singleThreeRegexpExpression,
        commentsStringSingleThree,
    ]
};

export const singleThreeRegexpLookaheadNegative: TokenPattern = {
    debugName: "singleThreeRegexpLookaheadNegative",

    begin: /(\()\?!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookaheadNegative, /*keyword.operator.lookahead.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookahead.negative.regexp punctuation.parenthesis.end.lookahead.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        singleThreeRegexpExpression,
        commentsStringSingleThree,
    ]
};

export const singleThreeRegexpLookbehind: TokenPattern = {
    debugName: "singleThreeRegexpLookbehind",

    begin: /(\()\?<=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookbehind, /*keyword.operator.lookbehind.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookbehind.regexp punctuation.parenthesis.end.lookbehind.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        singleThreeRegexpExpression,
        commentsStringSingleThree,
    ]
};

export const singleThreeRegexpLookbehindNegative: TokenPattern = {
    debugName: "singleThreeRegexpLookbehindNegative",

    begin: /(\()\?<!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookbehindNegative, /*keyword.operator.lookbehind.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.end.lookbehind.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        singleThreeRegexpExpression,
        commentsStringSingleThree,
    ]
};

export const singleThreeRegexpConditional: TokenPattern = {
    debugName: "singleThreeRegexpConditional",

    begin: /(\()\?\((\w+(?:\s+[a-zA-Z0-9]+)?|\d+)\)/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Conditional, /*keyword.operator.conditional.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.conditional.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.conditional.negative.regexp punctuation.parenthesis.end.conditional.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        singleThreeRegexpExpression,
        commentsStringSingleThree,
    ]
};

export const singleThreeRegexpParenthesesNonCapturing: TokenPattern = {
    debugName: "singleThreeRegexpParenthesesNonCapturing",

    begin: /\(\?:/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.begin.non-capturing.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.end.non-capturing.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        singleThreeRegexpExpression,
        commentsStringSingleThree,
    ]
};

export const singleThreeRegexpParentheses: TokenPattern = {
    debugName: "singleThreeRegexpParentheses",

    begin: /\(/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.end.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        singleThreeRegexpExpression,
        commentsStringSingleThree,
    ]
};

export const doubleOneRegexpExpression: TokenPattern = {
    patterns: [
        regexpBaseExpression,
        regexpFlags,
        regexpBackreference,
    ]
};

export const doubleOneRegexpCharacterSet: TokenPattern = {
    patterns: [
        {
            debugName: "doubleOneRegexpCharacterSet.patterns![0]",

            match: /\[\^?\](?!.*?\])/gm,
        },
        {
            debugName: "doubleOneRegexpCharacterSet.patterns![1]",

            token: MetaTokenType.CharacterSet, /*meta.character.set.regexp*/
            begin: /(\[)(\^)?(\])?/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.OpenSquareBracket, /*constant.other.set.regexp punctuation.character.set.begin.regexp*/ },
                2: { token: OperatorTokenType.Negation, /*keyword.operator.negation.regexp*/ },
                3: { token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/ },
            },
            end: /(\]|(?="))|((?=(?<!\\)\n))/dg,
            endCaptures: {
                1: { token: CharacterTokenType.CloseSquareBracket, /*constant.other.set.regexp punctuation.character.set.end.regexp*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
            },
            patterns: [
                regexpCharecterSetEscapes,
                {
                    debugName: "doubleOneRegexpCharacterSet.patterns![1].patterns![1]",

                    token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/
                    match: /[^\n]/g,
                },
            ]
        },
    ]
};

export const doubleOneRegexpNamedGroup: TokenPattern = {
    debugName: "doubleOneRegexpNamedGroup",

    token: MetaTokenType.Named, /*meta.named.regexp*/
    begin: /(\()(\?P<\w+(?:\s+[a-zA-Z0-9]+)?>)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.begin.named.regexp*/ },
        2: { token: EntityTokenType.TagName, /*entity.name.tag.named.group.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.end.named.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [doubleOneRegexpExpression]
};

export const doubleOneRegexpComments: TokenPattern = {
    debugName: "doubleOneRegexpComments",

    token: MetaTokenType.Comment, /*comment.regexp*/
    begin: /\(\?#/dg,
    beginCaptures: {
        0: { token: MetaTokenType.CommentBegin, /*punctuation.comment.begin.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: MetaTokenType.CommentEnd, /*punctuation.comment.end.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
    ]
};

export const doubleOneRegexpLookahead: TokenPattern = {
    debugName: "doubleOneRegexpLookahead",

    begin: /(\()\?=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookahead, /*keyword.operator.lookahead.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookahead.regexp punctuation.parenthesis.end.lookahead.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [doubleOneRegexpExpression]
};

export const doubleOneRegexpLookaheadNegative: TokenPattern = {
    debugName: "doubleOneRegexpLookaheadNegative",

    begin: /(\()\?!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookaheadNegative, /*keyword.operator.lookahead.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookahead.negative.regexp punctuation.parenthesis.end.lookahead.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [doubleOneRegexpExpression]
};

export const doubleOneRegexpLookbehind: TokenPattern = {
    debugName: "doubleOneRegexpLookbehind",

    begin: /(\()\?<=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookbehind, /*keyword.operator.lookbehind.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookbehind.regexp punctuation.parenthesis.end.lookbehind.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [doubleOneRegexpExpression]
};

export const doubleOneRegexpLookbehindNegative: TokenPattern = {
    debugName: "doubleOneRegexpLookbehindNegative",

    begin: /(\()\?<!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookbehindNegative, /*keyword.operator.lookbehind.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.end.lookbehind.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [doubleOneRegexpExpression]
};

export const doubleOneRegexpConditional: TokenPattern = {
    debugName: "doubleOneRegexpConditional",

    begin: /(\()\?\((\w+(?:\s+[a-zA-Z0-9]+)?|\d+)\)/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Conditional, /*keyword.operator.conditional.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.conditional.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.conditional.negative.regexp punctuation.parenthesis.end.conditional.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [doubleOneRegexpExpression]
};

export const doubleOneRegexpParenthesesNonCapturing: TokenPattern = {
    debugName: "doubleOneRegexpParenthesesNonCapturing",

    begin: /\(\?:/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.begin.non-capturing.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.end.non-capturing.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [doubleOneRegexpExpression]
};

export const doubleOneRegexpParentheses: TokenPattern = {
    debugName: "doubleOneRegexpParentheses",

    begin: /\(/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.end.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [doubleOneRegexpExpression]
};

export const doubleThreeRegexpExpression: TokenPattern = {
    patterns: [
        regexpBaseExpression,
        regexpFlags,
        regexpBackreference,
        commentsStringDoubleThree,
    ]
};

export const doubleThreeRegexpCharacterSet: TokenPattern = {
    patterns: [
        {
            debugName: "doubleThreeRegexpCharacterSet.patterns![0]",

            match: /\[\^?\](?!.*?\])/gm,
        },
        {
            debugName: "doubleThreeRegexpCharacterSet.patterns![1]",

            token: MetaTokenType.CharacterSet, /*meta.character.set.regexp*/
            begin: /(\[)(\^)?(\])?/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.OpenSquareBracket, /*constant.other.set.regexp punctuation.character.set.begin.regexp*/ },
                2: { token: OperatorTokenType.Negation, /*keyword.operator.negation.regexp*/ },
                3: { token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/ },
            },
            end: /(\]|(?="""))/dg,
            endCaptures: {
                1: { token: CharacterTokenType.CloseSquareBracket, /*constant.other.set.regexp punctuation.character.set.end.regexp*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
            },
            patterns: [
                regexpCharecterSetEscapes,
                {
                    debugName: "doubleThreeRegexpCharacterSet.patterns![1].patterns![1]",

                    token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/
                    match: /[^\n]/g,
                },
            ]
        },
    ]
};

export const doubleThreeRegexpNamedGroup: TokenPattern = {
    debugName: "doubleThreeRegexpNamedGroup",

    token: MetaTokenType.Named, /*meta.named.regexp*/
    begin: /(\()(\?P<\w+(?:\s+[a-zA-Z0-9]+)?>)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.begin.named.regexp*/ },
        2: { token: EntityTokenType.TagName, /*entity.name.tag.named.group.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.end.named.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        doubleThreeRegexpExpression,
        commentsStringDoubleThree,
    ]
};

export const doubleThreeRegexpComments: TokenPattern = {
    debugName: "doubleThreeRegexpComments",

    token: MetaTokenType.Comment, /*comment.regexp*/
    begin: /\(\?#/dg,
    beginCaptures: {
        0: { token: MetaTokenType.CommentBegin, /*punctuation.comment.begin.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: MetaTokenType.CommentEnd, /*punctuation.comment.end.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
    ]
};

export const doubleThreeRegexpLookahead: TokenPattern = {
    debugName: "doubleThreeRegexpLookahead",

    begin: /(\()\?=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookahead, /*keyword.operator.lookahead.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookahead.regexp punctuation.parenthesis.end.lookahead.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        doubleThreeRegexpExpression,
        commentsStringDoubleThree,
    ]
};

export const doubleThreeRegexpLookaheadNegative: TokenPattern = {
    debugName: "doubleThreeRegexpLookaheadNegative",

    begin: /(\()\?!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookaheadNegative, /*keyword.operator.lookahead.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookahead.negative.regexp punctuation.parenthesis.end.lookahead.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        doubleThreeRegexpExpression,
        commentsStringDoubleThree,
    ]
};

export const doubleThreeRegexpLookbehind: TokenPattern = {
    debugName: "doubleThreeRegexpLookbehind",

    begin: /(\()\?<=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookbehind, /*keyword.operator.lookbehind.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookbehind.regexp punctuation.parenthesis.end.lookbehind.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        doubleThreeRegexpExpression,
        commentsStringDoubleThree,
    ]
};

export const doubleThreeRegexpLookbehindNegative: TokenPattern = {
    debugName: "doubleThreeRegexpLookbehindNegative",

    begin: /(\()\?<!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookbehindNegative, /*keyword.operator.lookbehind.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.end.lookbehind.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        doubleThreeRegexpExpression,
        commentsStringDoubleThree,
    ]
};

export const doubleThreeRegexpConditional: TokenPattern = {
    debugName: "doubleThreeRegexpConditional",

    begin: /(\()\?\((\w+(?:\s+[a-zA-Z0-9]+)?|\d+)\)/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Conditional, /*keyword.operator.conditional.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.conditional.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*keyword.operator.conditional.negative.regexp punctuation.parenthesis.end.conditional.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        doubleThreeRegexpExpression,
        commentsStringDoubleThree,
    ]
};

export const doubleThreeRegexpParenthesesNonCapturing: TokenPattern = {
    debugName: "doubleThreeRegexpParenthesesNonCapturing",

    begin: /\(\?:/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.begin.non-capturing.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.end.non-capturing.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        doubleThreeRegexpExpression,
        commentsStringDoubleThree,
    ]
};

export const doubleThreeRegexpParentheses: TokenPattern = {
    debugName: "doubleThreeRegexpParentheses",

    begin: /\(/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*support.other.parenthesis.regexp punctuation.parenthesis.end.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        doubleThreeRegexpExpression,
        commentsStringDoubleThree,
    ]
};

export const regexpSingleOneLine: TokenPattern = {
    debugName: "regexpSingleOneLine",

    token: LiteralTokenType.String, /*string.regexp.quoted.single.python*/
    begin: /\b(?:([uU]r)|([bB]r)|(r[bB]?))(\')/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Deprecated, /*invalid.deprecated.prefix.python*/ },
        2: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        3: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        4: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(\')|(?<!\\)(\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [singleOneRegexpExpression]
};

export const regexpSingleThreeLine: TokenPattern = {
    debugName: "regexpSingleThreeLine",

    token: LiteralTokenType.String, /*string.regexp.quoted.multi.python*/
    begin: /\b(?:([uU]r)|([bB]r)|(r[bB]?))(\'\'\')/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Deprecated, /*invalid.deprecated.prefix.python*/ },
        2: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        3: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        4: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(\'\'\')/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [singleThreeRegexpExpression]
};

export const regexpDoubleOneLine: TokenPattern = {
    debugName: "regexpDoubleOneLine",

    token: LiteralTokenType.String, /*string.regexp.quoted.single.python*/
    begin: /\b(?:([uU]r)|([bB]r)|(r[bB]?))(")/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Deprecated, /*invalid.deprecated.prefix.python*/ },
        2: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        3: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        4: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(")|(?<!\\)(\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [doubleOneRegexpExpression]
};

export const regexpDoubleThreeLine: TokenPattern = {
    debugName: "regexpDoubleThreeLine",

    token: LiteralTokenType.String, /*string.regexp.quoted.multi.python*/
    begin: /\b(?:([uU]r)|([bB]r)|(r[bB]?))(""")/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Deprecated, /*invalid.deprecated.prefix.python*/ },
        2: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        3: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        4: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(""")/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [doubleThreeRegexpExpression]
};

export const stringRawQuotedSingleLine: TokenPattern = {
    debugName: "stringRawQuotedSingleLine",

    token: LiteralTokenType.String, /*string.quoted.raw.single.python*/
    begin: /\b(?:([uU]R)|(R))(['"])/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Deprecated, /*invalid.deprecated.prefix.python*/ },
        2: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        3: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /(\4)|((?<!\\)\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [stringRawGuts]
};

export const stringBinQuotedSingleLine: TokenPattern = {
    debugName: "stringBinQuotedSingleLine",

    token: LiteralTokenType.String, /*string.quoted.binary.single.python*/
    begin: /(\b[bB])(['"])/dg,
    beginCaptures: {
        1: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        2: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /(\2)|((?<!\\)\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [stringEntity]
};

export const stringRawBinQuotedSingleLine: TokenPattern = {
    debugName: "stringRawBinQuotedSingleLine",

    token: LiteralTokenType.String, /*string.quoted.raw.binary.single.python*/
    begin: /(\b(?:R[bB]|[bB]R))(['"])/dg,
    beginCaptures: {
        1: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        2: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /(\2)|((?<!\\)\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [stringRawBinGuts]
};

export const stringQuotedSingleLine: TokenPattern = {
    debugName: "stringQuotedSingleLine",

    token: LiteralTokenType.String, /*string.quoted.single.python*/
    begin: /(\b[rRuU])?(\b\w+)?(['"])/dg,
    beginCaptures: {
        1: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.prefix.python*/ },
        3: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /(\3)|((?<!\\)\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [stringUnicodeGuts]
};

export const stringSingleBadBrace1FormattingUnicode: TokenPattern = {
    debugName: "stringSingleBadBrace1FormattingUnicode",

    // template using {% ... %}
    begin: /(?=\{%(?:.*?(?!['"]|(?:(?<!\\)\n)))%\})/g,
    end: /(?=['"]|(?:(?<!\\)\n))/g,
    patterns: [
        escapeSequenceUnicode,
        escapeSequence,
        stringLineContinuation,
    ]
};

export const stringSingleBadBrace1FormattingRaw: TokenPattern = {
    debugName: "stringSingleBadBrace1FormattingRaw",

    // template using {% ... %}
    begin: /(?=\{%(?:.*?(?!['"]|(?:(?<!\\)\n)))%\})/g,
    end: /(?=['"]|(?:(?<!\\)\n))/g,
    patterns: [stringConsumeEscape]
};

export const stringSingleBadBrace2FormattingRaw: TokenPattern = {
    debugName: "stringSingleBadBrace2FormattingRaw",

    // odd format or format-like syntax
    begin: /(?!\{\{)(?=\{(?:\w*?(?!['"]|(?:(?<!\\)\n))[^!:\.\[}\w]).*?(?!['"]|(?:(?<!\\)\n))\})/g,
    end: /(?=['"]|(?:(?<!\\)\n))/g,
    patterns: [
        stringConsumeEscape,
        stringFormatting,
    ]
};

export const stringRawQuotedMultiLine: TokenPattern = {
    debugName: "stringRawQuotedMultiLine",

    token: LiteralTokenType.String, /*string.quoted.raw.multi.python*/
    begin: /\b(?:([uU]R)|(R))('''|""")/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Deprecated, /*invalid.deprecated.prefix.python*/ },
        2: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        3: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /(\4)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [stringRawGuts]
};

export const stringBinQuotedMultiLine: TokenPattern = {
    debugName: "stringBinQuotedMultiLine",

    token: LiteralTokenType.String, /*string.quoted.binary.multi.python*/
    begin: /(\b[bB])('''|""")/dg,
    beginCaptures: {
        1: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        2: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /(\2)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [stringEntity]
};

export const stringRawBinQuotedMultiLine: TokenPattern = {
    debugName: "stringRawBinQuotedMultiLine",

    token: LiteralTokenType.String, /*string.quoted.raw.binary.multi.python*/
    begin: /(\b(?:R[bB]|[bB]R))('''|""")/dg,
    beginCaptures: {
        1: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        2: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /(\2)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [stringRawBinGuts]
};

export const stringQuotedMultiLine: TokenPattern = {
    debugName: "stringQuotedMultiLine",

    token: LiteralTokenType.String, /*string.quoted.multi.python*/
    begin: /(?:\b([rR])(?=[uU]))?([uU])?('''|""")/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.prefix.python*/ },
        2: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        3: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /(\3)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [stringUnicodeGuts]
};

export const stringMultiBadBrace1FormattingUnicode: TokenPattern = {
    debugName: "stringMultiBadBrace1FormattingUnicode",

    // template using {% ... %}
    begin: /(?=\{%(.*?(?!'''|"""))%\})/g,
    end: /(?='''|""")/g,
    patterns: [
        escapeSequenceUnicode,
        escapeSequence,
        stringLineContinuation,
    ]
};

export const stringMultiBadBrace1FormattingRaw: TokenPattern = {
    debugName: "stringMultiBadBrace1FormattingRaw",

    // template using {% ... %}
    begin: /(?=\{%(.*?(?!'''|"""))%\})/g,
    end: /(?='''|""")/g,
    patterns: [stringConsumeEscape]
};

export const stringMultiBadBrace2FormattingUnicode: TokenPattern = {
    debugName: "stringMultiBadBrace2FormattingUnicode",

    // odd format or format-like syntax
    begin: /(?!\{\{)(?=\{(\w*?(?!'''|""")[^!:\.\[}\w]).*?(?!'''|""")\})/g,
    end: /(?='''|""")/g,
    patterns: [
        escapeSequenceUnicode,
        stringEntity,
    ]
};

export const stringMultiBadBrace2FormattingRaw: TokenPattern = {
    debugName: "stringMultiBadBrace2FormattingRaw",

    // odd format or format-like syntax
    begin: /(?!\{\{)(?=\{(\w*?(?!'''|""")[^!:\.\[}\w]).*?(?!'''|""")\})/g,
    end: /(?='''|""")/g,
    patterns: [
        stringConsumeEscape,
        stringFormatting,
    ]
};

export const fstringFnormQuotedSingleLine: TokenPattern = {
    debugName: "fstringFnormQuotedSingleLine",

    token: MetaTokenType.Fstring, /*meta.fstring.python*/
    begin: /(\b[fF])([bBuU])?((['"]))/dg,
    beginCaptures: {
        1: { token: MetaTokenType.StringStorageType, /*string.interpolated.python string.quoted.single.python storage.type.string.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.prefix.python*/ },
        3: { token: LiteralTokenType.String, /*punctuation.definition.string.begin.python string.interpolated.python string.quoted.single.python*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /(\3)|((?<!\\)\n)/dg,
    endCaptures: {
        1: { token: LiteralTokenType.String, /*punctuation.definition.string.end.python string.interpolated.python string.quoted.single.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        fstringGuts,
        fstringIllegalSingleBrace,
    ]
};

export const fstringNormfQuotedSingleLine: TokenPattern = {
    debugName: "fstringNormfQuotedSingleLine",

    token: MetaTokenType.Fstring, /*meta.fstring.python*/
    begin: /(\b[bBuU])([fF])((['"]))/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.prefix.python*/ },
        2: { token: MetaTokenType.StringStorageType, /*string.interpolated.python string.quoted.single.python storage.type.string.python*/ },
        3: { token: MetaTokenType.StringBegin, /*string.quoted.single.python punctuation.definition.string.begin.python*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /(\3)|((?<!\\)\n)/dg,
    endCaptures: {
        1: { token: LiteralTokenType.String, /*punctuation.definition.string.end.python string.interpolated.python string.quoted.single.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        fstringGuts,
        fstringIllegalSingleBrace,
    ]
};

export const fstringRawQuotedSingleLine: TokenPattern = {
    debugName: "fstringRawQuotedSingleLine",

    token: MetaTokenType.Fstring, /*meta.fstring.python*/
    begin: /(\b(?:[rR][fF]|[fF][rR]))((['"]))/dg,
    beginCaptures: {
        1: { token: MetaTokenType.StringStorageType, /*string.interpolated.python string.quoted.raw.single.python storage.type.string.python*/ },
        2: { token: MetaTokenType.StringBegin, /*string.quoted.raw.single.python punctuation.definition.string.begin.python*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /(\2)|((?<!\\)\n)/dg,
    endCaptures: {
        1: { token: LiteralTokenType.String, /*punctuation.definition.string.end.python string.interpolated.python string.quoted.raw.single.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        fstringRawGuts,
        fstringIllegalSingleBrace,
    ]
};

export const fstringSingleCore: TokenPattern = {
    debugName: "fstringSingleCore",

    token: LiteralTokenType.String, /*string.interpolated.python string.quoted.single.python*/
    match: /(.+?)(($\n?)|(?=[\\\}\{]|(['"])|((?<!\\)\n)))|\n/gm,
};

export const fstringRawSingleCore: TokenPattern = {
    debugName: "fstringRawSingleCore",

    token: LiteralTokenType.String, /*string.interpolated.python string.quoted.raw.single.python*/
    match: /(.+?)(($\n?)|(?=[\\\}\{]|(['"])|((?<!\\)\n)))|\n/gm,
};

export const fstringSingleBrace: TokenPattern = {
    debugName: "fstringSingleBrace",

    // value interpolation using { ... }
    begin: /(\{)/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
    },
    end: /(\})|(?=\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
    },
    patterns: [fExpression]
};

export const fstringTerminatorSingle: TokenPattern = {
    patterns: [
        {
            debugName: "fstringTerminatorSingle.patterns![0]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(=(![rsa])?)(?=})/g,
        },
        {
            debugName: "fstringTerminatorSingle.patterns![1]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(=?![rsa])(?=})/g,
        },
        {
            debugName: "fstringTerminatorSingle.patterns![2]",

            match: /((?:=?)(?:![rsa])?)(:\w?[<>=^]?[-+ ]?\#?\d*,?(\.\d+)?[bcdeEfFgGnosxX%]?)(?=})/dgm,
            captures: {
                1: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
                2: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
            },
        },
    ]
};

export const fstringTerminatorSingleTail: TokenPattern = {
    debugName: "fstringTerminatorSingleTail",

    begin: /((?:=?)(?:![rsa])?)(:)(?=.*?{)/dg,
    beginCaptures: {
        1: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
        2: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
    },
    end: /(?=})|(?=\n)/g,
    patterns: [
        fstringIllegalSingleBrace,
        fstringSingleBrace,
        {
            debugName: "fstringTerminatorSingleTail.patterns![2]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /([bcdeEfFgGnosxX%])(?=})/g,
        },
        {
            debugName: "fstringTerminatorSingleTail.patterns![3]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\.\d+)/g,
        },
        {
            debugName: "fstringTerminatorSingleTail.patterns![4]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(,)/g,
        },
        {
            debugName: "fstringTerminatorSingleTail.patterns![5]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\d+)/g,
        },
        {
            debugName: "fstringTerminatorSingleTail.patterns![6]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\#)/g,
        },
        {
            debugName: "fstringTerminatorSingleTail.patterns![7]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /([-+ ])/g,
        },
        {
            debugName: "fstringTerminatorSingleTail.patterns![8]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /([<>=^])/gm,
        },
        {
            debugName: "fstringTerminatorSingleTail.patterns![9]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\w)/g,
        },
    ]
};

export const fstringFnormQuotedMultiLine: TokenPattern = {
    debugName: "fstringFnormQuotedMultiLine",

    token: MetaTokenType.Fstring, /*meta.fstring.python*/
    begin: /(\b[fF])([bBuU])?('''|""")/dg,
    beginCaptures: {
        1: { token: MetaTokenType.StringStorageType, /*string.interpolated.python string.quoted.multi.python storage.type.string.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.prefix.python*/ },
        3: { token: LiteralTokenType.String, /*punctuation.definition.string.begin.python string.interpolated.python string.quoted.multi.python*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /(\3)/dg,
    endCaptures: {
        1: { token: LiteralTokenType.String, /*punctuation.definition.string.end.python string.interpolated.python string.quoted.multi.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        fstringGuts,
        fstringIllegalMultiBrace,
    ]
};

export const fstringNormfQuotedMultiLine: TokenPattern = {
    debugName: "fstringNormfQuotedMultiLine",

    token: MetaTokenType.Fstring, /*meta.fstring.python*/
    begin: /(\b[bBuU])([fF])('''|""")/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.prefix.python*/ },
        2: { token: MetaTokenType.StringStorageType, /*string.interpolated.python string.quoted.multi.python storage.type.string.python*/ },
        3: { token: MetaTokenType.StringBegin, /*string.quoted.multi.python punctuation.definition.string.begin.python*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /(\3)/dg,
    endCaptures: {
        1: { token: LiteralTokenType.String, /*punctuation.definition.string.end.python string.interpolated.python string.quoted.multi.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        fstringGuts,
        fstringIllegalMultiBrace,
    ]
};

export const fstringRawQuotedMultiLine: TokenPattern = {
    debugName: "fstringRawQuotedMultiLine",

    token: MetaTokenType.Fstring, /*meta.fstring.python*/
    begin: /(\b(?:[rR][fF]|[fF][rR]))('''|""")/dg,
    beginCaptures: {
        1: { token: MetaTokenType.StringStorageType, /*string.interpolated.python string.quoted.raw.multi.python storage.type.string.python*/ },
        2: { token: MetaTokenType.StringBegin, /*string.quoted.raw.multi.python punctuation.definition.string.begin.python*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /(\2)/dg,
    endCaptures: {
        1: { token: LiteralTokenType.String, /*punctuation.definition.string.end.python string.interpolated.python string.quoted.raw.multi.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        fstringRawGuts,
        fstringIllegalMultiBrace,
    ]
};

export const fstringMultiCore: TokenPattern = {
    debugName: "fstringMultiCore",

    token: LiteralTokenType.String, /*string.interpolated.python string.quoted.multi.python*/
    match: /(.+?)(($\n?)|(?=[\\\}\{]|'''|"""))|\n/gm,
};

export const fstringRawMultiCore: TokenPattern = {
    debugName: "fstringRawMultiCore",

    token: LiteralTokenType.String, /*string.interpolated.python string.quoted.raw.multi.python*/
    match: /(.+?)(($\n?)|(?=[\\\}\{]|'''|"""))|\n/gm,
};

export const fstringMultiBrace: TokenPattern = {
    debugName: "fstringMultiBrace",

    // value interpolation using { ... }
    begin: /(\{)/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
    },
    end: /(\})/dg,
    endCaptures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
    },
    patterns: [fExpression]
};

export const fstringTerminatorMulti: TokenPattern = {
    patterns: [
        {
            debugName: "fstringTerminatorMulti.patterns![0]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(=(![rsa])?)(?=})/g,
        },
        {
            debugName: "fstringTerminatorMulti.patterns![1]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(=?![rsa])(?=})/g,
        },
        {
            debugName: "fstringTerminatorMulti.patterns![2]",

            match: /((?:=?)(?:![rsa])?)(:\w?[<>=^]?[-+ ]?\#?\d*,?(\.\d+)?[bcdeEfFgGnosxX%]?)(?=})/dgm,
            captures: {
                1: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
                2: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
            },
        },
    ]
};

export const fstringTerminatorMultiTail: TokenPattern = {
    debugName: "fstringTerminatorMultiTail",

    begin: /((?:=?)(?:![rsa])?)(:)(?=.*?{)/dg,
    beginCaptures: {
        1: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
        2: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
    },
    end: /(?=})/g,
    patterns: [
        fstringIllegalMultiBrace,
        fstringMultiBrace,
        {
            debugName: "fstringTerminatorMultiTail.patterns![2]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /([bcdeEfFgGnosxX%])(?=})/g,
        },
        {
            debugName: "fstringTerminatorMultiTail.patterns![3]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\.\d+)/g,
        },
        {
            debugName: "fstringTerminatorMultiTail.patterns![4]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(,)/g,
        },
        {
            debugName: "fstringTerminatorMultiTail.patterns![5]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\d+)/g,
        },
        {
            debugName: "fstringTerminatorMultiTail.patterns![6]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\#)/g,
        },
        {
            debugName: "fstringTerminatorMultiTail.patterns![7]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /([-+ ])/g,
        },
        {
            debugName: "fstringTerminatorMultiTail.patterns![8]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /([<>=^])/gm,
        },
        {
            debugName: "fstringTerminatorMultiTail.patterns![9]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\w)/g,
        },
    ]
};

// Push pattern references that were not defined on include
python.patterns!.push(statement, expression);
statement.patterns!.push(importStatement, classDeclaration, functionDeclaration, generator, statementKeyword, assignmentOperator, decorator, docstringStatement, semicolon);
docstringStatement.patterns!.push(docstring);
docstring.patterns![0].patterns!.push(docstringPrompt, docstringGutsUnicode);
docstring.patterns![1].patterns!.push(stringConsumeEscape, docstringPrompt);
docstring.patterns![2].patterns!.push(docstringGutsUnicode);
docstring.patterns![3].patterns!.push(stringConsumeEscape);
docstringGutsUnicode.patterns!.push(escapeSequenceUnicode, escapeSequence, stringLineContinuation);
expressionBare.patterns!.splice(0, 0, backticks);
expressionBare.patterns!.splice(1, 0, illegalAnno);
expressionBare.patterns!.splice(2, 0, literal);
expressionBare.patterns!.splice(3, 0, regexp);
expressionBare.patterns!.splice(4, 0, string);
expressionBare.patterns!.splice(5, 0, lambda);
expressionBare.patterns!.splice(6, 0, generator);
expressionBare.patterns!.splice(7, 0, illegalOperator);
expressionBare.patterns!.splice(8, 0, operator);
expressionBare.patterns!.splice(9, 0, curlyBraces);
expressionBare.patterns!.splice(10, 0, itemAccess);
expressionBare.patterns!.splice(11, 0, list);
expressionBare.patterns!.splice(12, 0, oddFunctionCall);
expressionBare.patterns!.splice(13, 0, roundBraces);
expressionBare.patterns!.splice(14, 0, functionCall);
expressionBare.patterns!.splice(15, 0, builtinFunctions);
expressionBare.patterns!.splice(16, 0, builtinTypes);
expressionBare.patterns!.splice(17, 0, builtinExceptions);
expressionBare.patterns!.splice(18, 0, magicNames);
expressionBare.patterns!.splice(19, 0, specialNames);
expressionBare.patterns!.splice(20, 0, illegalNames);
expressionBare.patterns!.splice(21, 0, specialVariables);
expressionBare.patterns!.splice(22, 0, ellipsis);
expressionBare.patterns!.splice(23, 0, punctuation);
expressionBare.patterns!.splice(24, 0, lineContinuation);
expressionBase.patterns!.push(lineContinuation);
expression.patterns!.splice(1, 0, memberAccess);
memberAccess.patterns!.push(functionCall, memberAccessBase, memberAccessAttribute);
memberAccessBase.patterns!.push(magicNames, illegalNames, illegalObjectName, specialNames, lineContinuation, itemAccess);
oddFunctionCall.patterns!.push(functionArguments);
lineContinuation.patterns![1].patterns!.push(regexp, string);
literal.patterns!.push(number);
number.patterns!.splice(0, 0, numberFloat);
number.patterns!.splice(1, 0, numberDec);
number.patterns!.splice(2, 0, numberHex);
number.patterns!.splice(3, 0, numberOct);
number.patterns!.splice(4, 0, numberBin);
number.patterns!.splice(5, 0, numberLong);
regexp.patterns!.push(regexpSingleThreeLine, regexpDoubleThreeLine, regexpSingleOneLine, regexpDoubleOneLine);
string.patterns!.push(stringQuotedMultiLine, stringQuotedSingleLine, stringBinQuotedMultiLine, stringBinQuotedSingleLine, stringRawQuotedMultiLine, stringRawQuotedSingleLine, stringRawBinQuotedMultiLine, stringRawBinQuotedSingleLine, fstringFnormQuotedMultiLine, fstringFnormQuotedSingleLine, fstringNormfQuotedMultiLine, fstringNormfQuotedSingleLine, fstringRawQuotedMultiLine, fstringRawQuotedSingleLine);
stringUnicodeGuts.patterns!.push(escapeSequenceUnicode, stringEntity, stringBraceFormatting);
stringRawGuts.patterns!.push(stringFormatting, stringBraceFormatting);
stringRawBinGuts.patterns!.push(stringFormatting);
stringEntity.patterns!.push(escapeSequence, stringLineContinuation, stringFormatting);
fstringGuts.patterns!.push(escapeSequenceUnicode, escapeSequence, stringLineContinuation, fstringFormatting);
fstringRawGuts.patterns!.push(fstringFormatting);
fstringIllegalSingleBrace.patterns!.push(fstringTerminatorSingle, fExpression);
fstringFormatting.patterns!.push(fstringFormattingBraces, fstringFormattingSingeBrace);
classDeclaration.patterns![0].patterns!.push(className, classInheritance);
className.patterns!.splice(0, 0, illegalObjectName);
className.patterns!.splice(1, 0, builtinPossibleCallables);
classInheritance.patterns!.splice(4, 0, illegalNames);
classInheritance.patterns!.splice(5, 0, classKwarg);
classInheritance.patterns!.splice(6, 0, callWrapperInheritance);
classInheritance.patterns!.push(memberAccessClass, inheritanceIdentifier);
memberAccessClass.patterns!.splice(0, 0, callWrapperInheritance);
lambda.patterns![1].patterns!.splice(2, 0, lambdaNestedIncomplete);
lambda.patterns![1].patterns!.splice(3, 0, illegalNames);
lambda.patterns![1].patterns!.splice(6, 0, backticks);
lambda.patterns![1].patterns!.splice(7, 0, illegalAnno);
lambda.patterns![1].patterns!.splice(8, 0, lambdaParameterWithDefault);
lambda.patterns![1].patterns!.push(illegalOperator);
functionDeclaration.patterns!.splice(0, 0, functionDefName);
functionDeclaration.patterns!.splice(1, 0, parameters);
functionDeclaration.patterns!.push(returnAnnotation);
functionDefName.patterns!.splice(0, 0, illegalObjectName);
functionDefName.patterns!.splice(1, 0, builtinPossibleCallables);
parameters.patterns!.splice(3, 0, illegalNames);
parameters.patterns!.splice(4, 0, illegalObjectName);
parameters.patterns!.splice(5, 0, parameterSpecial);
parameters.patterns!.push(looseDefault, annotatedParameter);
itemAccess.patterns![0].patterns!.splice(0, 0, itemName);
itemAccess.patterns![0].patterns!.splice(1, 0, itemIndex);
itemName.patterns!.splice(0, 0, specialVariables);
itemName.patterns!.splice(1, 0, builtinFunctions);
decorator.patterns!.push(decoratorName, functionArguments);
decoratorName.patterns!.splice(0, 0, builtinCallables);
decoratorName.patterns!.splice(1, 0, illegalObjectName);
callWrapperInheritance.patterns!.push(inheritanceName, functionArguments);
inheritanceName.patterns!.splice(1, 0, builtinPossibleCallables);
functionCall.patterns!.push(specialVariables, functionName, functionArguments);
functionName.patterns!.splice(0, 0, builtinPossibleCallables);
functionArguments.patterns!.splice(3, 0, illegalNames);
builtinCallables.patterns!.push(illegalNames, illegalObjectName, builtinExceptions, builtinFunctions, builtinTypes);
builtinPossibleCallables.patterns!.push(magicNames);
regexpBaseExpression.patterns!.push(regexpQuantifier, regexpBaseCommon);
fregexpBaseExpression.patterns!.splice(0, 0, fregexpQuantifier);
fregexpBaseExpression.patterns!.splice(1, 0, fstringFormattingBraces);
fregexpBaseExpression.patterns!.push(regexpBaseCommon);
regexpBaseCommon.patterns!.push(regexpEscapeSequence);
singleOneRegexpExpression.patterns!.splice(1, 0, singleOneRegexpCharacterSet);
singleOneRegexpExpression.patterns!.splice(2, 0, singleOneRegexpComments);
singleOneRegexpExpression.patterns!.splice(4, 0, singleOneRegexpNamedGroup);
singleOneRegexpExpression.patterns!.push(singleOneRegexpLookahead, singleOneRegexpLookaheadNegative, singleOneRegexpLookbehind, singleOneRegexpLookbehindNegative, singleOneRegexpConditional, singleOneRegexpParenthesesNonCapturing, singleOneRegexpParentheses);
singleThreeRegexpExpression.patterns!.splice(1, 0, singleThreeRegexpCharacterSet);
singleThreeRegexpExpression.patterns!.splice(2, 0, singleThreeRegexpComments);
singleThreeRegexpExpression.patterns!.splice(4, 0, singleThreeRegexpNamedGroup);
singleThreeRegexpExpression.patterns!.splice(6, 0, singleThreeRegexpLookahead);
singleThreeRegexpExpression.patterns!.splice(7, 0, singleThreeRegexpLookaheadNegative);
singleThreeRegexpExpression.patterns!.splice(8, 0, singleThreeRegexpLookbehind);
singleThreeRegexpExpression.patterns!.splice(9, 0, singleThreeRegexpLookbehindNegative);
singleThreeRegexpExpression.patterns!.splice(10, 0, singleThreeRegexpConditional);
singleThreeRegexpExpression.patterns!.splice(11, 0, singleThreeRegexpParenthesesNonCapturing);
singleThreeRegexpExpression.patterns!.splice(12, 0, singleThreeRegexpParentheses);
doubleOneRegexpExpression.patterns!.splice(1, 0, doubleOneRegexpCharacterSet);
doubleOneRegexpExpression.patterns!.splice(2, 0, doubleOneRegexpComments);
doubleOneRegexpExpression.patterns!.splice(4, 0, doubleOneRegexpNamedGroup);
doubleOneRegexpExpression.patterns!.push(doubleOneRegexpLookahead, doubleOneRegexpLookaheadNegative, doubleOneRegexpLookbehind, doubleOneRegexpLookbehindNegative, doubleOneRegexpConditional, doubleOneRegexpParenthesesNonCapturing, doubleOneRegexpParentheses);
doubleThreeRegexpExpression.patterns!.splice(1, 0, doubleThreeRegexpCharacterSet);
doubleThreeRegexpExpression.patterns!.splice(2, 0, doubleThreeRegexpComments);
doubleThreeRegexpExpression.patterns!.splice(4, 0, doubleThreeRegexpNamedGroup);
doubleThreeRegexpExpression.patterns!.splice(6, 0, doubleThreeRegexpLookahead);
doubleThreeRegexpExpression.patterns!.splice(7, 0, doubleThreeRegexpLookaheadNegative);
doubleThreeRegexpExpression.patterns!.splice(8, 0, doubleThreeRegexpLookbehind);
doubleThreeRegexpExpression.patterns!.splice(9, 0, doubleThreeRegexpLookbehindNegative);
doubleThreeRegexpExpression.patterns!.splice(10, 0, doubleThreeRegexpConditional);
doubleThreeRegexpExpression.patterns!.splice(11, 0, doubleThreeRegexpParenthesesNonCapturing);
doubleThreeRegexpExpression.patterns!.splice(12, 0, doubleThreeRegexpParentheses);
stringRawQuotedSingleLine.patterns!.splice(0, 0, stringSingleBadBrace1FormattingRaw);
stringRawQuotedSingleLine.patterns!.splice(1, 0, stringSingleBadBrace2FormattingRaw);
stringQuotedSingleLine.patterns!.splice(0, 0, stringSingleBadBrace1FormattingUnicode);
stringRawQuotedMultiLine.patterns!.splice(0, 0, stringMultiBadBrace1FormattingRaw);
stringRawQuotedMultiLine.patterns!.splice(1, 0, stringMultiBadBrace2FormattingRaw);
stringQuotedMultiLine.patterns!.splice(0, 0, stringMultiBadBrace1FormattingUnicode);
stringQuotedMultiLine.patterns!.splice(1, 0, stringMultiBadBrace2FormattingUnicode);
fstringFnormQuotedSingleLine.patterns!.push(fstringSingleBrace, fstringSingleCore);
fstringNormfQuotedSingleLine.patterns!.push(fstringSingleBrace, fstringSingleCore);
fstringRawQuotedSingleLine.patterns!.push(fstringSingleBrace, fstringRawSingleCore);
fstringSingleBrace.patterns!.splice(0, 0, fstringTerminatorSingle);
fstringTerminatorSingle.patterns!.push(fstringTerminatorSingleTail);
fstringFnormQuotedMultiLine.patterns!.push(fstringMultiBrace, fstringMultiCore);
fstringNormfQuotedMultiLine.patterns!.push(fstringMultiBrace, fstringMultiCore);
fstringRawQuotedMultiLine.patterns!.push(fstringMultiBrace, fstringRawMultiCore);
fstringMultiBrace.patterns!.splice(0, 0, fstringTerminatorMulti);
fstringTerminatorMulti.patterns!.push(fstringTerminatorMultiTail);