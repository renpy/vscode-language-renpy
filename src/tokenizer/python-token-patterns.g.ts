/* eslint-disable no-useless-escape */
/* eslint-disable no-useless-backreference */
/* eslint-disable @typescript-eslint/no-non-null-assertion */

// THIS FILE HAS BEEN GENERATED BY THE `syntax-to-token-pattern.py` GENERATOR
// DO NOT EDIT THIS FILE DIRECTLY! INSTEAD RUN THE PYTHON SCRIPT.
// ANY MANUAL EDITS MADE TO THIS FILE WILL BE OVERWRITTEN. YOU HAVE BEEN WARNED.
// Last generated: 25/05/2023 16:56:42 (UTC+0)

import { MetaTokenType, KeywordTokenType, CharacterTokenType, OperatorTokenType, LiteralTokenType, EntityTokenType } from "./renpy-tokens";
import { stringsInterior } from "./token-patterns";
import { TokenPattern } from "./token-pattern-types";

export const pythonImpossible: TokenPattern = {
    debugName: "pythonImpossible",

    // This is a special rule that should be used where no match is desired. It is not a good idea to match something like '1{0}' because in some cases that can result in infinite loops in token generation. So the rule instead matches and impossible expression to allow a match to fail and move to the next token.
    match: /$.^/gm,
};

export const pythonStatement: TokenPattern = {
    patterns: [
    ]
};

export const pythonSemicolon: TokenPattern = {
    patterns: [
        {
            debugName: "pythonSemicolon.patterns![0]",

            token: MetaTokenType.Deprecated, /*invalid.deprecated.semicolon.python*/
            match: /\;$/gm,
        },
    ]
};

export const pythonComments: TokenPattern = {
    patterns: [
        {
            debugName: "pythonComments.patterns![0]",

            token: MetaTokenType.Comment, /*comment.line.number-sign.renpy*/
            match: /^[ \t]*(#[ \t]*(?:end)?region)\b.*$/dgm,
            captures: {
                1: { token: MetaTokenType.CommentRegionTag, /*punctuation.definition.tag.region*/ },
            },
        },
        {
            debugName: "pythonComments.patterns![1]",

            token: MetaTokenType.Comment, /*comment.line.number-sign.python*/
            contentToken: MetaTokenType.TypehintComment, /*meta.typehint.comment.python*/
            begin: /(?:\#\s*(type:)\s*+(?!$|\#))/dgm,
            beginCaptures: {
                0: { token: MetaTokenType.TypehintComment, /*meta.typehint.comment.python*/ },
                1: { token: MetaTokenType.TypehintDirective, /*comment.typehint.directive.notation.python*/ },
            },
            end: /(?:$|(?=\#))/gm,
            patterns: [
                {
                    debugName: "pythonComments.patterns![1].patterns![0]",

                    token: MetaTokenType.TypehintIgnore, /*comment.typehint.ignore.notation.python*/
                    match: /\Gignore(?=\s*(?:$|\#))/gm,
                },
                {
                    debugName: "pythonComments.patterns![1].patterns![1]",

                    token: MetaTokenType.TypehintType, /*comment.typehint.type.notation.python*/
                    match: /(?<!\.)\b(bool|bytes|float|int|object|str|List|Dict|Iterable|Sequence|Set|FrozenSet|Callable|Union|Tuple|Any|None)\b/g,
                },
                {
                    debugName: "pythonComments.patterns![1].patterns![2]",

                    token: MetaTokenType.TypehintPunctuation, /*comment.typehint.punctuation.notation.python*/
                    match: /([\[\]\(\),\.\=\*]|(->))/g,
                },
                {
                    debugName: "pythonComments.patterns![1].patterns![3]",

                    token: MetaTokenType.TypehintVariable, /*comment.typehint.variable.notation.python*/
                    match: /([[:alpha:]_]\w*)/g,
                },
            ]
        },
    ]
};

export const pythonDocstringStatement: TokenPattern = {
    debugName: "pythonDocstringStatement",

    // the string either terminates correctly or by the beginning of a new line (this is for single line docstrings that aren't terminated) AND it's not followed by another docstring
    begin: /^(?=\s*[rR]?(\'\'\'|\"\"\"|\'|\"))/gm,
    end: /((?<=\1)|^)(?!\s*[rR]?(\'\'\'|\"\"\"|\'|\"))/gm,
    patterns: [
    ]
};

export const pythonDocstring: TokenPattern = {
    patterns: [
        {
            debugName: "pythonDocstring.patterns![0]",

            token: MetaTokenType.Docstring, /*string.quoted.docstring.multi.python*/
            begin: /(\'\'\'|\"\"\")/dg,
            beginCaptures: {
                1: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
            },
            end: /(\1)/dg,
            endCaptures: {
                1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
            },
            patterns: [
            ]
        },
        {
            debugName: "pythonDocstring.patterns![1]",

            token: MetaTokenType.Docstring, /*string.quoted.docstring.raw.multi.python*/
            begin: /([rR])(\'\'\'|\"\"\")/dg,
            beginCaptures: {
                1: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
                2: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
            },
            end: /(\2)/dg,
            endCaptures: {
                1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
            },
            patterns: [
            ]
        },
        {
            debugName: "pythonDocstring.patterns![2]",

            token: MetaTokenType.Docstring, /*string.quoted.docstring.single.python*/
            begin: /(\'|\")/dg,
            beginCaptures: {
                1: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
            },
            end: /(\1)|(\n)/dg,
            endCaptures: {
                1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
            },
            patterns: [
            ]
        },
        {
            debugName: "pythonDocstring.patterns![3]",

            token: MetaTokenType.Docstring, /*string.quoted.docstring.raw.single.python*/
            begin: /([rR])(\'|\")/dg,
            beginCaptures: {
                1: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
                2: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
            },
            end: /(\2)|(\n)/dg,
            endCaptures: {
                1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
            },
            patterns: []
        }]
};

export const pythonDocstringGutsUnicode: TokenPattern = {
    patterns: [
    ]
};

export const pythonDocstringPrompt: TokenPattern = {
    debugName: "pythonDocstringPrompt",

    match: /(?:(?:^|\G)\s*((?:>>>|\.\.\.)\s)(?=\s*\S))/dgm,
    captures: {
        1: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/ },
    },
};

export const pythonStatementKeyword: TokenPattern = {
    patterns: [
        {
            debugName: "pythonStatementKeyword.patterns![0]",

            token: KeywordTokenType.Def, /*storage.type.function.python*/
            match: /\b((async\s+)?\s*def)\b/g,
        },
        {
            debugName: "pythonStatementKeyword.patterns![1]",

            // if `as` is eventually followed by `:` or line continuation, it's probably control flow like:    with foo as bar, \
            //          Foo as Bar:      try:        do_stuff()      except Exception as e:        pass
            token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/
            match: /\b(?<!\.)as\b(?=.*[:\\])/g,
        },
        {
            debugName: "pythonStatementKeyword.patterns![2]",

            // other legal use of `as` is in an import
            token: KeywordTokenType.Import, /*keyword.control.import.python*/
            match: /\b(?<!\.)as\b/g,
        },
        {
            debugName: "pythonStatementKeyword.patterns![3]",

            token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/
            match: /\b(?<!\.)(async|continue|del|assert|break|finally|for|from|elif|else|if|except|pass|raise|return|try|while|with)\b/g,
        },
        {
            debugName: "pythonStatementKeyword.patterns![4]",

            match: /\b(?<!\.)(?:(global)|(nonlocal))\b/dg,
            captures: {
                1: { token: KeywordTokenType.Global, /*storage.modifier.declaration.global.python*/ },
                2: { token: KeywordTokenType.Nonlocal, /*storage.modifier.declaration.nonlocal.python*/ },
            },
        },
        {
            debugName: "pythonStatementKeyword.patterns![5]",

            token: KeywordTokenType.Class, /*storage.type.class.python*/
            match: /\b(?<!\.)(class)\b/g,
        },
        {
            debugName: "pythonStatementKeyword.patterns![6]",

            match: /^\s*(case|match)(?=\s*([-+\w\d(\[{'":#]|$))\b/dgm,
            captures: {
                1: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/ },
            },
        },
    ]
};

export const pythonExpressionBare: TokenPattern = {
    // valid Python expressions w/o comments and line continuation
    patterns: [
    ]
};

export const pythonExpressionBase: TokenPattern = {
    // valid Python expressions with comments and line continuation
    patterns: [
        pythonComments,
        pythonExpressionBare,
    ]
};

export const pythonExpression: TokenPattern = {
    // All valid Python expressions
    patterns: [
        pythonExpressionBase,
        {
            debugName: "pythonExpression.patterns![2]",

            // Tokenize identifiers to help linters
            match: /\b([[:alpha:]_]\w*)\b/g,
        },
    ]
};

export const pythonMemberAccess: TokenPattern = {
    debugName: "pythonMemberAccess",

    token: MetaTokenType.MemberAccess, /*meta.member.access.python*/
    begin: /(\.)\s*(?!\.)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.Period, /*punctuation.separator.period.python*/ },
    },
    end: /(?<=\S)(?=\W)|(^|(?<=\s))(?=[^\\\w\s])|$/gm,
    patterns: [
    ]
};

export const pythonMemberAccessBase: TokenPattern = {
    patterns: [
    ]
};

export const pythonMemberAccessAttribute: TokenPattern = {
    debugName: "pythonMemberAccessAttribute",

    // Highlight attribute access in otherwise non-specialized cases.
    token: MetaTokenType.Attribute, /*meta.attribute.python*/
    match: /\b([[:alpha:]_]\w*)\b/g,
};

export const pythonSpecialNames: TokenPattern = {
    debugName: "pythonSpecialNames",

    token: MetaTokenType.ConstantCaps, /*constant.other.caps.python*/
    match: /\b(_*[[:upper:]][_\d]*[[:upper:]])[[:upper:]\d]*(_\w*)?\b/g,
};

export const pythonCurlyBraces: TokenPattern = {
    debugName: "pythonCurlyBraces",

    begin: /\{/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.dict.begin.python*/ },
    },
    end: /\}/dg,
    endCaptures: {
        0: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.dict.end.python*/ },
    },
    patterns: [
        {
            debugName: "pythonCurlyBraces.patterns![0]",

            token: CharacterTokenType.Colon, /*punctuation.separator.dict.python*/
            match: /:/g,
        },
        pythonExpression,
    ]
};

export const pythonList: TokenPattern = {
    debugName: "pythonList",

    begin: /\[/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenSquareBracket, /*punctuation.definition.list.begin.python*/ },
    },
    end: /\]/dg,
    endCaptures: {
        0: { token: CharacterTokenType.CloseSquareBracket, /*punctuation.definition.list.end.python*/ },
    },
    patterns: [pythonExpression]
};

export const pythonOddFunctionCall: TokenPattern = {
    debugName: "pythonOddFunctionCall",

    // A bit obscured function call where there may have been anarbitrary number of other operations to get the function.E.g. "arr[idx](args)"
    begin: /(?<=\]|\))\s*(?=\()/g,
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.python*/ },
    },
    patterns: [
    ]
};

export const pythonRoundBraces: TokenPattern = {
    debugName: "pythonRoundBraces",

    begin: /\(/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.python*/ },
    },
    end: /\)/dg,
    endCaptures: {
        0: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.python*/ },
    },
    patterns: [pythonExpression]
};

export const pythonLineContinuation: TokenPattern = {
    patterns: [
        {
            debugName: "pythonLineContinuation.patterns![0]",

            match: /(\\)\s*(\S.*$\n?)/dgm,
            captures: {
                1: { token: CharacterTokenType.Backslash, /*punctuation.separator.continuation.line.python*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.line.continuation.python*/ },
            },
        },
        {
            debugName: "pythonLineContinuation.patterns![1]",

            begin: /(\\)\s*$\n?/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.Backslash, /*punctuation.separator.continuation.line.python*/ },
            },
            end: /(?=^\s*$)|(?!(\s*[rR]?(\'\'\'|\"\"\"|\'|\"))|(\G$))/gm,
            patterns: []
        }]
};

export const pythonAssignmentOperator: TokenPattern = {
    debugName: "pythonAssignmentOperator",

    token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/
    match: /<<=|>>=|\/\/=|\*\*=|\+=|-=|\/=|@=|\*=|%=|~=|\^=|&=|\|=|=(?!=)/gm,
};

export const pythonOperator: TokenPattern = {
    debugName: "pythonOperator",

    match: /\b(?<!\.)(?:(and|or|not|in|is)|(for|if|else|await|(?:yield(?:\s+from)?)))(?!\s*:)\b|(<<|>>|&|\||\^|~)|(\*\*|\*|\+|-|%|\/\/|\/|@)|(!=|==|>=|<=|<|>)|(:=)/dgm,
    captures: {
        1: { token: MetaTokenType.LogicalOperatorKeyword, /*keyword.operator.logical.python*/ },
        2: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/ },
        3: { token: MetaTokenType.BitwiseOperatorKeyword, /*keyword.operator.bitwise.python*/ },
        4: { token: MetaTokenType.ArithmeticOperator, /*keyword.operator.arithmetic.python*/ },
        5: { token: MetaTokenType.ComparisonOperatorKeyword, /*keyword.operator.comparison.python*/ },
        6: { token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/ },
    },
};

export const pythonPunctuation: TokenPattern = {
    patterns: [
        {
            debugName: "pythonPunctuation.patterns![0]",

            token: CharacterTokenType.Colon, /*punctuation.separator.colon.python*/
            match: /:/g,
        },
        {
            debugName: "pythonPunctuation.patterns![1]",

            token: CharacterTokenType.Comma, /*punctuation.separator.element.python*/
            match: /,/g,
        },
    ]
};

export const pythonLiteral: TokenPattern = {
    patterns: [
        {
            debugName: "pythonLiteral.patterns![0]",

            token: MetaTokenType.ConstantLiteral, /*constant.language.python*/
            match: /\b(True|False|None|NotImplemented|Ellipsis)\b/g,
        },
    ]
};

export const pythonNumber: TokenPattern = {
    patterns: [
        {
            debugName: "pythonNumber.patterns![6]",

            token: MetaTokenType.Invalid, /*invalid.illegal.name.python*/
            match: /\b[0-9]+\w+/g,
        },
    ]
};

export const pythonNumberFloat: TokenPattern = {
    debugName: "pythonNumberFloat",

    token: LiteralTokenType.Float, /*constant.numeric.float.python*/
    match: /(?<!\w)(?:(?:\.[0-9](?:_?[0-9])*|[0-9](?:_?[0-9])*\.[0-9](?:_?[0-9])*|[0-9](?:_?[0-9])*\.)(?:[eE][+-]?[0-9](?:_?[0-9])*)?|[0-9](?:_?[0-9])*(?:[eE][+-]?[0-9](?:_?[0-9])*))([jJ])?\b/dg,
    captures: {
        1: { token: MetaTokenType.ImaginaryNumberStorageType, /*storage.type.imaginary.number.python*/ },
    },
};

export const pythonNumberDec: TokenPattern = {
    debugName: "pythonNumberDec",

    token: MetaTokenType.ConstantNumeric, /*constant.numeric.dec.python*/
    match: /(?<![\w.])(?:[1-9](?:_?[0-9])*|0+|[0-9](?:_?[0-9])*([jJ])|0([0-9]+)(?![eE.]))\b/dg,
    captures: {
        1: { token: MetaTokenType.ImaginaryNumberStorageType, /*storage.type.imaginary.number.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.dec.python*/ },
    },
};

export const pythonNumberHex: TokenPattern = {
    debugName: "pythonNumberHex",

    token: MetaTokenType.ConstantNumeric, /*constant.numeric.hex.python*/
    match: /(?<![\w.])(0[xX])(_?[0-9a-fA-F])+\b/dg,
    captures: {
        1: { token: MetaTokenType.NumberStorageType, /*storage.type.number.python*/ },
    },
};

export const pythonNumberOct: TokenPattern = {
    debugName: "pythonNumberOct",

    token: MetaTokenType.ConstantNumeric, /*constant.numeric.oct.python*/
    match: /(?<![\w.])(0[oO])(_?[0-7])+\b/dg,
    captures: {
        1: { token: MetaTokenType.NumberStorageType, /*storage.type.number.python*/ },
    },
};

export const pythonNumberBin: TokenPattern = {
    debugName: "pythonNumberBin",

    token: MetaTokenType.ConstantNumeric, /*constant.numeric.bin.python*/
    match: /(?<![\w.])(0[bB])(_?[01])+\b/dg,
    captures: {
        1: { token: MetaTokenType.NumberStorageType, /*storage.type.number.python*/ },
    },
};

export const pythonNumberLong: TokenPattern = {
    debugName: "pythonNumberLong",

    // this is to support python2 syntax for long ints
    token: MetaTokenType.ConstantNumeric, /*constant.numeric.bin.python*/
    match: /(?<![\w.])([1-9][0-9]*|0)([lL])\b/dg,
    captures: {
        2: { token: MetaTokenType.NumberStorageType, /*storage.type.number.python*/ },
    },
};

export const pythonRegexp: TokenPattern = {
    patterns: []
};

export const pythonString: TokenPattern = {
    patterns: [
    ]
};

export const pythonStringUnicodeGuts: TokenPattern = {
    patterns: [
        stringsInterior]
};

export const pythonStringConsumeEscape: TokenPattern = {
    debugName: "pythonStringConsumeEscape",

    match: /\\['"\n\\]/g,
};

export const pythonStringRawGuts: TokenPattern = {
    patterns: [pythonStringConsumeEscape]
};

export const pythonStringRawBinGuts: TokenPattern = {
    patterns: [pythonStringConsumeEscape]
};

export const pythonStringEntity: TokenPattern = {
    patterns: []
};

export const pythonFstringGuts: TokenPattern = {
    patterns: [
    ]
};

export const pythonFstringRawGuts: TokenPattern = {
    patterns: [
        pythonStringConsumeEscape]
};

export const pythonFstringIllegalSingleBrace: TokenPattern = {
    debugName: "pythonFstringIllegalSingleBrace",

    // it is illegal to have a multiline brace inside a single-line string
    begin: /(\{)(?=[^\n}]*$\n?)/dgm,
    beginCaptures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
    },
    end: /(\})|(?=\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
    },
    patterns: []
};

export const pythonFstringIllegalMultiBrace: TokenPattern = {
    patterns: [
        pythonImpossible]
};

export const pythonFExpression: TokenPattern = {
    // All valid Python expressions, except comments and line continuation
    patterns: [
        pythonExpressionBare,
        pythonMemberAccess,
        {
            debugName: "pythonFExpression.patterns![2]",

            // Tokenize identifiers to help linters
            match: /\b([[:alpha:]_]\w*)\b/g,
        },
    ]
};

export const pythonEscapeSequenceUnicode: TokenPattern = {
    patterns: [
        {
            debugName: "pythonEscapeSequenceUnicode.patterns![0]",

            token: MetaTokenType.EscapeSequence, /*constant.character.escape.python*/
            match: /\\(u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8}|N\{[\w\s]+?\})/g,
        },
    ]
};

export const pythonEscapeSequence: TokenPattern = {
    debugName: "pythonEscapeSequence",

    token: MetaTokenType.EscapeSequence, /*constant.character.escape.python*/
    match: /\\(x[0-9A-Fa-f]{2}|[0-7]{1,3}|[\\"'abfnrtv])/g,
};

export const pythonStringLineContinuation: TokenPattern = {
    debugName: "pythonStringLineContinuation",

    token: MetaTokenType.ConstantLiteral, /*constant.language.python*/
    match: /\\$/gm,
};

export const pythonStringFormatting: TokenPattern = {
    debugName: "pythonStringFormatting",

    token: MetaTokenType.FormatPercent, /*meta.format.percent.python*/
    match: /(%(\([\w\s]*\))?[-+#0 ]*(\d+|\*)?(\.(\d+|\*))?([hlL])?[diouxXeEfFgGcrsab%])/dg,
    captures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
    },
};

export const pythonStringBraceFormatting: TokenPattern = {
    patterns: [
        {
            debugName: "pythonStringBraceFormatting.patterns![0]",

            token: MetaTokenType.FormatBrace, /*meta.format.brace.python*/
            match: /({{|}}|(?:{\w*(\.[[:alpha:]_]\w*|\[[^\]'"]+\])*(![rsa])?(:\w?[<>=^]?[-+ ]?\#?\d*,?(\.\d+)?[bcdeEfFgGnosxX%]?)?}))/dgm,
            captures: {
                1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
                3: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
                4: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
            },
        },
        {
            debugName: "pythonStringBraceFormatting.patterns![1]",

            token: MetaTokenType.FormatBrace, /*meta.format.brace.python*/
            match: /({\w*(\.[[:alpha:]_]\w*|\[[^\]'"]+\])*(![rsa])?(:)[^'"{}\n]*(?:\{[^'"}\n]*?\}[^'"{}\n]*)*})/dg,
            captures: {
                1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
                3: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
                4: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
            },
        },
    ]
};

export const pythonFstringFormatting: TokenPattern = {
    patterns: [
    ]
};

export const pythonFstringFormattingSingeBrace: TokenPattern = {
    debugName: "pythonFstringFormattingSingeBrace",

    token: MetaTokenType.Invalid, /*invalid.illegal.brace.python*/
    match: /(}(?!}))/g,
};

export const pythonImport: TokenPattern = {
    // Import statements used to correctly mark `from`, `import`, and `as`
    patterns: [
        {
            debugName: "pythonImport.patterns![0]",

            begin: /\b(?<!\.)(from)\b(?=.+import)/dg,
            beginCaptures: {
                1: { token: KeywordTokenType.Import, /*keyword.control.import.python*/ },
            },
            end: /$|(?=import)/gm,
            patterns: [
                {
                    debugName: "pythonImport.patterns![0].patterns![0]",

                    token: CharacterTokenType.Period, /*punctuation.separator.period.python*/
                    match: /\.+/g,
                },
                pythonExpression,
            ]
        },
        {
            debugName: "pythonImport.patterns![1]",

            begin: /\b(?<!\.)(import)\b/dg,
            beginCaptures: {
                1: { token: KeywordTokenType.Import, /*keyword.control.import.python*/ },
            },
            end: /$/gm,
            patterns: [
                {
                    debugName: "pythonImport.patterns![1].patterns![0]",

                    token: KeywordTokenType.Import, /*keyword.control.import.python*/
                    match: /\b(?<!\.)as\b/g,
                },
                pythonExpression,
            ]
        },
    ]
};

export const pythonClassDeclaration: TokenPattern = {
    patterns: [
        {
            debugName: "pythonClassDeclaration.patterns![0]",

            token: MetaTokenType.ClassDefinition, /*meta.class.python*/
            begin: /\s*(class)\s+(?=[[:alpha:]_]\w*\s*(:|\())/dg,
            beginCaptures: {
                1: { token: KeywordTokenType.Class, /*storage.type.class.python*/ },
            },
            end: /(:)/dg,
            endCaptures: {
                1: { token: CharacterTokenType.Colon, /*punctuation.section.class.begin.python*/ },
            },
            patterns: []
        }]
};

export const pythonClassName: TokenPattern = {
    patterns: [
        {
            debugName: "pythonClassName.patterns![2]",

            token: EntityTokenType.ClassName, /*entity.name.type.class.python*/
            match: /\b([[:alpha:]_]\w*)\b/g,
        },
    ]
};

export const pythonClassInheritance: TokenPattern = {
    debugName: "pythonClassInheritance",

    token: MetaTokenType.ClassInheritance, /*meta.class.inheritance.python*/
    begin: /(\()/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.inheritance.begin.python*/ },
    },
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.inheritance.end.python*/ },
    },
    patterns: [
        {
            debugName: "pythonClassInheritance.patterns![0]",

            token: OperatorTokenType.Unpacking, /*keyword.operator.unpacking.arguments.python*/
            match: /(\*\*|\*)/g,
        },
        {
            debugName: "pythonClassInheritance.patterns![1]",

            token: CharacterTokenType.Comma, /*punctuation.separator.inheritance.python*/
            match: /,/g,
        },
        {
            debugName: "pythonClassInheritance.patterns![2]",

            token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/
            match: /=(?!=)/g,
        },
        {
            debugName: "pythonClassInheritance.patterns![3]",

            token: KeywordTokenType.Metaclass, /*support.type.metaclass.python*/
            match: /\bmetaclass\b/g,
        },
        pythonExpressionBase,
    ]
};

export const pythonClassKwarg: TokenPattern = {
    debugName: "pythonClassKwarg",

    match: /\b([[:alpha:]_]\w*)\s*(=)(?!=)/dg,
    captures: {
        1: { token: EntityTokenType.InheritedClassName, /*entity.other.inherited-class.python variable.parameter.class.python*/ },
        2: { token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/ },
    },
};

export const pythonInheritanceIdentifier: TokenPattern = {
    debugName: "pythonInheritanceIdentifier",

    match: /\b([[:alpha:]_]\w*)\b/dg,
    captures: {
        1: { token: EntityTokenType.InheritedClassName, /*entity.other.inherited-class.python*/ },
    },
};

export const pythonMemberAccessClass: TokenPattern = {
    debugName: "pythonMemberAccessClass",

    token: MetaTokenType.MemberAccess, /*meta.member.access.python*/
    begin: /(\.)\s*(?!\.)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.Period, /*punctuation.separator.period.python*/ },
    },
    end: /(?<=\S)(?=\W)|$/gm,
    patterns: [
        pythonMemberAccessBase,
        pythonInheritanceIdentifier,
    ]
};

export const pythonLambda: TokenPattern = {
    patterns: [
        {
            debugName: "pythonLambda.patterns![0]",

            match: /((?<=\.)lambda|lambda(?=\s*[\.=]))/dg,
            captures: {
                1: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/ },
            },
        },
        {
            debugName: "pythonLambda.patterns![1]",

            match: /\b(lambda)\s*?(?=[,\n]|$)/dgm,
            captures: {
                1: { token: KeywordTokenType.Lambda, /*storage.type.function.lambda.python*/ },
            },
        },
        {
            debugName: "pythonLambda.patterns![2]",

            token: MetaTokenType.LambdaFunction, /*meta.lambda-function.python*/
            contentToken: MetaTokenType.FunctionDefinition, /*meta.function.lambda.parameters.python*/
            begin: /\b(lambda)\b/dg,
            beginCaptures: {
                1: { token: KeywordTokenType.Lambda, /*storage.type.function.lambda.python*/ },
            },
            end: /(:)|(\n)/dg,
            endCaptures: {
                1: { token: CharacterTokenType.Colon, /*punctuation.section.function.lambda.begin.python*/ },
            },
            patterns: [
                {
                    debugName: "pythonLambda.patterns![2].patterns![0]",

                    token: OperatorTokenType.PositionalParameter, /*keyword.operator.positional.parameter.python*/
                    match: /\//g,
                },
                {
                    debugName: "pythonLambda.patterns![2].patterns![1]",

                    token: OperatorTokenType.Unpacking, /*keyword.operator.unpacking.parameter.python*/
                    match: /(\*\*|\*)/g,
                },
                {
                    debugName: "pythonLambda.patterns![2].patterns![4]",

                    match: /([[:alpha:]_]\w*)\s*(?:(,)|(?=:|$))/dgm,
                    captures: {
                        1: { token: EntityTokenType.VariableName, /*variable.parameter.function.language.python*/ },
                        2: { token: CharacterTokenType.Comma, /*punctuation.separator.parameters.python*/ },
                    },
                },
                pythonComments,
                pythonLineContinuation,
            ]
        },
    ]
};

export const pythonLambdaIncomplete: TokenPattern = {
    debugName: "pythonLambdaIncomplete",

    token: KeywordTokenType.Lambda, /*storage.type.function.lambda.python*/
    match: /\blambda(?=\s*[,)])/g,
};

export const pythonLambdaNestedIncomplete: TokenPattern = {
    debugName: "pythonLambdaNestedIncomplete",

    token: KeywordTokenType.Lambda, /*storage.type.function.lambda.python*/
    match: /\blambda(?=\s*[:,)])/g,
};

export const pythonLambdaParameterWithDefault: TokenPattern = {
    debugName: "pythonLambdaParameterWithDefault",

    begin: /\b([[:alpha:]_]\w*)\s*(=)/dg,
    beginCaptures: {
        1: { token: EntityTokenType.VariableName, /*variable.parameter.function.language.python*/ },
        2: { token: MetaTokenType.Operator, /*keyword.operator.python*/ },
    },
    end: /(,)|(?=:|$)/dgm,
    endCaptures: {
        1: { token: CharacterTokenType.Comma, /*punctuation.separator.parameters.python*/ },
    },
    patterns: [pythonExpression]
};

export const pythonGenerator: TokenPattern = {
    debugName: "pythonGenerator",

    // Match "for ... in" construct used in generators and for loops to correctly identify the "in" as a control flow keyword.
    begin: /\bfor\b/dg,
    beginCaptures: {
        0: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/ },
    },
    end: /\bin\b/dg,
    endCaptures: {
        0: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/ },
    },
    patterns: [pythonExpression]
};

export const pythonFunctionDeclaration: TokenPattern = {
    debugName: "pythonFunctionDeclaration",

    token: MetaTokenType.FunctionDefinition, /*meta.function.python*/
    begin: /\s*(?:\b(async)\s+)?\b(def)\s+(?=[[:alpha:]_][[:word:]]*\s*\()/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.Async, /*storage.type.function.async.python*/ },
        2: { token: KeywordTokenType.Def, /*storage.type.function.python*/ },
    },
    end: /(:|(?=[#'"\n]))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.Colon, /*punctuation.section.function.begin.python*/ },
    },
    patterns: [pythonLineContinuation]
};

export const pythonFunctionDefName: TokenPattern = {
    patterns: [
        {
            debugName: "pythonFunctionDefName.patterns![2]",

            token: EntityTokenType.FunctionName, /*entity.name.function.python*/
            match: /\b([[:alpha:]_]\w*)\b/g,
        },
    ]
};

export const pythonParameters: TokenPattern = {
    debugName: "pythonParameters",

    token: MetaTokenType.FunctionDefinition, /*meta.function.parameters.python*/
    begin: /(\()/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.definition.parameters.begin.python*/ },
    },
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.parameters.end.python*/ },
    },
    patterns: [
        {
            debugName: "pythonParameters.patterns![0]",

            token: OperatorTokenType.PositionalParameter, /*keyword.operator.positional.parameter.python*/
            match: /\//g,
        },
        {
            debugName: "pythonParameters.patterns![1]",

            token: OperatorTokenType.Unpacking, /*keyword.operator.unpacking.parameter.python*/
            match: /(\*\*|\*)/g,
        },
        pythonLambdaIncomplete,
        {
            debugName: "pythonParameters.patterns![6]",

            match: /([[:alpha:]_]\w*)\s*(?:(,)|(?=[)#\n=]))/dg,
            captures: {
                1: { token: EntityTokenType.VariableName, /*variable.parameter.function.language.python*/ },
                2: { token: CharacterTokenType.Comma, /*punctuation.separator.parameters.python*/ },
            },
        },
        pythonComments,
    ]
};

export const pythonParameterSpecial: TokenPattern = {
    debugName: "pythonParameterSpecial",

    match: /\b((self)|(cls))\b\s*(?:(,)|(?=\)))/dg,
    captures: {
        1: { token: EntityTokenType.VariableName, /*variable.parameter.function.language.python*/ },
        2: { token: EntityTokenType.VariableName, /*variable.parameter.function.language.special.self.python*/ },
        3: { token: EntityTokenType.VariableName, /*variable.parameter.function.language.special.cls.python*/ },
        4: { token: CharacterTokenType.Comma, /*punctuation.separator.parameters.python*/ },
    },
};

export const pythonLooseDefault: TokenPattern = {
    debugName: "pythonLooseDefault",

    begin: /(=)/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Operator, /*keyword.operator.python*/ },
    },
    end: /(,)|(?=\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.Comma, /*punctuation.separator.parameters.python*/ },
    },
    patterns: [pythonExpression]
};

export const pythonAnnotatedParameter: TokenPattern = {
    debugName: "pythonAnnotatedParameter",

    begin: /\b([[:alpha:]_]\w*)\s*(:)/dg,
    beginCaptures: {
        1: { token: EntityTokenType.VariableName, /*variable.parameter.function.language.python*/ },
        2: { token: CharacterTokenType.Colon, /*punctuation.separator.annotation.python*/ },
    },
    end: /(,)|(?=\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.Comma, /*punctuation.separator.parameters.python*/ },
    },
    patterns: [
        pythonExpression,
        {
            debugName: "pythonAnnotatedParameter.patterns![1]",

            token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/
            match: /=(?!=)/g,
        },
    ]
};

export const pythonReturnAnnotation: TokenPattern = {
    debugName: "pythonReturnAnnotation",

    begin: /(->)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.Colon, /*punctuation.separator.annotation.result.python*/ },
    },
    end: /(?=:)/g,
    patterns: [pythonExpression]
};

export const pythonItemAccess: TokenPattern = {
    patterns: [
        {
            debugName: "pythonItemAccess.patterns![0]",

            token: MetaTokenType.ItemAccess, /*meta.item-access.python*/
            begin: /\b(?=[[:alpha:]_]\w*\s*\[)/g,
            end: /(\])/dg,
            endCaptures: {
                1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.python*/ },
            },
            patterns: [pythonExpression]
        },
    ]
};

export const pythonItemName: TokenPattern = {
    patterns: [
        pythonSpecialNames,
        {
            debugName: "pythonItemName.patterns![3]",

            token: MetaTokenType.IndexedName, /*meta.indexed-name.python*/
            match: /\b([[:alpha:]_]\w*)\b/g,
        },
    ]
};

export const pythonItemIndex: TokenPattern = {
    debugName: "pythonItemIndex",

    contentToken: MetaTokenType.Arguments, /*meta.item-access.arguments.python*/
    begin: /(\[)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.definition.arguments.begin.python*/ },
    },
    end: /(?=\])/g,
    patterns: [
        {
            debugName: "pythonItemIndex.patterns![0]",

            token: CharacterTokenType.Colon, /*punctuation.separator.slice.python*/
            match: /:/g,
        },
        pythonExpression,
    ]
};

export const pythonDecorator: TokenPattern = {
    debugName: "pythonDecorator",

    token: MetaTokenType.FunctionDefinition, /*meta.function.decorator.python*/
    begin: /^\s*((@))\s*(?=[[:alpha:]_]\w*)/dgm,
    beginCaptures: {
        1: { token: EntityTokenType.FunctionName, /*entity.name.function.decorator.python*/ },
        2: { token: CharacterTokenType.AtSymbol, /*punctuation.definition.decorator.python*/ },
    },
    end: /(\))(?:(.*?)(?=\s*(?:\#|$)))|(?=\n|\#)/dgm,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.decorator.python*/ },
    },
    patterns: [
    ]
};

export const pythonDecoratorName: TokenPattern = {
    patterns: [
        {
            debugName: "pythonDecoratorName.patterns![2]",

            token: EntityTokenType.FunctionName, /*entity.name.function.decorator.python*/
            match: /([[:alpha:]_]\w*)|(\.)/dg,
            captures: {
                2: { token: CharacterTokenType.Period, /*punctuation.separator.period.python*/ },
            },
        },
        pythonLineContinuation,
        {
            debugName: "pythonDecoratorName.patterns![4]",

            token: MetaTokenType.Invalid, /*invalid.illegal.decorator.python*/
            match: /\s*([^([:alpha:]\s_\.#\\].*?)(?=\#|$)/dgm,
            captures: {
                1: { token: MetaTokenType.Invalid, /*invalid.illegal.decorator.python*/ },
            },
        },
    ]
};

export const pythonCallWrapperInheritance: TokenPattern = {
    debugName: "pythonCallWrapperInheritance",

    // same as a function call, but in inheritance context
    token: MetaTokenType.FunctionCall, /*meta.function-call.python*/
    begin: /\b(?=([[:alpha:]_]\w*)\s*(\())/g,
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.python*/ },
    },
    patterns: [
    ]
};

export const pythonInheritanceName: TokenPattern = {
    patterns: [
        pythonLambdaIncomplete,
        pythonInheritanceIdentifier,
    ]
};

export const pythonFunctionCall: TokenPattern = {
    debugName: "pythonFunctionCall",

    // Regular function call of the type "name(args)"
    token: MetaTokenType.FunctionCall, /*meta.function-call.python*/
    begin: /\b(?=([[:alpha:]_]\w*)\s*(\())/g,
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.python*/ },
    },
    patterns: [
    ]
};

export const pythonFunctionName: TokenPattern = {
    patterns: [
        {
            debugName: "pythonFunctionName.patterns![1]",

            // Some color schemas support meta.function-call.generic scope
            token: MetaTokenType.FunctionCall, /*meta.function-call.generic.python*/
            match: /\b([[:alpha:]_]\w*)\b/g,
        },
    ]
};

export const pythonFunctionArguments: TokenPattern = {
    debugName: "pythonFunctionArguments",

    contentToken: MetaTokenType.Arguments, /*meta.function-call.arguments.python*/
    begin: /(\()/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.definition.arguments.begin.python*/ },
    },
    end: /(?=\))(?!\)\s*\()/g,
    patterns: [
        {
            debugName: "pythonFunctionArguments.patterns![0]",

            token: CharacterTokenType.Comma, /*punctuation.separator.arguments.python*/
            match: /(,)/g,
        },
        {
            debugName: "pythonFunctionArguments.patterns![1]",

            match: /(?:(?<=[,(])|^)\s*(\*{1,2})/dgm,
            captures: {
                1: { token: OperatorTokenType.Unpacking, /*keyword.operator.unpacking.arguments.python*/ },
            },
        },
        pythonLambdaIncomplete,
        {
            debugName: "pythonFunctionArguments.patterns![4]",

            match: /\b([[:alpha:]_]\w*)\s*(=)(?!=)/dg,
            captures: {
                1: { token: EntityTokenType.VariableName, /*variable.parameter.function-call.python*/ },
                2: { token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/ },
            },
        },
        {
            debugName: "pythonFunctionArguments.patterns![5]",

            token: OperatorTokenType.Assignment, /*keyword.operator.assignment.python*/
            match: /=(?!=)/g,
        },
        pythonExpression,
        {
            debugName: "pythonFunctionArguments.patterns![7]",

            match: /\s*(\))\s*(\()/dg,
            captures: {
                1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.python*/ },
                2: { token: CharacterTokenType.OpenParentheses, /*punctuation.definition.arguments.begin.python*/ },
            },
        },
    ]
};

export const pythonBuiltinCallables: TokenPattern = {
    patterns: []
};

export const pythonBuiltinPossibleCallables: TokenPattern = {
    patterns: [
        pythonBuiltinCallables]
};

export const pythonBuiltinExceptions: TokenPattern = {
    debugName: "pythonBuiltinExceptions",

    token: MetaTokenType.BuiltinExceptionType, /*support.type.exception.python*/
    match: /(?<!\.)\b((Arithmetic|Assertion|Attribute|Buffer|BlockingIO|BrokenPipe|ChildProcess|(Connection(Aborted|Refused|Reset)?)|EOF|Environment|FileExists|FileNotFound|FloatingPoint|IO|Import|Indentation|Index|Interrupted|IsADirectory|NotADirectory|Permission|ProcessLookup|Timeout|Key|Lookup|Memory|Name|NotImplemented|OS|Overflow|Reference|Runtime|Recursion|Syntax|System|Tab|Type|UnboundLocal|Unicode(Encode|Decode|Translate)?|Value|Windows|ZeroDivision|ModuleNotFound)Error|((Pending)?Deprecation|Runtime|Syntax|User|Future|Import|Unicode|Bytes|Resource)?Warning|SystemExit|Stop(Async)?Iteration|KeyboardInterrupt|GeneratorExit|(Base)?Exception)\b/g,
};

export const pythonBuiltinFunctions: TokenPattern = {
    patterns: [
        {
            debugName: "pythonBuiltinFunctions.patterns![0]",

            token: EntityTokenType.FunctionName, /*support.function.builtin.python*/
            match: /(?<!\.)\b(__import__|abs|aiter|all|any|anext|ascii|bin|breakpoint|callable|chr|compile|copyright|credits|delattr|dir|divmod|enumerate|eval|exec|exit|filter|format|getattr|globals|hasattr|hash|help|hex|id|input|isinstance|issubclass|iter|len|license|locals|map|max|memoryview|min|next|oct|open|ord|pow|print|quit|range|reload|repr|reversed|round|setattr|sorted|sum|vars|zip)\b/g,
        },
        {
            debugName: "pythonBuiltinFunctions.patterns![1]",

            token: EntityTokenType.VariableName, /*variable.legacy.builtin.python*/
            match: /(?<!\.)\b(file|reduce|intern|raw_input|unicode|cmp|basestring|execfile|long|xrange)\b/g,
        },
    ]
};

export const pythonBuiltinTypes: TokenPattern = {
    debugName: "pythonBuiltinTypes",

    token: MetaTokenType.BuiltinType, /*support.type.python*/
    match: /(?<!\.)\b(bool|bytearray|bytes|classmethod|complex|dict|float|frozenset|int|list|object|property|set|slice|staticmethod|str|tuple|type|super)\b/g,
};

export const pythonMagicFunctionNames: TokenPattern = {
    debugName: "pythonMagicFunctionNames",

    // these methods have magic interpretation by python and are generally calledindirectly through syntactic constructs
    match: /\b(__(?:abs|add|aenter|aexit|aiter|and|anext|await|bool|call|ceil|class_getitem|cmp|coerce|complex|contains|copy|deepcopy|del|delattr|delete|delitem|delslice|dir|div|divmod|enter|eq|exit|float|floor|floordiv|format|ge|get|getattr|getattribute|getinitargs|getitem|getnewargs|getslice|getstate|gt|hash|hex|iadd|iand|idiv|ifloordiv||ilshift|imod|imul|index|init|instancecheck|int|invert|ior|ipow|irshift|isub|iter|itruediv|ixor|le|len|long|lshift|lt|missing|mod|mul|ne|neg|new|next|nonzero|oct|or|pos|pow|radd|rand|rdiv|rdivmod|reduce|reduce_ex|repr|reversed|rfloordiv||rlshift|rmod|rmul|ror|round|rpow|rrshift|rshift|rsub|rtruediv|rxor|set|setattr|setitem|set_name|setslice|setstate|sizeof|str|sub|subclasscheck|truediv|trunc|unicode|xor|matmul|rmatmul|imatmul|init_subclass|set_name|fspath|bytes|prepare|length_hint)__)\b/dg,
    captures: {
        1: { token: EntityTokenType.FunctionName, /*support.function.magic.python*/ },
    },
};

export const pythonMagicVariableNames: TokenPattern = {
    debugName: "pythonMagicVariableNames",

    // magic variables which a class/module may have.
    match: /\b(__(?:all|annotations|bases|builtins|class|closure|code|debug|defaults|dict|doc|file|func|globals|kwdefaults|match_args|members|metaclass|methods|module|mro|mro_entries|name|qualname|post_init|self|signature|slots|subclasses|version|weakref|wrapped|classcell|spec|path|package|future|traceback)__)\b/dg,
    captures: {
        1: { token: EntityTokenType.VariableName, /*support.variable.magic.python*/ },
    },
};

export const pythonMagicNames: TokenPattern = {
    patterns: [
        pythonMagicFunctionNames,
        pythonMagicVariableNames,
    ]
};

export const pythonIllegalNames: TokenPattern = {
    debugName: "pythonIllegalNames",

    match: /\b(?:(and|assert|async|await|break|class|continue|def|del|elif|else|except|finally|for|from|global|if|in|is|(?<=\.)lambda|lambda(?=\s*[\.=])|nonlocal|not|or|pass|raise|return|try|while|with|yield)|(as|import))\b/dg,
    captures: {
        1: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.python*/ },
        2: { token: KeywordTokenType.Import, /*keyword.control.import.python*/ },
    },
};

export const pythonSpecialVariables: TokenPattern = {
    debugName: "pythonSpecialVariables",

    match: /\b(?<!\.)(?:(self)|(cls))\b/dg,
    captures: {
        1: { token: EntityTokenType.VariableName, /*variable.language.special.self.python*/ },
        2: { token: EntityTokenType.VariableName, /*variable.language.special.cls.python*/ },
    },
};

export const pythonEllipsis: TokenPattern = {
    debugName: "pythonEllipsis",

    token: MetaTokenType.ConstantCaps, /*constant.other.ellipsis.python*/
    match: /\.\.\./g,
};

export const pythonBackticks: TokenPattern = {
    debugName: "pythonBackticks",

    token: MetaTokenType.Deprecated, /*invalid.deprecated.backtick.python*/
    begin: /\`/g,
    end: /(?:\`|(?<!\\)(\n))/g,
    patterns: [pythonExpression]
};

export const pythonIllegalOperator: TokenPattern = {
    patterns: [
        {
            debugName: "pythonIllegalOperator.patterns![0]",

            token: MetaTokenType.Invalid, /*invalid.illegal.operator.python*/
            match: /&&|\|\||--|\+\+/g,
        },
        {
            debugName: "pythonIllegalOperator.patterns![1]",

            token: MetaTokenType.Invalid, /*invalid.illegal.operator.python*/
            match: /[?$]/gm,
        },
        {
            debugName: "pythonIllegalOperator.patterns![2]",

            // We don't want `!` to flash when we're typing `!=`
            token: MetaTokenType.Invalid, /*invalid.illegal.operator.python*/
            match: /!\b/g,
        },
    ]
};

export const pythonIllegalObjectName: TokenPattern = {
    debugName: "pythonIllegalObjectName",

    // It's illegal to name class or function "True"
    token: MetaTokenType.Invalid, /*keyword.illegal.name.python*/
    match: /\b(True|False|None)\b/g,
};

export const pythonIllegalAnno: TokenPattern = {
    debugName: "pythonIllegalAnno",

    token: MetaTokenType.Invalid, /*invalid.illegal.annotation.python*/
    match: /->/g,
};

export const pythonRegexpBaseExpression: TokenPattern = {
    patterns: [
    ]
};

export const pythonFregexpBaseExpression: TokenPattern = {
    patterns: [
        {
            debugName: "pythonFregexpBaseExpression.patterns![2]",

            match: /\{.*?\}/g,
        },
    ]
};

export const pythonFstringFormattingBraces: TokenPattern = {
    patterns: [
        {
            debugName: "pythonFstringFormattingBraces.patterns![0]",

            // empty braces are illegal
            match: /({)(\s*?)(})/dg,
            captures: {
                1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.brace.python*/ },
                3: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
            },
        },
        {
            debugName: "pythonFstringFormattingBraces.patterns![1]",

            token: MetaTokenType.EscapeSequence, /*constant.character.escape.python*/
            match: /({{|}})/g,
        },
    ]
};

export const pythonRegexpBaseCommon: TokenPattern = {
    patterns: [
        {
            debugName: "pythonRegexpBaseCommon.patterns![0]",

            token: CharacterTokenType.Period, /*support.other.match.any.regexp*/
            match: /\./g,
        },
        {
            debugName: "pythonRegexpBaseCommon.patterns![1]",

            token: CharacterTokenType.Caret, /*support.other.match.begin.regexp*/
            match: /\^/gm,
        },
        {
            debugName: "pythonRegexpBaseCommon.patterns![2]",

            token: CharacterTokenType.DollarSymbol, /*support.other.match.end.regexp*/
            match: /\$/gm,
        },
        {
            debugName: "pythonRegexpBaseCommon.patterns![3]",

            token: OperatorTokenType.Quantifier, /*keyword.operator.quantifier.regexp*/
            match: /[+*?]\??/g,
        },
        {
            debugName: "pythonRegexpBaseCommon.patterns![4]",

            token: OperatorTokenType.Disjunction, /*keyword.operator.disjunction.regexp*/
            match: /\|/g,
        },
    ]
};

export const pythonRegexpQuantifier: TokenPattern = {
    debugName: "pythonRegexpQuantifier",

    token: OperatorTokenType.Quantifier, /*keyword.operator.quantifier.regexp*/
    match: /\{(\d+|\d+,(\d+)?|,\d+)\}/g,
};

export const pythonFregexpQuantifier: TokenPattern = {
    debugName: "pythonFregexpQuantifier",

    token: OperatorTokenType.Quantifier, /*keyword.operator.quantifier.regexp*/
    match: /\{\{(\d+|\d+,(\d+)?|,\d+)\}\}/g,
};

export const pythonRegexpBackreferenceNumber: TokenPattern = {
    debugName: "pythonRegexpBackreferenceNumber",

    token: MetaTokenType.Backreference, /*meta.backreference.regexp*/
    match: /(\\[1-9]\d?)/dg,
    captures: {
        1: { token: EntityTokenType.TagName, /*entity.name.tag.backreference.regexp*/ },
    },
};

export const pythonRegexpBackreference: TokenPattern = {
    debugName: "pythonRegexpBackreference",

    token: MetaTokenType.BackreferenceNamed, /*meta.backreference.named.regexp*/
    match: /(\()(\?P=\w+(?:\s+[[:alnum:]]+)?)(\))/dg,
    captures: {
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.backreference.named.regexp support.other.parenthesis.regexp*/ },
        2: { token: EntityTokenType.TagName, /*entity.name.tag.named.backreference.regexp*/ },
        3: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.backreference.named.regexp support.other.parenthesis.regexp*/ },
    },
};

export const pythonRegexpFlags: TokenPattern = {
    debugName: "pythonRegexpFlags",

    token: MetaTokenType.ModifierFlagStorageType, /*storage.modifier.flag.regexp*/
    match: /\(\?[aiLmsux]+\)/g,
};

export const pythonRegexpEscapeSpecial: TokenPattern = {
    debugName: "pythonRegexpEscapeSpecial",

    token: MetaTokenType.EscapeSequence, /*support.other.escape.special.regexp*/
    match: /\\([AbBdDsSwWZ])/g,
};

export const pythonRegexpEscapeCharacter: TokenPattern = {
    debugName: "pythonRegexpEscapeCharacter",

    token: MetaTokenType.EscapeSequence, /*constant.character.escape.regexp*/
    match: /\\(x[0-9A-Fa-f]{2}|0[0-7]{1,2}|[0-7]{3})/g,
};

export const pythonRegexpEscapeUnicode: TokenPattern = {
    debugName: "pythonRegexpEscapeUnicode",

    token: MetaTokenType.EscapeSequence, /*constant.character.unicode.regexp*/
    match: /\\(u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/g,
};

export const pythonRegexpEscapeCatchall: TokenPattern = {
    debugName: "pythonRegexpEscapeCatchall",

    token: MetaTokenType.EscapeSequence, /*constant.character.escape.regexp*/
    match: /\\(.|\n)/g,
};

export const pythonRegexpEscapeSequence: TokenPattern = {
    patterns: [
        pythonRegexpEscapeSpecial,
        pythonRegexpEscapeCharacter,
        pythonRegexpEscapeUnicode,
        pythonRegexpBackreferenceNumber,
        pythonRegexpEscapeCatchall,
    ]
};

export const pythonRegexpCharecterSetEscapes: TokenPattern = {
    patterns: [
        {
            debugName: "pythonRegexpCharecterSetEscapes.patterns![0]",

            token: MetaTokenType.EscapeSequence, /*constant.character.escape.regexp*/
            match: /\\[abfnrtv\\]/g,
        },
        pythonRegexpEscapeSpecial,
        {
            debugName: "pythonRegexpCharecterSetEscapes.patterns![2]",

            token: MetaTokenType.EscapeSequence, /*constant.character.escape.regexp*/
            match: /\\([0-7]{1,3})/g,
        },
        pythonRegexpEscapeCharacter,
        pythonRegexpEscapeUnicode,
        pythonRegexpEscapeCatchall,
    ]
};

export const pythonCodetags: TokenPattern = {
    debugName: "pythonCodetags",

    match: /(?:\b(NOTE|XXX|HACK|FIXME|BUG|TODO)\b)/dg,
    captures: {
        1: { token: MetaTokenType.CommentCodeTag, /*keyword.codetag.notation.python*/ },
    },
};

export const pythonCommentsBase: TokenPattern = {
    debugName: "pythonCommentsBase",

    token: MetaTokenType.Comment, /*comment.line.number-sign.python*/
    begin: /(\#)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.Hashtag, /*punctuation.definition.comment.python*/ },
    },
    end: /($)/gm,
    patterns: [pythonCodetags]
};

export const pythonCommentsStringSingleThree: TokenPattern = {
    debugName: "pythonCommentsStringSingleThree",

    token: MetaTokenType.Comment, /*comment.line.number-sign.python*/
    begin: /(\#)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.Hashtag, /*punctuation.definition.comment.python*/ },
    },
    end: /($|(?='''))/gm,
    patterns: [pythonCodetags]
};

export const pythonCommentsStringDoubleThree: TokenPattern = {
    debugName: "pythonCommentsStringDoubleThree",

    token: MetaTokenType.Comment, /*comment.line.number-sign.python*/
    begin: /(\#)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.Hashtag, /*punctuation.definition.comment.python*/ },
    },
    end: /($|(?="""))/gm,
    patterns: [pythonCodetags]
};

export const pythonSingleOneRegexpExpression: TokenPattern = {
    patterns: [
        pythonRegexpBaseExpression,
        pythonRegexpFlags,
        pythonRegexpBackreference,
    ]
};

export const pythonSingleOneRegexpCharacterSet: TokenPattern = {
    patterns: [
        {
            debugName: "pythonSingleOneRegexpCharacterSet.patterns![0]",

            match: /\[\^?\](?!.*?\])/gm,
        },
        {
            debugName: "pythonSingleOneRegexpCharacterSet.patterns![1]",

            token: MetaTokenType.CharacterSet, /*meta.character.set.regexp*/
            begin: /(\[)(\^)?(\])?/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.OpenSquareBracket, /*punctuation.character.set.begin.regexp constant.other.set.regexp*/ },
                2: { token: OperatorTokenType.Negation, /*keyword.operator.negation.regexp*/ },
                3: { token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/ },
            },
            end: /(\]|(?=\'))|((?=(?<!\\)\n))/dg,
            endCaptures: {
                1: { token: CharacterTokenType.CloseSquareBracket, /*punctuation.character.set.end.regexp constant.other.set.regexp*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
            },
            patterns: [
                pythonRegexpCharecterSetEscapes,
                {
                    debugName: "pythonSingleOneRegexpCharacterSet.patterns![1].patterns![1]",

                    token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/
                    match: /[^\n]/g,
                },
            ]
        },
    ]
};

export const pythonSingleOneRegexpNamedGroup: TokenPattern = {
    debugName: "pythonSingleOneRegexpNamedGroup",

    token: MetaTokenType.Named, /*meta.named.regexp*/
    begin: /(\()(\?P<\w+(?:\s+[[:alnum:]]+)?>)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.named.regexp support.other.parenthesis.regexp*/ },
        2: { token: EntityTokenType.TagName, /*entity.name.tag.named.group.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.named.regexp support.other.parenthesis.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonSingleOneRegexpExpression]
};

export const pythonSingleOneRegexpComments: TokenPattern = {
    debugName: "pythonSingleOneRegexpComments",

    token: MetaTokenType.Comment, /*comment.regexp*/
    begin: /\(\?#/dg,
    beginCaptures: {
        0: { token: MetaTokenType.CommentBegin, /*punctuation.comment.begin.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: MetaTokenType.CommentEnd, /*punctuation.comment.end.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonCodetags]
};

export const pythonSingleOneRegexpLookahead: TokenPattern = {
    debugName: "pythonSingleOneRegexpLookahead",

    begin: /(\()\?=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookahead, /*keyword.operator.lookahead.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.lookahead.regexp keyword.operator.lookahead.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonSingleOneRegexpExpression]
};

export const pythonSingleOneRegexpLookaheadNegative: TokenPattern = {
    debugName: "pythonSingleOneRegexpLookaheadNegative",

    begin: /(\()\?!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookaheadNegative, /*keyword.operator.lookahead.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.lookahead.regexp keyword.operator.lookahead.negative.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonSingleOneRegexpExpression]
};

export const pythonSingleOneRegexpLookbehind: TokenPattern = {
    debugName: "pythonSingleOneRegexpLookbehind",

    begin: /(\()\?<=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookbehind, /*keyword.operator.lookbehind.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.lookbehind.regexp keyword.operator.lookbehind.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonSingleOneRegexpExpression]
};

export const pythonSingleOneRegexpLookbehindNegative: TokenPattern = {
    debugName: "pythonSingleOneRegexpLookbehindNegative",

    begin: /(\()\?<!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookbehindNegative, /*keyword.operator.lookbehind.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.lookbehind.regexp keyword.operator.lookbehind.negative.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonSingleOneRegexpExpression]
};

export const pythonSingleOneRegexpConditional: TokenPattern = {
    debugName: "pythonSingleOneRegexpConditional",

    begin: /(\()\?\((\w+(?:\s+[[:alnum:]]+)?|\d+)\)/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Conditional, /*keyword.operator.conditional.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.conditional.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.conditional.regexp keyword.operator.conditional.negative.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonSingleOneRegexpExpression]
};

export const pythonSingleOneRegexpParenthesesNonCapturing: TokenPattern = {
    debugName: "pythonSingleOneRegexpParenthesesNonCapturing",

    begin: /\(\?:/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.non-capturing.regexp support.other.parenthesis.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.non-capturing.regexp support.other.parenthesis.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonSingleOneRegexpExpression]
};

export const pythonSingleOneRegexpParentheses: TokenPattern = {
    debugName: "pythonSingleOneRegexpParentheses",

    begin: /\(/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.regexp support.other.parenthesis.regexp*/ },
    },
    end: /(\)|(?=\'))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.regexp support.other.parenthesis.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonSingleOneRegexpExpression]
};

export const pythonSingleThreeRegexpExpression: TokenPattern = {
    patterns: [
        pythonRegexpBaseExpression,
        pythonRegexpFlags,
        pythonRegexpBackreference,
        pythonCommentsStringSingleThree,
    ]
};

export const pythonSingleThreeRegexpCharacterSet: TokenPattern = {
    patterns: [
        {
            debugName: "pythonSingleThreeRegexpCharacterSet.patterns![0]",

            match: /\[\^?\](?!.*?\])/gm,
        },
        {
            debugName: "pythonSingleThreeRegexpCharacterSet.patterns![1]",

            token: MetaTokenType.CharacterSet, /*meta.character.set.regexp*/
            begin: /(\[)(\^)?(\])?/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.OpenSquareBracket, /*punctuation.character.set.begin.regexp constant.other.set.regexp*/ },
                2: { token: OperatorTokenType.Negation, /*keyword.operator.negation.regexp*/ },
                3: { token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/ },
            },
            end: /(\]|(?=\'\'\'))/dg,
            endCaptures: {
                1: { token: CharacterTokenType.CloseSquareBracket, /*punctuation.character.set.end.regexp constant.other.set.regexp*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
            },
            patterns: [
                pythonRegexpCharecterSetEscapes,
                {
                    debugName: "pythonSingleThreeRegexpCharacterSet.patterns![1].patterns![1]",

                    token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/
                    match: /[^\n]/g,
                },
            ]
        },
    ]
};

export const pythonSingleThreeRegexpNamedGroup: TokenPattern = {
    debugName: "pythonSingleThreeRegexpNamedGroup",

    token: MetaTokenType.Named, /*meta.named.regexp*/
    begin: /(\()(\?P<\w+(?:\s+[[:alnum:]]+)?>)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.named.regexp support.other.parenthesis.regexp*/ },
        2: { token: EntityTokenType.TagName, /*entity.name.tag.named.group.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.named.regexp support.other.parenthesis.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonSingleThreeRegexpExpression,
        pythonCommentsStringSingleThree,
    ]
};

export const pythonSingleThreeRegexpComments: TokenPattern = {
    debugName: "pythonSingleThreeRegexpComments",

    token: MetaTokenType.Comment, /*comment.regexp*/
    begin: /\(\?#/dg,
    beginCaptures: {
        0: { token: MetaTokenType.CommentBegin, /*punctuation.comment.begin.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: MetaTokenType.CommentEnd, /*punctuation.comment.end.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonCodetags]
};

export const pythonSingleThreeRegexpLookahead: TokenPattern = {
    debugName: "pythonSingleThreeRegexpLookahead",

    begin: /(\()\?=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookahead, /*keyword.operator.lookahead.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.lookahead.regexp keyword.operator.lookahead.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonSingleThreeRegexpExpression,
        pythonCommentsStringSingleThree,
    ]
};

export const pythonSingleThreeRegexpLookaheadNegative: TokenPattern = {
    debugName: "pythonSingleThreeRegexpLookaheadNegative",

    begin: /(\()\?!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookaheadNegative, /*keyword.operator.lookahead.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.lookahead.regexp keyword.operator.lookahead.negative.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonSingleThreeRegexpExpression,
        pythonCommentsStringSingleThree,
    ]
};

export const pythonSingleThreeRegexpLookbehind: TokenPattern = {
    debugName: "pythonSingleThreeRegexpLookbehind",

    begin: /(\()\?<=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookbehind, /*keyword.operator.lookbehind.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: OperatorTokenType.Lookbehind, /*keyword.operator.lookbehind.regexp punctuation.parenthesis.end.lookbehind.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonSingleThreeRegexpExpression,
        pythonCommentsStringSingleThree,
    ]
};

export const pythonSingleThreeRegexpLookbehindNegative: TokenPattern = {
    debugName: "pythonSingleThreeRegexpLookbehindNegative",

    begin: /(\()\?<!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookbehindNegative, /*keyword.operator.lookbehind.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: OperatorTokenType.LookbehindNegative, /*keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.end.lookbehind.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonSingleThreeRegexpExpression,
        pythonCommentsStringSingleThree,
    ]
};

export const pythonSingleThreeRegexpConditional: TokenPattern = {
    debugName: "pythonSingleThreeRegexpConditional",

    begin: /(\()\?\((\w+(?:\s+[[:alnum:]]+)?|\d+)\)/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Conditional, /*keyword.operator.conditional.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.conditional.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: OperatorTokenType.ConditionalNegative, /*keyword.operator.conditional.negative.regexp punctuation.parenthesis.end.conditional.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonSingleThreeRegexpExpression,
        pythonCommentsStringSingleThree,
    ]
};

export const pythonSingleThreeRegexpParenthesesNonCapturing: TokenPattern = {
    debugName: "pythonSingleThreeRegexpParenthesesNonCapturing",

    begin: /\(\?:/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.non-capturing.regexp support.other.parenthesis.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.non-capturing.regexp support.other.parenthesis.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonSingleThreeRegexpExpression,
        pythonCommentsStringSingleThree,
    ]
};

export const pythonSingleThreeRegexpParentheses: TokenPattern = {
    debugName: "pythonSingleThreeRegexpParentheses",

    begin: /\(/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.regexp support.other.parenthesis.regexp*/ },
    },
    end: /(\)|(?=\'\'\'))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.regexp support.other.parenthesis.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonSingleThreeRegexpExpression,
        pythonCommentsStringSingleThree,
    ]
};

export const pythonDoubleOneRegexpExpression: TokenPattern = {
    patterns: [
        pythonRegexpBaseExpression,
        pythonRegexpFlags,
        pythonRegexpBackreference,
    ]
};

export const pythonDoubleOneRegexpCharacterSet: TokenPattern = {
    patterns: [
        {
            debugName: "pythonDoubleOneRegexpCharacterSet.patterns![0]",

            match: /\[\^?\](?!.*?\])/gm,
        },
        {
            debugName: "pythonDoubleOneRegexpCharacterSet.patterns![1]",

            token: MetaTokenType.CharacterSet, /*meta.character.set.regexp*/
            begin: /(\[)(\^)?(\])?/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.OpenSquareBracket, /*punctuation.character.set.begin.regexp constant.other.set.regexp*/ },
                2: { token: OperatorTokenType.Negation, /*keyword.operator.negation.regexp*/ },
                3: { token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/ },
            },
            end: /(\]|(?="))|((?=(?<!\\)\n))/dg,
            endCaptures: {
                1: { token: CharacterTokenType.CloseSquareBracket, /*punctuation.character.set.end.regexp constant.other.set.regexp*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
            },
            patterns: [
                pythonRegexpCharecterSetEscapes,
                {
                    debugName: "pythonDoubleOneRegexpCharacterSet.patterns![1].patterns![1]",

                    token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/
                    match: /[^\n]/g,
                },
            ]
        },
    ]
};

export const pythonDoubleOneRegexpNamedGroup: TokenPattern = {
    debugName: "pythonDoubleOneRegexpNamedGroup",

    token: MetaTokenType.Named, /*meta.named.regexp*/
    begin: /(\()(\?P<\w+(?:\s+[[:alnum:]]+)?>)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.named.regexp support.other.parenthesis.regexp*/ },
        2: { token: EntityTokenType.TagName, /*entity.name.tag.named.group.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.named.regexp support.other.parenthesis.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonDoubleOneRegexpExpression]
};

export const pythonDoubleOneRegexpComments: TokenPattern = {
    debugName: "pythonDoubleOneRegexpComments",

    token: MetaTokenType.Comment, /*comment.regexp*/
    begin: /\(\?#/dg,
    beginCaptures: {
        0: { token: MetaTokenType.CommentBegin, /*punctuation.comment.begin.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: MetaTokenType.CommentEnd, /*punctuation.comment.end.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonCodetags]
};

export const pythonDoubleOneRegexpLookahead: TokenPattern = {
    debugName: "pythonDoubleOneRegexpLookahead",

    begin: /(\()\?=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookahead, /*keyword.operator.lookahead.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: OperatorTokenType.Lookahead, /*keyword.operator.lookahead.regexp punctuation.parenthesis.end.lookahead.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonDoubleOneRegexpExpression]
};

export const pythonDoubleOneRegexpLookaheadNegative: TokenPattern = {
    debugName: "pythonDoubleOneRegexpLookaheadNegative",

    begin: /(\()\?!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookaheadNegative, /*keyword.operator.lookahead.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: OperatorTokenType.LookaheadNegative, /*keyword.operator.lookahead.negative.regexp punctuation.parenthesis.end.lookahead.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonDoubleOneRegexpExpression]
};

export const pythonDoubleOneRegexpLookbehind: TokenPattern = {
    debugName: "pythonDoubleOneRegexpLookbehind",

    begin: /(\()\?<=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookbehind, /*keyword.operator.lookbehind.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: OperatorTokenType.Lookbehind, /*keyword.operator.lookbehind.regexp punctuation.parenthesis.end.lookbehind.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonDoubleOneRegexpExpression]
};

export const pythonDoubleOneRegexpLookbehindNegative: TokenPattern = {
    debugName: "pythonDoubleOneRegexpLookbehindNegative",

    begin: /(\()\?<!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookbehindNegative, /*keyword.operator.lookbehind.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: OperatorTokenType.LookbehindNegative, /*keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.end.lookbehind.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonDoubleOneRegexpExpression]
};

export const pythonDoubleOneRegexpConditional: TokenPattern = {
    debugName: "pythonDoubleOneRegexpConditional",

    begin: /(\()\?\((\w+(?:\s+[[:alnum:]]+)?|\d+)\)/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Conditional, /*keyword.operator.conditional.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.conditional.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: OperatorTokenType.ConditionalNegative, /*keyword.operator.conditional.negative.regexp punctuation.parenthesis.end.conditional.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonDoubleOneRegexpExpression]
};

export const pythonDoubleOneRegexpParenthesesNonCapturing: TokenPattern = {
    debugName: "pythonDoubleOneRegexpParenthesesNonCapturing",

    begin: /\(\?:/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.non-capturing.regexp support.other.parenthesis.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.non-capturing.regexp support.other.parenthesis.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonDoubleOneRegexpExpression]
};

export const pythonDoubleOneRegexpParentheses: TokenPattern = {
    debugName: "pythonDoubleOneRegexpParentheses",

    begin: /\(/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.regexp support.other.parenthesis.regexp*/ },
    },
    end: /(\)|(?="))|((?=(?<!\\)\n))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.regexp support.other.parenthesis.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonDoubleOneRegexpExpression]
};

export const pythonDoubleThreeRegexpExpression: TokenPattern = {
    patterns: [
        pythonRegexpBaseExpression,
        pythonRegexpFlags,
        pythonRegexpBackreference,
        pythonCommentsStringDoubleThree,
    ]
};

export const pythonDoubleThreeRegexpCharacterSet: TokenPattern = {
    patterns: [
        {
            debugName: "pythonDoubleThreeRegexpCharacterSet.patterns![0]",

            match: /\[\^?\](?!.*?\])/gm,
        },
        {
            debugName: "pythonDoubleThreeRegexpCharacterSet.patterns![1]",

            token: MetaTokenType.CharacterSet, /*meta.character.set.regexp*/
            begin: /(\[)(\^)?(\])?/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.OpenSquareBracket, /*punctuation.character.set.begin.regexp constant.other.set.regexp*/ },
                2: { token: OperatorTokenType.Negation, /*keyword.operator.negation.regexp*/ },
                3: { token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/ },
            },
            end: /(\]|(?="""))/dg,
            endCaptures: {
                1: { token: CharacterTokenType.CloseSquareBracket, /*punctuation.character.set.end.regexp constant.other.set.regexp*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
            },
            patterns: [
                pythonRegexpCharecterSetEscapes,
                {
                    debugName: "pythonDoubleThreeRegexpCharacterSet.patterns![1].patterns![1]",

                    token: MetaTokenType.CharacterSet, /*constant.character.set.regexp*/
                    match: /[^\n]/g,
                },
            ]
        },
    ]
};

export const pythonDoubleThreeRegexpNamedGroup: TokenPattern = {
    debugName: "pythonDoubleThreeRegexpNamedGroup",

    token: MetaTokenType.Named, /*meta.named.regexp*/
    begin: /(\()(\?P<\w+(?:\s+[[:alnum:]]+)?>)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.named.regexp support.other.parenthesis.regexp*/ },
        2: { token: EntityTokenType.TagName, /*entity.name.tag.named.group.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.named.regexp support.other.parenthesis.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonDoubleThreeRegexpExpression,
        pythonCommentsStringDoubleThree,
    ]
};

export const pythonDoubleThreeRegexpComments: TokenPattern = {
    debugName: "pythonDoubleThreeRegexpComments",

    token: MetaTokenType.Comment, /*comment.regexp*/
    begin: /\(\?#/dg,
    beginCaptures: {
        0: { token: MetaTokenType.CommentBegin, /*punctuation.comment.begin.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: MetaTokenType.CommentEnd, /*punctuation.comment.end.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonCodetags]
};

export const pythonDoubleThreeRegexpLookahead: TokenPattern = {
    debugName: "pythonDoubleThreeRegexpLookahead",

    begin: /(\()\?=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookahead, /*keyword.operator.lookahead.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: OperatorTokenType.Lookahead, /*keyword.operator.lookahead.regexp punctuation.parenthesis.end.lookahead.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonDoubleThreeRegexpExpression,
        pythonCommentsStringDoubleThree,
    ]
};

export const pythonDoubleThreeRegexpLookaheadNegative: TokenPattern = {
    debugName: "pythonDoubleThreeRegexpLookaheadNegative",

    begin: /(\()\?!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookaheadNegative, /*keyword.operator.lookahead.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookahead.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: OperatorTokenType.LookaheadNegative, /*keyword.operator.lookahead.negative.regexp punctuation.parenthesis.end.lookahead.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonDoubleThreeRegexpExpression,
        pythonCommentsStringDoubleThree,
    ]
};

export const pythonDoubleThreeRegexpLookbehind: TokenPattern = {
    debugName: "pythonDoubleThreeRegexpLookbehind",

    begin: /(\()\?<=/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Lookbehind, /*keyword.operator.lookbehind.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: OperatorTokenType.Lookbehind, /*keyword.operator.lookbehind.regexp punctuation.parenthesis.end.lookbehind.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonDoubleThreeRegexpExpression,
        pythonCommentsStringDoubleThree,
    ]
};

export const pythonDoubleThreeRegexpLookbehindNegative: TokenPattern = {
    debugName: "pythonDoubleThreeRegexpLookbehindNegative",

    begin: /(\()\?<!/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.LookbehindNegative, /*keyword.operator.lookbehind.negative.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.lookbehind.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: OperatorTokenType.LookbehindNegative, /*keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.end.lookbehind.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonDoubleThreeRegexpExpression,
        pythonCommentsStringDoubleThree,
    ]
};

export const pythonDoubleThreeRegexpConditional: TokenPattern = {
    debugName: "pythonDoubleThreeRegexpConditional",

    begin: /(\()\?\((\w+(?:\s+[[:alnum:]]+)?|\d+)\)/dg,
    beginCaptures: {
        0: { token: OperatorTokenType.Conditional, /*keyword.operator.conditional.regexp*/ },
        1: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.conditional.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: OperatorTokenType.ConditionalNegative, /*keyword.operator.conditional.negative.regexp punctuation.parenthesis.end.conditional.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonDoubleThreeRegexpExpression,
        pythonCommentsStringDoubleThree,
    ]
};

export const pythonDoubleThreeRegexpParenthesesNonCapturing: TokenPattern = {
    debugName: "pythonDoubleThreeRegexpParenthesesNonCapturing",

    begin: /\(\?:/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.non-capturing.regexp support.other.parenthesis.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.non-capturing.regexp support.other.parenthesis.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonDoubleThreeRegexpExpression,
        pythonCommentsStringDoubleThree,
    ]
};

export const pythonDoubleThreeRegexpParentheses: TokenPattern = {
    debugName: "pythonDoubleThreeRegexpParentheses",

    begin: /\(/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.regexp support.other.parenthesis.regexp*/ },
    },
    end: /(\)|(?="""))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.regexp support.other.parenthesis.regexp*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonDoubleThreeRegexpExpression,
        pythonCommentsStringDoubleThree,
    ]
};

export const pythonRegexpSingleOneLine: TokenPattern = {
    debugName: "pythonRegexpSingleOneLine",

    token: LiteralTokenType.String, /*string.regexp.quoted.single.python*/
    begin: /\b(([uU]r)|([bB]r)|(r[bB]?))(\')/dg,
    beginCaptures: {
        2: { token: MetaTokenType.Deprecated, /*invalid.deprecated.prefix.python*/ },
        3: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        4: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        5: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(\')|(?<!\\)(\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonSingleOneRegexpExpression]
};

export const pythonRegexpSingleThreeLine: TokenPattern = {
    debugName: "pythonRegexpSingleThreeLine",

    token: LiteralTokenType.String, /*string.regexp.quoted.multi.python*/
    begin: /\b(([uU]r)|([bB]r)|(r[bB]?))(\'\'\')/dg,
    beginCaptures: {
        2: { token: MetaTokenType.Deprecated, /*invalid.deprecated.prefix.python*/ },
        3: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        4: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        5: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(\'\'\')/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonSingleThreeRegexpExpression]
};

export const pythonRegexpDoubleOneLine: TokenPattern = {
    debugName: "pythonRegexpDoubleOneLine",

    token: LiteralTokenType.String, /*string.regexp.quoted.single.python*/
    begin: /\b(([uU]r)|([bB]r)|(r[bB]?))(")/dg,
    beginCaptures: {
        2: { token: MetaTokenType.Deprecated, /*invalid.deprecated.prefix.python*/ },
        3: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        4: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        5: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(")|(?<!\\)(\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonDoubleOneRegexpExpression]
};

export const pythonRegexpDoubleThreeLine: TokenPattern = {
    debugName: "pythonRegexpDoubleThreeLine",

    token: LiteralTokenType.String, /*string.regexp.quoted.multi.python*/
    begin: /\b(([uU]r)|([bB]r)|(r[bB]?))(""")/dg,
    beginCaptures: {
        2: { token: MetaTokenType.Deprecated, /*invalid.deprecated.prefix.python*/ },
        3: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        4: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        5: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(""")/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonDoubleThreeRegexpExpression]
};

export const pythonStringRawQuotedSingleLine: TokenPattern = {
    debugName: "pythonStringRawQuotedSingleLine",

    token: LiteralTokenType.String, /*string.quoted.raw.single.python*/
    begin: /\b(([uU]R)|(R))((['"]))/dg,
    beginCaptures: {
        2: { token: MetaTokenType.Deprecated, /*invalid.deprecated.prefix.python*/ },
        3: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        4: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(\4)|((?<!\\)\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonStringRawGuts]
};

export const pythonStringBinQuotedSingleLine: TokenPattern = {
    debugName: "pythonStringBinQuotedSingleLine",

    token: LiteralTokenType.String, /*string.quoted.binary.single.python*/
    begin: /(\b[bB])((['"]))/dg,
    beginCaptures: {
        1: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        2: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(\2)|((?<!\\)\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonStringEntity]
};

export const pythonStringRawBinQuotedSingleLine: TokenPattern = {
    debugName: "pythonStringRawBinQuotedSingleLine",

    token: LiteralTokenType.String, /*string.quoted.raw.binary.single.python*/
    begin: /(\b(?:R[bB]|[bB]R))((['"]))/dg,
    beginCaptures: {
        1: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        2: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(\2)|((?<!\\)\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonStringRawBinGuts]
};

export const pythonStringQuotedSingleLine: TokenPattern = {
    debugName: "pythonStringQuotedSingleLine",

    token: LiteralTokenType.String, /*string.quoted.single.python*/
    begin: /(?:\b([rR])(?=[uU]))?([uU])?((['"]))/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.prefix.python*/ },
        2: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        3: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(\3)|((?<!\\)\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonStringUnicodeGuts]
};

export const pythonStringSingleBadBrace1FormattingUnicode: TokenPattern = {
    debugName: "pythonStringSingleBadBrace1FormattingUnicode",

    // template using {% ... %}
    begin: /(?=\{%(.*?(?!(['"])|((?<!\\)\n)))%\})/g,
    end: /(?=(['"])|((?<!\\)\n))/g,
    patterns: [
        pythonEscapeSequenceUnicode,
        pythonEscapeSequence,
        pythonStringLineContinuation,
    ]
};

export const pythonStringSingleBadBrace1FormattingRaw: TokenPattern = {
    debugName: "pythonStringSingleBadBrace1FormattingRaw",

    // template using {% ... %}
    begin: /(?=\{%(.*?(?!(['"])|((?<!\\)\n)))%\})/g,
    end: /(?=(['"])|((?<!\\)\n))/g,
    patterns: [pythonStringConsumeEscape]
};

export const pythonStringSingleBadBrace2FormattingUnicode: TokenPattern = {
    debugName: "pythonStringSingleBadBrace2FormattingUnicode",

    // odd format or format-like syntax
    begin: /(?!\{\{)(?=\{(\w*?(?!(['"])|((?<!\\)\n))[^!:\.\[}\w]).*?(?!(['"])|((?<!\\)\n))\})/g,
    end: /(?=(['"])|((?<!\\)\n))/g,
    patterns: [
        pythonEscapeSequenceUnicode,
        pythonStringEntity,
    ]
};

export const pythonStringSingleBadBrace2FormattingRaw: TokenPattern = {
    debugName: "pythonStringSingleBadBrace2FormattingRaw",

    // odd format or format-like syntax
    begin: /(?!\{\{)(?=\{(\w*?(?!(['"])|((?<!\\)\n))[^!:\.\[}\w]).*?(?!(['"])|((?<!\\)\n))\})/g,
    end: /(?=(['"])|((?<!\\)\n))/g,
    patterns: [
        pythonStringConsumeEscape,
        pythonStringFormatting,
    ]
};

export const pythonStringRawQuotedMultiLine: TokenPattern = {
    debugName: "pythonStringRawQuotedMultiLine",

    token: LiteralTokenType.String, /*string.quoted.raw.multi.python*/
    begin: /\b(([uU]R)|(R))('''|""")/dg,
    beginCaptures: {
        2: { token: MetaTokenType.Deprecated, /*invalid.deprecated.prefix.python*/ },
        3: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        4: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(\4)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonStringRawGuts]
};

export const pythonStringBinQuotedMultiLine: TokenPattern = {
    debugName: "pythonStringBinQuotedMultiLine",

    token: LiteralTokenType.String, /*string.quoted.binary.multi.python*/
    begin: /(\b[bB])('''|""")/dg,
    beginCaptures: {
        1: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        2: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(\2)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonStringEntity]
};

export const pythonStringRawBinQuotedMultiLine: TokenPattern = {
    debugName: "pythonStringRawBinQuotedMultiLine",

    token: LiteralTokenType.String, /*string.quoted.raw.binary.multi.python*/
    begin: /(\b(?:R[bB]|[bB]R))('''|""")/dg,
    beginCaptures: {
        1: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        2: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(\2)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonStringRawBinGuts]
};

export const pythonStringQuotedMultiLine: TokenPattern = {
    debugName: "pythonStringQuotedMultiLine",

    token: LiteralTokenType.String, /*string.quoted.multi.python*/
    begin: /(?:\b([rR])(?=[uU]))?([uU])?('''|""")/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.prefix.python*/ },
        2: { token: MetaTokenType.StringStorageType, /*storage.type.string.python*/ },
        3: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python*/ },
    },
    end: /(\3)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [pythonStringUnicodeGuts]
};

export const pythonStringMultiBadBrace1FormattingUnicode: TokenPattern = {
    debugName: "pythonStringMultiBadBrace1FormattingUnicode",

    // template using {% ... %}
    begin: /(?=\{%(.*?(?!'''|"""))%\})/g,
    end: /(?='''|""")/g,
    patterns: [
        pythonEscapeSequenceUnicode,
        pythonEscapeSequence,
        pythonStringLineContinuation,
    ]
};

export const pythonStringMultiBadBrace1FormattingRaw: TokenPattern = {
    debugName: "pythonStringMultiBadBrace1FormattingRaw",

    // template using {% ... %}
    begin: /(?=\{%(.*?(?!'''|"""))%\})/g,
    end: /(?='''|""")/g,
    patterns: [pythonStringConsumeEscape]
};

export const pythonStringMultiBadBrace2FormattingUnicode: TokenPattern = {
    debugName: "pythonStringMultiBadBrace2FormattingUnicode",

    // odd format or format-like syntax
    begin: /(?!\{\{)(?=\{(\w*?(?!'''|""")[^!:\.\[}\w]).*?(?!'''|""")\})/g,
    end: /(?='''|""")/g,
    patterns: [
        pythonEscapeSequenceUnicode,
        pythonStringEntity,
    ]
};

export const pythonStringMultiBadBrace2FormattingRaw: TokenPattern = {
    debugName: "pythonStringMultiBadBrace2FormattingRaw",

    // odd format or format-like syntax
    begin: /(?!\{\{)(?=\{(\w*?(?!'''|""")[^!:\.\[}\w]).*?(?!'''|""")\})/g,
    end: /(?='''|""")/g,
    patterns: [
        pythonStringConsumeEscape,
        pythonStringFormatting,
    ]
};

export const pythonFstringFnormQuotedSingleLine: TokenPattern = {
    debugName: "pythonFstringFnormQuotedSingleLine",

    token: MetaTokenType.Fstring, /*meta.fstring.python*/
    begin: /(\b[fF])([bBuU])?((['"]))/dg,
    beginCaptures: {
        1: { token: LiteralTokenType.String, /*string.interpolated.python string.quoted.single.python storage.type.string.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.prefix.python*/ },
        3: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python string.interpolated.python string.quoted.single.python*/ },
    },
    end: /(\3)|((?<!\\)\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python string.interpolated.python string.quoted.single.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonFstringGuts,
        pythonFstringIllegalSingleBrace,
    ]
};

export const pythonFstringNormfQuotedSingleLine: TokenPattern = {
    debugName: "pythonFstringNormfQuotedSingleLine",

    token: MetaTokenType.Fstring, /*meta.fstring.python*/
    begin: /(\b[bBuU])([fF])((['"]))/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.prefix.python*/ },
        2: { token: LiteralTokenType.String, /*string.interpolated.python string.quoted.single.python storage.type.string.python*/ },
        3: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python string.quoted.single.python*/ },
    },
    end: /(\3)|((?<!\\)\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python string.interpolated.python string.quoted.single.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonFstringGuts,
        pythonFstringIllegalSingleBrace,
    ]
};

export const pythonFstringRawQuotedSingleLine: TokenPattern = {
    debugName: "pythonFstringRawQuotedSingleLine",

    token: MetaTokenType.Fstring, /*meta.fstring.python*/
    begin: /(\b(?:[rR][fF]|[fF][rR]))((['"]))/dg,
    beginCaptures: {
        1: { token: LiteralTokenType.String, /*string.interpolated.python string.quoted.raw.single.python storage.type.string.python*/ },
        2: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python string.quoted.raw.single.python*/ },
    },
    end: /(\2)|((?<!\\)\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python string.interpolated.python string.quoted.raw.single.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonFstringRawGuts,
        pythonFstringIllegalSingleBrace,
    ]
};

export const pythonFstringSingleCore: TokenPattern = {
    debugName: "pythonFstringSingleCore",

    token: LiteralTokenType.String, /*string.interpolated.python string.quoted.single.python*/
    match: /(.+?)(($\n?)|(?=[\\\}\{]|(['"])|((?<!\\)\n)))|\n/gm,
};

export const pythonFstringRawSingleCore: TokenPattern = {
    debugName: "pythonFstringRawSingleCore",

    token: LiteralTokenType.String, /*string.interpolated.python string.quoted.raw.single.python*/
    match: /(.+?)(($\n?)|(?=[\\\}\{]|(['"])|((?<!\\)\n)))|\n/gm,
};

export const pythonFstringSingleBrace: TokenPattern = {
    debugName: "pythonFstringSingleBrace",

    // value interpolation using { ... }
    begin: /(\{)/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
    },
    end: /(\})|(?=\n)/dg,
    endCaptures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
    },
    patterns: [pythonFExpression]
};

export const pythonFstringTerminatorSingle: TokenPattern = {
    patterns: [
        {
            debugName: "pythonFstringTerminatorSingle.patterns![0]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(=(![rsa])?)(?=})/g,
        },
        {
            debugName: "pythonFstringTerminatorSingle.patterns![1]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(=?![rsa])(?=})/g,
        },
        {
            debugName: "pythonFstringTerminatorSingle.patterns![2]",

            match: /((?:=?)(?:![rsa])?)(:\w?[<>=^]?[-+ ]?\#?\d*,?(\.\d+)?[bcdeEfFgGnosxX%]?)(?=})/dgm,
            captures: {
                1: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
                2: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
            },
        },
    ]
};

export const pythonFstringTerminatorSingleTail: TokenPattern = {
    debugName: "pythonFstringTerminatorSingleTail",

    begin: /((?:=?)(?:![rsa])?)(:)(?=.*?{)/dg,
    beginCaptures: {
        1: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
        2: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
    },
    end: /(?=})|(?=\n)/g,
    patterns: [
        pythonFstringIllegalSingleBrace,
        pythonFstringSingleBrace,
        {
            debugName: "pythonFstringTerminatorSingleTail.patterns![2]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /([bcdeEfFgGnosxX%])(?=})/g,
        },
        {
            debugName: "pythonFstringTerminatorSingleTail.patterns![3]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\.\d+)/g,
        },
        {
            debugName: "pythonFstringTerminatorSingleTail.patterns![4]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(,)/g,
        },
        {
            debugName: "pythonFstringTerminatorSingleTail.patterns![5]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\d+)/g,
        },
        {
            debugName: "pythonFstringTerminatorSingleTail.patterns![6]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\#)/g,
        },
        {
            debugName: "pythonFstringTerminatorSingleTail.patterns![7]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /([-+ ])/g,
        },
        {
            debugName: "pythonFstringTerminatorSingleTail.patterns![8]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /([<>=^])/gm,
        },
        {
            debugName: "pythonFstringTerminatorSingleTail.patterns![9]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\w)/g,
        },
    ]
};

export const pythonFstringFnormQuotedMultiLine: TokenPattern = {
    debugName: "pythonFstringFnormQuotedMultiLine",

    token: MetaTokenType.Fstring, /*meta.fstring.python*/
    begin: /(\b[fF])([bBuU])?('''|""")/dg,
    beginCaptures: {
        1: { token: LiteralTokenType.String, /*string.interpolated.python string.quoted.multi.python storage.type.string.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.prefix.python*/ },
        3: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python string.interpolated.python string.quoted.multi.python*/ },
    },
    end: /(\3)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python string.interpolated.python string.quoted.multi.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonFstringGuts,
        pythonFstringIllegalMultiBrace,
    ]
};

export const pythonFstringNormfQuotedMultiLine: TokenPattern = {
    debugName: "pythonFstringNormfQuotedMultiLine",

    token: MetaTokenType.Fstring, /*meta.fstring.python*/
    begin: /(\b[bBuU])([fF])('''|""")/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.prefix.python*/ },
        2: { token: LiteralTokenType.String, /*string.interpolated.python string.quoted.multi.python storage.type.string.python*/ },
        3: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python string.quoted.multi.python*/ },
    },
    end: /(\3)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python string.interpolated.python string.quoted.multi.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonFstringGuts,
        pythonFstringIllegalMultiBrace,
    ]
};

export const pythonFstringRawQuotedMultiLine: TokenPattern = {
    debugName: "pythonFstringRawQuotedMultiLine",

    token: MetaTokenType.Fstring, /*meta.fstring.python*/
    begin: /(\b(?:[rR][fF]|[fF][rR]))('''|""")/dg,
    beginCaptures: {
        1: { token: LiteralTokenType.String, /*string.interpolated.python string.quoted.raw.multi.python storage.type.string.python*/ },
        2: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.python string.quoted.raw.multi.python*/ },
    },
    end: /(\2)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.python string.interpolated.python string.quoted.raw.multi.python*/ },
        2: { token: MetaTokenType.Invalid, /*invalid.illegal.newline.python*/ },
    },
    patterns: [
        pythonFstringRawGuts,
        pythonFstringIllegalMultiBrace,
    ]
};

export const pythonFstringMultiCore: TokenPattern = {
    debugName: "pythonFstringMultiCore",

    token: LiteralTokenType.String, /*string.interpolated.python string.quoted.multi.python*/
    match: /(.+?)(($\n?)|(?=[\\\}\{]|'''|"""))|\n/gm,
};

export const pythonFstringRawMultiCore: TokenPattern = {
    debugName: "pythonFstringRawMultiCore",

    token: LiteralTokenType.String, /*string.interpolated.python string.quoted.raw.multi.python*/
    match: /(.+?)(($\n?)|(?=[\\\}\{]|'''|"""))|\n/gm,
};

export const pythonFstringMultiBrace: TokenPattern = {
    debugName: "pythonFstringMultiBrace",

    // value interpolation using { ... }
    begin: /(\{)/dg,
    beginCaptures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
    },
    end: /(\})/dg,
    endCaptures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.python*/ },
    },
    patterns: [pythonFExpression]
};

export const pythonFstringTerminatorMulti: TokenPattern = {
    patterns: [
        {
            debugName: "pythonFstringTerminatorMulti.patterns![0]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(=(![rsa])?)(?=})/g,
        },
        {
            debugName: "pythonFstringTerminatorMulti.patterns![1]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(=?![rsa])(?=})/g,
        },
        {
            debugName: "pythonFstringTerminatorMulti.patterns![2]",

            match: /((?:=?)(?:![rsa])?)(:\w?[<>=^]?[-+ ]?\#?\d*,?(\.\d+)?[bcdeEfFgGnosxX%]?)(?=})/dgm,
            captures: {
                1: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
                2: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
            },
        },
    ]
};

export const pythonFstringTerminatorMultiTail: TokenPattern = {
    debugName: "pythonFstringTerminatorMultiTail",

    begin: /((?:=?)(?:![rsa])?)(:)(?=.*?{)/dg,
    beginCaptures: {
        1: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
        2: { token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/ },
    },
    end: /(?=})/g,
    patterns: [
        pythonFstringIllegalMultiBrace,
        pythonFstringMultiBrace,
        {
            debugName: "pythonFstringTerminatorMultiTail.patterns![2]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /([bcdeEfFgGnosxX%])(?=})/g,
        },
        {
            debugName: "pythonFstringTerminatorMultiTail.patterns![3]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\.\d+)/g,
        },
        {
            debugName: "pythonFstringTerminatorMultiTail.patterns![4]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(,)/g,
        },
        {
            debugName: "pythonFstringTerminatorMultiTail.patterns![5]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\d+)/g,
        },
        {
            debugName: "pythonFstringTerminatorMultiTail.patterns![6]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\#)/g,
        },
        {
            debugName: "pythonFstringTerminatorMultiTail.patterns![7]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /([-+ ])/g,
        },
        {
            debugName: "pythonFstringTerminatorMultiTail.patterns![8]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /([<>=^])/gm,
        },
        {
            debugName: "pythonFstringTerminatorMultiTail.patterns![9]",

            token: MetaTokenType.FormatStorageType, /*storage.type.format.python*/
            match: /(\w)/g,
        },
    ]
};

// Push pattern references that were not defined on include
pythonStatement.patterns!.push(pythonImport, pythonClassDeclaration, pythonFunctionDeclaration, pythonGenerator, pythonStatementKeyword, pythonAssignmentOperator, pythonDecorator, pythonDocstringStatement, pythonSemicolon);
pythonComments.patterns!.push(pythonCommentsBase);
pythonDocstringStatement.patterns!.push(pythonDocstring);
pythonDocstring.patterns![0].patterns!.push(pythonDocstringPrompt, pythonCodetags, pythonDocstringGutsUnicode);
pythonDocstring.patterns![1].patterns!.push(pythonStringConsumeEscape, pythonDocstringPrompt, pythonCodetags);
pythonDocstring.patterns![2].patterns!.push(pythonCodetags, pythonDocstringGutsUnicode);
pythonDocstring.patterns![3].patterns!.push(pythonStringConsumeEscape, pythonCodetags);
pythonDocstringGutsUnicode.patterns!.push(pythonEscapeSequenceUnicode, pythonEscapeSequence, pythonStringLineContinuation);
pythonExpressionBare.patterns!.push(pythonBackticks, pythonIllegalAnno, pythonLiteral, pythonRegexp, pythonString, pythonLambda, pythonGenerator, pythonIllegalOperator, pythonOperator, pythonCurlyBraces, pythonItemAccess, pythonList, pythonOddFunctionCall, pythonRoundBraces, pythonFunctionCall, pythonBuiltinFunctions, pythonBuiltinTypes, pythonBuiltinExceptions, pythonMagicNames, pythonSpecialNames, pythonIllegalNames, pythonSpecialVariables, pythonEllipsis, pythonPunctuation, pythonLineContinuation);
pythonExpressionBase.patterns!.push(pythonLineContinuation);
pythonExpression.patterns!.push(pythonMemberAccess);
pythonMemberAccess.patterns!.push(pythonFunctionCall, pythonMemberAccessBase, pythonMemberAccessAttribute);
pythonMemberAccessBase.patterns!.push(pythonMagicNames, pythonIllegalNames, pythonIllegalObjectName, pythonSpecialNames, pythonLineContinuation, pythonItemAccess);
pythonOddFunctionCall.patterns!.push(pythonFunctionArguments);
pythonLineContinuation.patterns![1].patterns!.push(pythonRegexp, pythonString);
pythonLiteral.patterns!.push(pythonNumber);
pythonNumber.patterns!.push(pythonNumberFloat, pythonNumberDec, pythonNumberHex, pythonNumberOct, pythonNumberBin, pythonNumberLong);
pythonRegexp.patterns!.push(pythonRegexpSingleThreeLine, pythonRegexpDoubleThreeLine, pythonRegexpSingleOneLine, pythonRegexpDoubleOneLine);
pythonString.patterns!.push(pythonStringQuotedMultiLine, pythonStringQuotedSingleLine, pythonStringBinQuotedMultiLine, pythonStringBinQuotedSingleLine, pythonStringRawQuotedMultiLine, pythonStringRawQuotedSingleLine, pythonStringRawBinQuotedMultiLine, pythonStringRawBinQuotedSingleLine, pythonFstringFnormQuotedMultiLine, pythonFstringFnormQuotedSingleLine, pythonFstringNormfQuotedMultiLine, pythonFstringNormfQuotedSingleLine, pythonFstringRawQuotedMultiLine, pythonFstringRawQuotedSingleLine);
pythonStringUnicodeGuts.patterns!.push(pythonEscapeSequenceUnicode, pythonStringEntity, pythonStringBraceFormatting);
pythonStringRawGuts.patterns!.push(pythonStringFormatting, pythonStringBraceFormatting);
pythonStringRawBinGuts.patterns!.push(pythonStringFormatting);
pythonStringEntity.patterns!.push(pythonEscapeSequence, pythonStringLineContinuation, pythonStringFormatting);
pythonFstringGuts.patterns!.push(pythonEscapeSequenceUnicode, pythonEscapeSequence, pythonStringLineContinuation, pythonFstringFormatting);
pythonFstringRawGuts.patterns!.push(pythonFstringFormatting);
pythonFstringIllegalSingleBrace.patterns!.push(pythonFstringTerminatorSingle, pythonFExpression);
pythonFstringFormatting.patterns!.push(pythonFstringFormattingBraces, pythonFstringFormattingSingeBrace);
pythonClassDeclaration.patterns![0].patterns!.push(pythonClassName, pythonClassInheritance);
pythonClassName.patterns!.push(pythonIllegalObjectName, pythonBuiltinPossibleCallables);
pythonClassInheritance.patterns!.push(pythonIllegalNames, pythonClassKwarg, pythonCallWrapperInheritance, pythonMemberAccessClass, pythonInheritanceIdentifier);
pythonMemberAccessClass.patterns!.push(pythonCallWrapperInheritance);
pythonLambda.patterns![2].patterns!.push(pythonLambdaNestedIncomplete, pythonIllegalNames, pythonBackticks, pythonIllegalAnno, pythonLambdaParameterWithDefault, pythonIllegalOperator);
pythonFunctionDeclaration.patterns!.push(pythonFunctionDefName, pythonParameters, pythonReturnAnnotation);
pythonFunctionDefName.patterns!.push(pythonIllegalObjectName, pythonBuiltinPossibleCallables);
pythonParameters.patterns!.push(pythonIllegalNames, pythonIllegalObjectName, pythonParameterSpecial, pythonLooseDefault, pythonAnnotatedParameter);
pythonItemAccess.patterns![0].patterns!.push(pythonItemName, pythonItemIndex);
pythonItemName.patterns!.push(pythonSpecialVariables, pythonBuiltinFunctions);
pythonDecorator.patterns!.push(pythonDecoratorName, pythonFunctionArguments);
pythonDecoratorName.patterns!.push(pythonBuiltinCallables, pythonIllegalObjectName);
pythonCallWrapperInheritance.patterns!.push(pythonInheritanceName, pythonFunctionArguments);
pythonInheritanceName.patterns!.push(pythonBuiltinPossibleCallables);
pythonFunctionCall.patterns!.push(pythonSpecialVariables, pythonFunctionName, pythonFunctionArguments);
pythonFunctionName.patterns!.push(pythonBuiltinPossibleCallables);
pythonFunctionArguments.patterns!.push(pythonIllegalNames);
pythonBuiltinCallables.patterns!.push(pythonIllegalNames, pythonIllegalObjectName, pythonBuiltinExceptions, pythonBuiltinFunctions, pythonBuiltinTypes);
pythonBuiltinPossibleCallables.patterns!.push(pythonMagicNames);
pythonRegexpBaseExpression.patterns!.push(pythonRegexpQuantifier, pythonRegexpBaseCommon);
pythonFregexpBaseExpression.patterns!.push(pythonFregexpQuantifier, pythonFstringFormattingBraces, pythonRegexpBaseCommon);
pythonRegexpBaseCommon.patterns!.push(pythonRegexpEscapeSequence);
pythonSingleOneRegexpExpression.patterns!.push(pythonSingleOneRegexpCharacterSet, pythonSingleOneRegexpComments, pythonSingleOneRegexpNamedGroup, pythonSingleOneRegexpLookahead, pythonSingleOneRegexpLookaheadNegative, pythonSingleOneRegexpLookbehind, pythonSingleOneRegexpLookbehindNegative, pythonSingleOneRegexpConditional, pythonSingleOneRegexpParenthesesNonCapturing, pythonSingleOneRegexpParentheses);
pythonSingleThreeRegexpExpression.patterns!.push(pythonSingleThreeRegexpCharacterSet, pythonSingleThreeRegexpComments, pythonSingleThreeRegexpNamedGroup, pythonSingleThreeRegexpLookahead, pythonSingleThreeRegexpLookaheadNegative, pythonSingleThreeRegexpLookbehind, pythonSingleThreeRegexpLookbehindNegative, pythonSingleThreeRegexpConditional, pythonSingleThreeRegexpParenthesesNonCapturing, pythonSingleThreeRegexpParentheses);
pythonDoubleOneRegexpExpression.patterns!.push(pythonDoubleOneRegexpCharacterSet, pythonDoubleOneRegexpComments, pythonDoubleOneRegexpNamedGroup, pythonDoubleOneRegexpLookahead, pythonDoubleOneRegexpLookaheadNegative, pythonDoubleOneRegexpLookbehind, pythonDoubleOneRegexpLookbehindNegative, pythonDoubleOneRegexpConditional, pythonDoubleOneRegexpParenthesesNonCapturing, pythonDoubleOneRegexpParentheses);
pythonDoubleThreeRegexpExpression.patterns!.push(pythonDoubleThreeRegexpCharacterSet, pythonDoubleThreeRegexpComments, pythonDoubleThreeRegexpNamedGroup, pythonDoubleThreeRegexpLookahead, pythonDoubleThreeRegexpLookaheadNegative, pythonDoubleThreeRegexpLookbehind, pythonDoubleThreeRegexpLookbehindNegative, pythonDoubleThreeRegexpConditional, pythonDoubleThreeRegexpParenthesesNonCapturing, pythonDoubleThreeRegexpParentheses);
pythonStringRawQuotedSingleLine.patterns!.push(pythonStringSingleBadBrace1FormattingRaw, pythonStringSingleBadBrace2FormattingRaw);
pythonStringQuotedSingleLine.patterns!.push(pythonStringSingleBadBrace1FormattingUnicode, pythonStringSingleBadBrace2FormattingUnicode);
pythonStringRawQuotedMultiLine.patterns!.push(pythonStringMultiBadBrace1FormattingRaw, pythonStringMultiBadBrace2FormattingRaw);
pythonStringQuotedMultiLine.patterns!.push(pythonStringMultiBadBrace1FormattingUnicode, pythonStringMultiBadBrace2FormattingUnicode);
pythonFstringFnormQuotedSingleLine.patterns!.push(pythonFstringSingleBrace, pythonFstringSingleCore);
pythonFstringNormfQuotedSingleLine.patterns!.push(pythonFstringSingleBrace, pythonFstringSingleCore);
pythonFstringRawQuotedSingleLine.patterns!.push(pythonFstringSingleBrace, pythonFstringRawSingleCore);
pythonFstringSingleBrace.patterns!.push(pythonFstringTerminatorSingle);
pythonFstringTerminatorSingle.patterns!.push(pythonFstringTerminatorSingleTail);
pythonFstringFnormQuotedMultiLine.patterns!.push(pythonFstringMultiBrace, pythonFstringMultiCore);
pythonFstringNormfQuotedMultiLine.patterns!.push(pythonFstringMultiBrace, pythonFstringMultiCore);
pythonFstringRawQuotedMultiLine.patterns!.push(pythonFstringMultiBrace, pythonFstringRawMultiCore);
pythonFstringMultiBrace.patterns!.push(pythonFstringTerminatorMulti);
pythonFstringTerminatorMulti.patterns!.push(pythonFstringTerminatorMultiTail);