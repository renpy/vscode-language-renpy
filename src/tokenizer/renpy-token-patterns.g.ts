/* eslint-disable no-useless-escape */
/* eslint-disable no-useless-backreference */
/* eslint-disable @typescript-eslint/no-non-null-assertion */

// THIS FILE HAS BEEN GENERATED BY THE `syntax-to-token-pattern.py` GENERATOR
// DO NOT EDIT THIS FILE DIRECTLY! INSTEAD RUN THE PYTHON SCRIPT.
// ANY MANUAL EDITS MADE TO THIS FILE WILL BE OVERWRITTEN. YOU HAVE BEEN WARNED.
// Last generated: 14/06/2023 16:51:20 (UTC+0)

import { MetaTokenType, CharacterTokenType, LiteralTokenType, EntityTokenType, KeywordTokenType, EscapedCharacterTokenType, OperatorTokenType } from "./renpy-tokens";
import { TokenPattern } from "./token-pattern-types";

export const statements: TokenPattern = {
    patterns: []
};

export const expressions: TokenPattern = {
    patterns: [
    ]
};

export const renpyOnlyExpressions: TokenPattern = {
    patterns: [
    ]
};

export const renpyPythonExpressions: TokenPattern = {
    patterns: [
        renpyOnlyExpressions]
};

export const invalidToken: TokenPattern = {
    debugName: "invalidToken",

    token: MetaTokenType.Invalid, /*invalid.unknown.token.renpy*/
    match: /.+/g,
};

export const newLine: TokenPattern = {
    debugName: "newLine",

    token: CharacterTokenType.NewLine, /*punctuation.new-line.renpy*/
    match: /\r\n|\r|\n/g,
};

export const whitespace: TokenPattern = {
    debugName: "whitespace",

    token: CharacterTokenType.Whitespace, /*punctuation.whitespace.renpy*/
    match: /[ \t]+/g,
};

export const fallbackCharacters: TokenPattern = {
    // NOTE: Having these patterns separated increases performance. Benchmark before making a change!
    patterns: [
        newLine,
        whitespace,
        {
            debugName: "fallbackCharacters.patterns![2]",

            token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.renpy*/
            match: /\(/g,
        },
        {
            debugName: "fallbackCharacters.patterns![3]",

            token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.renpy*/
            match: /\)/g,
        },
        {
            debugName: "fallbackCharacters.patterns![4]",

            token: CharacterTokenType.OpenBracket, /*punctuation.bracket.begin.renpy*/
            match: /{/g,
        },
        {
            debugName: "fallbackCharacters.patterns![5]",

            token: CharacterTokenType.CloseBracket, /*punctuation.bracket.end.renpy*/
            match: /}/g,
        },
        {
            debugName: "fallbackCharacters.patterns![6]",

            token: CharacterTokenType.OpenSquareBracket, /*punctuation.square-bracket.begin.renpy*/
            match: /\[/g,
        },
        {
            debugName: "fallbackCharacters.patterns![7]",

            token: CharacterTokenType.CloseSquareBracket, /*punctuation.square-bracket.end.renpy*/
            match: /\]/g,
        },
        {
            debugName: "fallbackCharacters.patterns![8]",

            token: CharacterTokenType.Period, /*punctuation.period.renpy*/
            match: /\./g,
        },
        {
            debugName: "fallbackCharacters.patterns![9]",

            token: CharacterTokenType.Colon, /*punctuation.colon.renpy*/
            match: /:/g,
        },
        {
            debugName: "fallbackCharacters.patterns![10]",

            token: CharacterTokenType.Semicolon, /*punctuation.semicolon.renpy*/
            match: /;/g,
        },
        {
            debugName: "fallbackCharacters.patterns![11]",

            token: CharacterTokenType.Comma, /*punctuation.comma.renpy*/
            match: /,/g,
        },
        {
            debugName: "fallbackCharacters.patterns![12]",

            token: CharacterTokenType.Hashtag, /*punctuation.hashtag.renpy*/
            match: /#/g,
        },
        {
            debugName: "fallbackCharacters.patterns![13]",

            token: CharacterTokenType.Quote, /*punctuation.quote.renpy*/
            match: /'/g,
        },
        {
            debugName: "fallbackCharacters.patterns![14]",

            token: CharacterTokenType.DoubleQuote, /*punctuation.double-quote.renpy*/
            match: /"/g,
        },
        {
            debugName: "fallbackCharacters.patterns![15]",

            token: CharacterTokenType.BackQuote, /*punctuation.back-quote.renpy*/
            match: /`/g,
        },
        {
            debugName: "fallbackCharacters.patterns![16]",

            token: CharacterTokenType.Backslash, /*punctuation.backslash.renpy*/
            match: /\\/g,
        },
        {
            debugName: "fallbackCharacters.patterns![17]",

            token: CharacterTokenType.ForwardSlash, /*punctuation.forward-slash.renpy*/
            match: /\//g,
        },
        {
            debugName: "fallbackCharacters.patterns![18]",

            token: CharacterTokenType.EqualsSymbol, /*punctuation.equals-symbol.renpy*/
            match: /=/g,
        },
        {
            debugName: "fallbackCharacters.patterns![19]",

            token: MetaTokenType.Invalid, /*debug.invalid.illegal.unmatched.renpy*/
            match: /\b\w+\b/g,
        },
        {
            debugName: "fallbackCharacters.patterns![20]",

            token: CharacterTokenType.Unknown, /*punctuation.unknown.renpy*/
            match: /./g,
        },
    ]
};

export const fallbackPatterns: TokenPattern = {
    patterns: [fallbackCharacters]
};

export const literal: TokenPattern = {
    patterns: [
        {
            debugName: "literal.patterns![0]",

            // Python literals
            token: MetaTokenType.ConstantLiteral, /*constant.language.renpy*/
            match: /\b(?<!\.)(True|False|None)\b/g,
        },
    ]
};

export const numFloat: TokenPattern = {
    debugName: "numFloat",

    match: /([\+\-])?(\d+\.?\d*|\.\d+)([eE][\-\+]?\d+)?/dg,
    captures: {
        1: { token: MetaTokenType.ArithmeticOperator, /*keyword.operator.arithmetic.renpy*/ },
        2: { token: LiteralTokenType.Float, /*constant.numeric.float.renpy*/ },
        3: { token: LiteralTokenType.Float, /*constant.numeric.float.renpy*/ },
    },
};

export const numInt: TokenPattern = {
    debugName: "numInt",

    token: LiteralTokenType.Integer, /*constant.numeric.integer.renpy*/
    match: /(?<![\w.])(?:[1-9]+|0+|0([0-9]+)(?![eE.]))\b/dg,
    captures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.integer.renpy*/ },
    },
};

export const parenthesisedPython: TokenPattern = {
    patterns: [
        {
            debugName: "parenthesisedPython.patterns![0]",

            begin: /\(/dg,
            beginCaptures: {
                0: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.python.renpy*/ },
            },
            end: /\)/dg,
            endCaptures: {
                0: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.python.renpy*/ },
            },
            patterns: [
            ]
        },
        {
            debugName: "parenthesisedPython.patterns![1]",

            begin: /\[/dg,
            beginCaptures: {
                1: { token: CharacterTokenType.OpenSquareBracket, /*punctuation.square-bracket.begin.python.renpy*/ },
            },
            end: /\]/dg,
            endCaptures: {
                1: { token: CharacterTokenType.CloseSquareBracket, /*punctuation.square-bracket.end.python.renpy*/ },
            },
            patterns: [
            ]
        },
        {
            debugName: "parenthesisedPython.patterns![2]",

            begin: /\{/dg,
            beginCaptures: {
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.bracket.begin.python.renpy*/ },
            },
            end: /\}/dg,
            endCaptures: {
                1: { token: CharacterTokenType.CloseBracket, /*punctuation.bracket.end.python.renpy*/ },
            },
            patterns: []
        }]
};

export const identifier: TokenPattern = {
    debugName: "identifier",

    token: EntityTokenType.VariableName, /*variable.name.renpy*/
    match: /\b[\p{XID_Start}_]\p{XID_Continue}*\b/g,
};

export const illegalIdentifiers: TokenPattern = {
    patterns: [
        {
            debugName: "illegalIdentifiers.patterns![0]",

            token: MetaTokenType.Invalid, /*invalid.illegal.identifier.renpy*/
            match: /\b(as|at|behind|call|expression|hide|if|in|image|init|jump|menu|onlayer|python|return|scene|show|with|while|zorder)\b/g,
        },
    ]
};

export const name: TokenPattern = {
    patterns: [
        illegalIdentifiers,
        identifier,
    ]
};

export const simpleExpression: TokenPattern = {
    debugName: "simpleExpression",

    token: MetaTokenType.SimpleExpression, /*meta.simple-expression.renpy*/
    begin: /[ \t]*/g,
    end: /(?!\G)(?![.\[\(\{])|$/gm,
    patterns: [
        literal,
        numFloat,
        identifier,
        parenthesisedPython,
        whitespace,
    ]
};

export const keywords: TokenPattern = {
    // Fallback patterns for unmatched keywords
    patterns: [
        {
            debugName: "keywords.patterns![0]",

            // Control flow keywords
            token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.renpy*/
            match: /\b(?<!\.)(?:pass|return|pause)\b/g,
        },
        {
            debugName: "keywords.patterns![1]",

            // Control flow keywords with block
            contentToken: MetaTokenType.PythonLine, /*meta.embedded.line.python*/
            begin: /\b(?<!\.)(?:(if|elif|else)|(for|while))\b/dg,
            beginCaptures: {
                1: { token: KeywordTokenType.If, /*keyword.control.conditional.renpy*/ },
                2: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.renpy*/ },
            },
            end: /:|$/dgm,
            endCaptures: {
                0: { token: CharacterTokenType.Colon, /*punctuation.section.block.begin.renpy*/ },
            },
            patterns: [expressions]
        },
        {
            debugName: "keywords.patterns![2]",

            // Python statement keywords
            token: KeywordTokenType.OtherPython, /*keyword.other.python.renpy*/
            match: /\b(?<!\.)(define|default|early|hide|in|init|python)\b/g,
        },
        {
            debugName: "keywords.patterns![3]",

            // Renpy keywords
            token: KeywordTokenType.Other, /*keyword.other.renpy*/
            match: /\b(?<!\.)(?:camera|image|label|layeredimage|menu|nvl[ \t]+clear|play|queue|scene|screen|show|transform|translate|voice(?:[ \t]+sustain)?|window|frame)\b/g,
        },
        {
            debugName: "keywords.patterns![4]",

            // [TODO: Should probably only be a keyword in the expression] Renpy sub expression keywords
            token: KeywordTokenType.Other, /*keyword.other.renpy*/
            match: /\b(?<!\.)(?:set|expression|at|with|from|style_prefix|spacing|textbutton)\b/g,
        },
        {
            debugName: "keywords.patterns![5]",

            // [TODO: Should probably only be a keyword in the expression] Renpy sub expression keywords
            token: KeywordTokenType.Other, /*keyword.control.flow.other.renpy*/
            match: /\b(?<!\.)(?:action)\b/g,
        },
    ]
};

export const comments: TokenPattern = {
    patterns: [
        {
            debugName: "comments.patterns![0]",

            token: MetaTokenType.Comment, /*comment.line.number-sign.renpy*/
            match: /(?<=^[ \t]*)(#[ \t]*(?:end)?region)\b.*$/dgm,
            captures: {
                1: { token: MetaTokenType.CommentRegionTag, /*punctuation.definition.tag.region*/ },
            },
        },
        {
            debugName: "comments.patterns![1]",

            token: MetaTokenType.Comment, /*comment.line.number-sign.renpy*/
            match: /(#)(.*)$/dgm,
            captures: {
                1: { token: CharacterTokenType.Hashtag, /*punctuation.definition.comment.renpy*/ },
                2: {
                    patterns: [
                        {
                            debugName: "comments.patterns![1].captures![2].patterns![0]",

                            // Code Tags
                            match: /(?:\b(NOTE|XXX|HACK|FIXME|BUG|TODO)\b)/dg,
                            captures: {
                                1: { token: MetaTokenType.CommentCodeTag, /*keyword.codetag.notation.renpy*/ },
                            },
                        },
                    ]
                },
            },
        },
    ]
};

export const escapedChar: TokenPattern = {
    debugName: "escapedChar",

    match: /(\\")|(\\')|(\\ )|(\\n)|(\\\\)|(\[\[)|({{)/dg,
    captures: {
        1: { token: EscapedCharacterTokenType.EscDoubleQuote, /*constant.character.escape.double-quote.python.renpy*/ },
        2: { token: EscapedCharacterTokenType.EscQuote, /*constant.character.escape.quote.python.renpy*/ },
        3: { token: EscapedCharacterTokenType.EscWhitespace, /*constant.character.escape.whitespace.python.renpy*/ },
        4: { token: EscapedCharacterTokenType.EscNewline, /*constant.character.escape.newline.python.renpy*/ },
        5: { token: EscapedCharacterTokenType.EscBackslash, /*constant.character.escape.backslash.python.renpy*/ },
        6: { token: EscapedCharacterTokenType.EscOpenBracket, /*constant.character.escape.open.bracket.python.renpy*/ },
        7: { token: EscapedCharacterTokenType.EscOpenSquareBracket, /*constant.character.escape.open.square-bracket.python.renpy*/ },
    },
};

export const constantPlaceholder: TokenPattern = {
    debugName: "constantPlaceholder",

    // Python value interpolation using [ ... ]
    token: MetaTokenType.ConstantCaps, /*constant.other.placeholder.tags.renpy*/
    match: /(\[)(.*?)(\])(?![^\[]*?\])/dg,
    captures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.renpy*/ },
        2: {
            token: MetaTokenType.PythonLine, /*meta.embedded.line.python*/
            patterns: [
            ]
        },
        3: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.renpy*/ },
    },
};

export const escapedUnicodeChar: TokenPattern = {
    debugName: "escapedUnicodeChar",

    match: /(\\U[0-9A-Fa-f]{8})|(\\u[0-9A-Fa-f]{4})|(\\N\{[a-zA-Z ]+\})/dg,
    captures: {
        1: { token: MetaTokenType.EscapeSequence, /*constant.character.unicode.16-bit-hex.python.renpy*/ },
        2: { token: MetaTokenType.EscapeSequence, /*constant.character.unicode.32-bit-hex.python.renpy*/ },
        3: { token: MetaTokenType.EscapeSequence, /*constant.character.unicode.name.python.renpy*/ },
    },
};

export const hexLiteral: TokenPattern = {
    patterns: [
        {
            debugName: "hexLiteral.patterns![0]",

            // rgb, rgba, rrggbb, rrggbbaa
            token: LiteralTokenType.Color, /*constant.color.renpy*/
            match: /#(?:[a-f0-9]{8}|[a-f0-9]{6}|[a-f0-9]{3,4})\b/gi,
        },
        {
            debugName: "hexLiteral.patterns![1]",

            token: MetaTokenType.Invalid, /*invalid.illegal.unexpected-number-of-hex-values.renpy*/
            match: /#[a-f0-9]+\b/gi,
        },
        {
            debugName: "hexLiteral.patterns![2]",

            match: /(#[a-f0-9]*)?(.+?)\b/dgi,
            captures: {
                1: { token: LiteralTokenType.Color, /*constant.color.renpy*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.character-not-allowed-here.renpy*/ },
            },
        },
    ]
};

export const stringsInterior: TokenPattern = {
    patterns: [
        newLine,
        escapedChar,
        constantPlaceholder,
    ]
};

export const stringTagsBroken: TokenPattern = {
    patterns: [
        {
            debugName: "stringTagsBroken.patterns![0]",

            // Valid tags without params (close required)
            contentToken: MetaTokenType.TaggedString, /*renpy.meta.${2:/downcase} meta.tagged.string.renpy*/
            begin: /({)\s*(u|i|b|s|plain|alt|noalt|art|rb|rt)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTagsBroken.patterns![1]",

            // Valid tags with numeric params (close required)
            contentToken: MetaTokenType.TaggedString, /*renpy.meta.${2:/downcase} meta.tagged.string.renpy*/
            begin: /({)\s*(alpha|cps|k)(=)(?:(\*)|(\-)|(\+))?(\d*(?:.\d+)?)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: OperatorTokenType.Multiply, /*keyword.operator.arithmetic.Multiply.renpy*/ },
                5: { token: OperatorTokenType.Minus, /*keyword.operator.arithmetic.Minus.renpy*/ },
                6: { token: OperatorTokenType.Plus, /*keyword.operator.arithmetic.Plus.renpy*/ },
                7: { token: MetaTokenType.ConstantNumeric, /*support.constant.property-value.renpy constant.numeric.renpy*/ },
                8: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTagsBroken.patterns![2]",

            // Valid tags with numeric params (close required)
            contentToken: MetaTokenType.TaggedString, /*renpy.meta.${2:/downcase} meta.tagged.string.renpy*/
            begin: /({)\s*(size)(=)([\-+]?)(\d+)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: MetaTokenType.ArithmeticOperator, /*keyword.operator.arithmetic.renpy*/ },
                5: { token: LiteralTokenType.Integer, /*support.constant.property-value.renpy constant.numeric.integer.renpy*/ },
                6: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTagsBroken.patterns![3]",

            // Valid tags with file param (close required)
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            begin: /({)\s*(font)(=)([\w.]+)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: LiteralTokenType.String, /*support.constant.property-value.renpy string.unquoted.renpy*/ },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTagsBroken.patterns![4]",

            // Color tag
            contentToken: MetaTokenType.TaggedString, /*renpy.meta.${2:/downcase}.${4:/downcase} meta.tagged.string.renpy*/
            begin: /({)\s*(color|outlinecolor)(=)(#?[a-zA-Z0-9]+)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { patterns: [hexLiteral] },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTagsBroken.patterns![5]",

            // a tag
            contentToken: MetaTokenType.TaggedString, /*renpy.meta.${2:/downcase} meta.tagged.string.renpy*/
            begin: /({)\s*(a)(=)(.*?)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: {
                    token: LiteralTokenType.String, /*support.constant.property-value.renpy string.unquoted.renpy*/
                    patterns: [
                    ]
                },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
    ]
};

export const stringTags: TokenPattern = {
    patterns: [
        {
            debugName: "stringTags.patterns![0]",

            // Valid tags without params (self-closing)
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            match: /({)\s*(nw|done|fast|p|w|clear)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![1]",

            // Valid tags with numeric params (self-closing)
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            match: /({)\s*(p|w)(=)(\+?)(\d*(?:.\d+)?)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: OperatorTokenType.Plus, /*keyword.operator.arithmetic.plus.renpy*/ },
                5: { token: LiteralTokenType.Float, /*support.constant.property-value.renpy constant.numeric.float.renpy*/ },
                6: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![2]",

            // Valid tags with numeric params (self-closing)
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            match: /({)\s*(v?space)(=)(\+?)(\d+)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: OperatorTokenType.Plus, /*keyword.operator.arithmetic.plus.renpy*/ },
                5: { token: LiteralTokenType.Integer, /*support.constant.property-value.renpy constant.numeric.integer.renpy*/ },
                6: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![3]",

            // Comment tag (self-closing)
            token: MetaTokenType.StringTag, /*meta.string.tag.comment.self-closing.renpy*/
            match: /({)\s*(#)\s*(.*?)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: CharacterTokenType.Hashtag, /*comment.line.number-sign.renpy punctuation.definition.comment.renpy*/ },
                3: { token: MetaTokenType.Comment, /*comment.line.number-sign.renpy*/ },
                4: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![4]",

            // Valid tags with file param
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            match: /({)\s*(image)(=)([\w.]+)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: LiteralTokenType.String, /*support.constant.property-value.renpy string.unquoted.renpy*/ },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![5]",

            // Valid tags without params (close required)
            match: /({)\s*(u|i|b|s|plain|alt|noalt|art|rb|rt)\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![6]",

            // Valid tags with numeric params (close required)
            match: /({)\s*(alpha|cps|k)(=)(?:(\*)|(\-)|(\+))?(\d*(?:.\d+)?)\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: OperatorTokenType.Multiply, /*keyword.operator.arithmetic.Multiply.renpy*/ },
                5: { token: OperatorTokenType.Minus, /*keyword.operator.arithmetic.Minus.renpy*/ },
                6: { token: OperatorTokenType.Plus, /*keyword.operator.arithmetic.Plus.renpy*/ },
                7: { token: MetaTokenType.ConstantNumeric, /*support.constant.property-value.renpy constant.numeric.renpy*/ },
                8: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![7]",

            // Valid tags with numeric params (close required)
            match: /({)\s*(size)(=)([\-+]?)(\d+)\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: MetaTokenType.ArithmeticOperator, /*keyword.operator.arithmetic.renpy*/ },
                5: { token: LiteralTokenType.Integer, /*support.constant.property-value.renpy constant.numeric.integer.renpy*/ },
                6: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![8]",

            // Valid tags with file param (close required)
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            match: /({)\s*(font)(=)([\w.]+)\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: LiteralTokenType.String, /*support.constant.property-value.renpy string.unquoted.renpy*/ },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![9]",

            // Color tag
            match: /({)\s*(color|outlinecolor)(=)(#?[a-zA-Z0-9]+)\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { patterns: [hexLiteral] },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![10]",

            // a tag
            match: /({)\s*(a)(=)(.*?)\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: {
                    token: LiteralTokenType.String, /*support.constant.property-value.renpy string.unquoted.renpy*/
                    patterns: [
                    ]
                },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![11]",

            // Unknown tag (Single line support only cus \R does not work) (Since we don't know if a tag is self closing, we can't assume that an end pattern exists)
            match: /({)[ \t]*(\w+)\b(?:(=)(.*?))?\s*(})((?:.|\R)+?)\s*({\/)\s*(\2)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*meta.string.tag.${2:/downcase}.start.renpy punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*meta.string.tag.${2:/downcase}.start.renpy renpy.meta.u entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*meta.string.tag.${2:/downcase}.start.renpy punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: MetaTokenType.ConstantCaps, /*meta.string.tag.${2:/downcase}.start.renpy constant.other.placeholder.tags.renpy*/ },
                5: { token: CharacterTokenType.CloseBracket, /*meta.string.tag.${2:/downcase}.start.renpy punctuation.definition.tag.end.renpy*/ },
                6: { token: MetaTokenType.TaggedString, /*renpy.meta.string.tag.custom.${2:/downcase } meta.tagged.string.renpy*/
                    patterns: [stringsInterior]
                },
                7: { token: CharacterTokenType.OpenBracket, /*meta.string.tag.${2:/downcase}.end.renpy punctuation.definition.tag.begin.renpy*/ },
                8: { token: EntityTokenType.TagName, /*meta.string.tag.${2:/downcase}.end.renpy renpy.meta.u entity.name.tag.${2:/downcase}.renpy*/ },
                9: { token: CharacterTokenType.CloseBracket, /*meta.string.tag.${2:/downcase}.end.renpy punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![12]",

            // Unknown tag start
            match: /({)\s*(\w*)(?:(=)(.*?))?\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: {
                    token: MetaTokenType.ConstantCaps, /*support.constant.property-value.renpy constant.other.placeholder.tags.renpy*/
                    patterns: [
                    ]
                },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![13]",

            // Unknown tag end
            match: /({\/)\s*(\w*?)\b\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
    ]
};

export const strings: TokenPattern = {
    debugName: "strings",

    token: LiteralTokenType.String, /*string.quoted.renpy*/
    begin: /"""|"|'''|'|```|`/dg,
    beginCaptures: {
        0: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.renpy*/ },
    },
    end: /(?<![^\\]\\)(((?<=\0)\0)|\0)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.renpy*/ },
        2: { token: MetaTokenType.EmptyString, /*meta.empty-string.renpy*/ },
    },
    patterns: [stringsInterior]
};

export const pythonStatements: TokenPattern = {
    patterns: [
        {
            debugName: "pythonStatements.patterns![0]",

            match: /^([ \t]*)(init)[ \t]+(offset)[ \t]*(=)[ \t]*(-)?([^#]*?)$/dgm,
            captures: {
                1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.renpy*/ },
                2: { token: KeywordTokenType.Init, /*keyword.init.renpy*/ },
                3: { token: KeywordTokenType.Offset, /*keyword.offset.renpy*/ },
                4: { token: OperatorTokenType.Assignment, /*keyword.operator.assignment.renpy*/ },
                5: { token: OperatorTokenType.Minus, /*keyword.operator.arithmetic.minus.renpy*/ },
                6: {
                    patterns: [
                        numInt,
                        invalidToken,
                    ]
                },
            },
        },
        {
            debugName: "pythonStatements.patterns![1]",

            // Renpy python block
            contentToken: MetaTokenType.PythonBlock, /*meta.embedded.block.python*/
            begin: /^([ \t]+)?(?:(init)(?:[ \t]+(-)?(\d+))?[ \t]+)?(python)[ \t]*(.*)?(:)/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.embedded.leading.renpy*/ },
                2: { token: KeywordTokenType.Init, /*keyword.init.renpy*/ },
                3: { token: OperatorTokenType.Minus, /*keyword.operator.arithmetic.minus.renpy*/ },
                4: { token: LiteralTokenType.Integer, /*constant.numeric.integer.renpy*/ },
                5: { token: KeywordTokenType.Python, /*keyword.python.renpy*/ },
                6: {
                    token: MetaTokenType.Arguments, /*meta.python.block.arguments.renpy*/
                    patterns: [
                        {
                            debugName: "pythonStatements.patterns![1].beginCaptures![6].patterns![0]",

                            // in statement
                            match: /(?:\s*(in)\s*([a-zA-Z_]\w*)\b)/dg,
                            captures: {
                                1: { token: KeywordTokenType.In, /*keyword.control.flow.in.renpy*/ },
                                2: { token: EntityTokenType.NamespaceName, /*entity.name.namespace*/ },
                            },
                        },
                        {
                            debugName: "pythonStatements.patterns![1].beginCaptures![6].patterns![1]",

                            // keywords
                            match: /\b(hide)|(early)|(in)\b/dg,
                            captures: {
                                1: { token: KeywordTokenType.Hide, /*keyword.hide.renpy*/ },
                                2: { token: KeywordTokenType.Early, /*keyword.early.renpy*/ },
                                3: { token: KeywordTokenType.In, /*keyword.control.flow.in.renpy*/ },
                            },
                        },
                    ]
                },
                7: { token: CharacterTokenType.Colon, /*punctuation.section.python.begin.renpy*/ },
            },
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: []
        }]
};

export const define: TokenPattern = {
    debugName: "define",

    // Match begin and end of python one line statements
    begin: /(?<=^[ \t]*)(define)(?=[ \t])/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Define, /*keyword.define.renpy*/ },
    },
    end: /$/gm,
    patterns: [
        {
            debugName: "define.patterns![0]",

            // Type the first name as a variable (Probably not needed, but python doesn't seem to catch it)
            token: EntityTokenType.VariableName, /*variable.other.renpy*/
            match: /(?<!\.)\b([a-zA-Z_]\w*)(?=\s=\s)/g,
        },
        numInt,
        strings,
        fallbackCharacters,
    ]
};

export const defaultStatement: TokenPattern = {
    debugName: "defaultStatement",

    // Match begin and end of python one line statements
    begin: /(?<=^[ \t]*)(default)(?=[ \t])/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Default, /*keyword.default.renpy*/ },
    },
    end: /$/gm,
    patterns: [
        {
            debugName: "defaultStatement.patterns![0]",

            // Type the first name as a variable (Probably not needed, but python doesn't seem to catch it)
            token: EntityTokenType.VariableName, /*variable.other.renpy*/
            match: /(?<!\.)\b([a-zA-Z_]\w*)(?=\s=\s)/g,
        },
        strings,
        whitespace,
    ]
};

export const oneLinePython: TokenPattern = {
    debugName: "oneLinePython",

    // Match begin and end of python one line statements
    begin: /(?<=^[ \t]*)(\$)(?=[ \t])/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.DollarSign, /*keyword.dollar.sign.renpy*/ },
    },
    end: /$/gm,
    patterns: [
        {
            debugName: "oneLinePython.patterns![0]",

            // Type the first name as a variable (Probably not needed, but python doesn't seem to catch it)
            token: EntityTokenType.VariableName, /*variable.other.renpy*/
            match: /(?<!\.)\b([a-zA-Z_]\w*)(?=\s=\s)/g,
        },
        strings,
        whitespace,
    ]
};

export const sayStatements: TokenPattern = {
    patterns: [
        {
            debugName: "sayStatements.patterns![0]",

            token: MetaTokenType.SayStatement, /*meta.say.statement.renpy*/
            contentToken: LiteralTokenType.String, /*renpy.meta.say.$1 string.quoted.renpy*/
            begin: /(?<=^[ \t]+)(?:([a-zA-Z_]\w*)\b|"([a-zA-Z_]\w*)\b")((?:[ \t]+(?:@|\w+))*)?[ \t]*("""|"|'''|'|```|`)/dgm,
            beginCaptures: {
                1: {
                    token: EntityTokenType.VariableName, /*renpy.meta.character.$1 variable.other.renpy*/
                    patterns: [
                        {
                            debugName: "sayStatements.patterns![0].beginCaptures![1].patterns![0]",

                            token: KeywordTokenType.Extend, /*keyword.extend.renpy*/
                            match: /extend/g,
                        },
                        {
                            debugName: "sayStatements.patterns![0].beginCaptures![1].patterns![1]",

                            token: KeywordTokenType.Voice, /*keyword.voice.renpy*/
                            match: /voice/g,
                        },
                        {
                            debugName: "sayStatements.patterns![0].beginCaptures![1].patterns![2]",

                            // Match special characters
                            token: EntityTokenType.VariableName, /*variable.other.constant.renpy*/
                            match: /adv|nvl|narrator|name_only|centered|vcentered/g,
                        },
                    ]
                },
                2: { token: MetaTokenType.CharacterNameString, /*meta.string.character.$2.renpy*/ },
                3: {
                    token: MetaTokenType.Arguments, /*meta.arguments.renpy*/
                    patterns: [
                        {
                            debugName: "sayStatements.patterns![0].beginCaptures![3].patterns![0]",

                            token: KeywordTokenType.At, /*keyword.at.renpy*/
                            match: /@/g,
                        },
                    ]
                },
                4: { token: MetaTokenType.StringBegin, /*string.quoted.renpy punctuation.definition.string.begin.renpy*/ },
            },
            end: /(?<![^\\]\\)(((?<=\4)\4)|\4)[ \t]*(\(.*?\)(?![^\(]*?\)))?/dg,
            endCaptures: {
                1: { token: MetaTokenType.StringEnd, /*string.quoted.renpy punctuation.definition.string.end.renpy*/ },
                2: { token: MetaTokenType.EmptyString, /*meta.empty-string.renpy*/ },
                3: {
                    patterns: [
                    ]
                },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "sayStatements.patterns![1]",

            token: MetaTokenType.SayNarrator, /*meta.say.narrator.renpy*/
            contentToken: LiteralTokenType.String, /*string.quoted.narrator.renpy*/
            begin: /(?<=^[ \t]+)("""|"|'''|'|```|`)/dgm,
            beginCaptures: {
                1: { token: MetaTokenType.StringBegin, /*string.quoted.renpy punctuation.definition.string.begin.renpy*/ },
            },
            end: /(?<![^\\]\\)(((?<=\1)\1)|\1)[ \t]*(\(.*?\)(?![^\(]*?\)))?/dg,
            endCaptures: {
                1: { token: MetaTokenType.StringEnd, /*string.quoted.renpy punctuation.definition.string.end.renpy*/ },
                2: { token: MetaTokenType.EmptyString, /*meta.empty-string.renpy*/ },
                3: {
                    patterns: [
                    ]
                },
            },
            patterns: [stringsInterior]
        },
    ]
};

export const pause: TokenPattern = {
    debugName: "pause",

    match: /(?<=^[ \t]+)(pause)\b(.+)?/dgm,
    captures: {
        1: { token: KeywordTokenType.Pause, /*keyword.control.flow.pause.renpy*/ },
        2: {
            token: MetaTokenType.PauseParameters, /*meta.pause.parameters.renpy*/
            patterns: [simpleExpression]
        },
    },
};

export const conditionals: TokenPattern = {
    debugName: "conditionals",

    match: /(?<=^[ \t]+)(if|elif|else)\b(.*?)(:)/dgm,
    captures: {
        1: { token: KeywordTokenType.If, /*keyword.control.conditional.renpy*/ },
        2: { patterns: [simpleExpression] },
        3: { token: CharacterTokenType.Colon, /*punctuation.section.condition.begin.renpy*/ },
    },
};

export const atStatement: TokenPattern = {
    debugName: "atStatement",

    token: MetaTokenType.AtStatement, /*meta.at.statement.renpy*/
    match: /\b(?!\.)(at)\b(.+)?/dg,
    captures: {
        1: { token: KeywordTokenType.At, /*keyword.control.flow.at.renpy*/ },
        2: {
            token: MetaTokenType.AtParameters, /*meta.at.parameters.renpy*/
            patterns: [simpleExpression]
        },
    },
};

export const asStatement: TokenPattern = {
    debugName: "asStatement",

    token: MetaTokenType.AsStatement, /*meta.as.statement.renpy*/
    match: /\b(?!\.)(as)\b[ \t]*(.+)?/dg,
    captures: {
        1: { token: KeywordTokenType.As, /*keyword.control.flow.as.renpy*/ },
        2: {
            token: MetaTokenType.AsParameters, /*meta.as.parameters.renpy*/
            patterns: [simpleExpression]
        },
    },
};

export const withStatement: TokenPattern = {
    debugName: "withStatement",

    token: MetaTokenType.WithStatement, /*meta.with.statement.renpy*/
    match: /\b(?!\.)(with)\b(.+)?/dg,
    captures: {
        1: { token: KeywordTokenType.With, /*keyword.control.flow.with.renpy*/ },
        2: {
            token: MetaTokenType.WithParameters, /*meta.with.parameters.renpy*/
            patterns: [simpleExpression]
        },
    },
};

export const behind: TokenPattern = {
    debugName: "behind",

    token: MetaTokenType.BehindStatement, /*meta.behind.statement.renpy*/
    match: /\b(?!\.)(behind)\b(.+)?/dg,
    captures: {
        1: { token: KeywordTokenType.Behind, /*keyword.control.flow.behind.renpy*/ },
        2: {
            token: MetaTokenType.BehindParameters, /*meta.behind.parameters.renpy*/
            patterns: [simpleExpression]
        },
    },
};

export const onlayer: TokenPattern = {
    debugName: "onlayer",

    token: MetaTokenType.OnlayerStatement, /*meta.onlayer.statement.renpy*/
    match: /\b(?!\.)(onlayer)\b(.+)?/dg,
    captures: {
        1: { token: KeywordTokenType.Onlayer, /*keyword.control.flow.onlayer.renpy*/ },
        2: {
            token: MetaTokenType.OnlayerParameters, /*meta.onlayer.parameters.renpy*/
            patterns: [simpleExpression]
        },
    },
};

export const zorder: TokenPattern = {
    debugName: "zorder",

    token: MetaTokenType.ZorderStatement, /*meta.zorder.statement.renpy*/
    match: /\b(?!\.)(zorder)\b(.+)?/dg,
    captures: {
        1: { token: KeywordTokenType.Zorder, /*keyword.control.flow.zorder.renpy*/ },
        2: {
            token: MetaTokenType.ZorderParameters, /*meta.zorder.parameters.renpy*/
            patterns: [simpleExpression]
        },
    },
};

export const image: TokenPattern = {
    patterns: [
        {
            debugName: "image.patterns![0]",

            token: MetaTokenType.ImageStatement, /*meta.image.statement.renpy*/
            contentToken: MetaTokenType.ATLBlock, /*meta.atl-block.renpy*/
            begin: /^([ \t]+)?(image)\b[ \t]*([a-zA-Z_0-9 ]*)(:)/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.renpy*/ },
                2: { token: KeywordTokenType.Image, /*keyword.image.renpy*/ },
                3: { token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/ },
                4: { token: CharacterTokenType.Colon, /*punctuation.section.atl.begin.renpy*/ },
            },
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: [
            ]
        },
        {
            debugName: "image.patterns![1]",

            token: MetaTokenType.ImageStatement, /*meta.image.statement.renpy*/
            begin: /(?<=^[ \t]*)(image)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Image, /*keyword.image.renpy*/ },
            },
            end: /(?=\b(at)\b|#|=)|$/gm,
            patterns: [
                strings,
                {
                    debugName: "image.patterns![1].patterns![1]",

                    token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/
                    match: /\b(?:[a-zA-Z_0-9]+)\b[ \t]*/g,
                },
            ]
        },
        atStatement,
        withStatement,
    ]
};

export const show: TokenPattern = {
    patterns: [
        {
            debugName: "show.patterns![0]",

            token: MetaTokenType.ShowStatement, /*meta.show.statement.renpy*/
            contentToken: MetaTokenType.ATLBlock, /*meta.atl-block.renpy*/
            begin: /^([ \t]+)?(show)\b[ \t]*([a-zA-Z_0-9 ]*)(:)/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.renpy*/ },
                2: { token: KeywordTokenType.Show, /*keyword.show.renpy*/ },
                3: { token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/ },
                4: { token: CharacterTokenType.Colon, /*punctuation.section.atl.begin.renpy*/ },
            },
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: [
            ]
        },
        {
            debugName: "show.patterns![1]",

            token: MetaTokenType.ShowStatement, /*meta.show.statement.renpy*/
            begin: /(?<=^[ \t]*)(show)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Show, /*keyword.show.renpy*/ },
            },
            end: /(?=\b(at|as|behind|onlayer|expression|with|zorder)\b|#)|$/gm,
            patterns: [
                strings,
                {
                    debugName: "show.patterns![1].patterns![1]",

                    token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/
                    match: /\b(?:[a-zA-Z_0-9]+)\b[ \t]*/g,
                },
            ]
        },
        atStatement,
        asStatement,
        withStatement,
        behind,
        onlayer,
        zorder,
    ]
};

export const scene: TokenPattern = {
    patterns: [
        {
            debugName: "scene.patterns![0]",

            token: MetaTokenType.SceneStatement, /*meta.scene.statement.renpy*/
            contentToken: MetaTokenType.ATLBlock, /*meta.atl-block.renpy*/
            begin: /^([ \t]+)?(scene)\b[ \t]*([a-zA-Z_0-9 ]*)(:)/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.renpy*/ },
                2: { token: KeywordTokenType.Scene, /*keyword.scene.renpy*/ },
                3: { token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/ },
                4: { token: CharacterTokenType.Colon, /*punctuation.section.atl.begin.renpy*/ },
            },
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: [
            ]
        },
        {
            debugName: "scene.patterns![1]",

            token: MetaTokenType.SceneStatement, /*meta.scene.statement.renpy*/
            begin: /(?<=^[ \t]*)(scene)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Scene, /*keyword.scene.renpy*/ },
            },
            end: /(?=\b(at|as|behind|onlayer|expression|with|zorder)\b|#)|$/gm,
            patterns: [
                strings,
                {
                    debugName: "scene.patterns![1].patterns![1]",

                    token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/
                    match: /\b(?:[a-zA-Z_0-9]+)\b[ \t]*/g,
                },
            ]
        },
        atStatement,
        asStatement,
        withStatement,
        behind,
        onlayer,
        zorder,
    ]
};

export const camera: TokenPattern = {
    patterns: [
        {
            debugName: "camera.patterns![0]",

            token: MetaTokenType.CameraStatement, /*meta.camera.statement.renpy*/
            contentToken: MetaTokenType.ATLBlock, /*meta.atl-block.renpy*/
            begin: /^([ \t]+)?(camera)\b[ \t]*(:)/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.renpy*/ },
                2: { token: KeywordTokenType.Camera, /*keyword.camera.renpy*/ },
                3: { token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/ },
                4: { token: CharacterTokenType.Colon, /*punctuation.section.atl.begin.renpy*/ },
            },
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: [
            ]
        },
        {
            debugName: "camera.patterns![1]",

            token: MetaTokenType.CameraStatement, /*meta.camera.statement.renpy*/
            begin: /(?<=^[ \t]*)(camera)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Camera, /*keyword.camera.renpy*/ },
            },
            end: /(?=\b(at|with)\b|#)|$/gm,
            patterns: [
                {
                    debugName: "camera.patterns![1].patterns![0]",

                    token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/
                    match: /\b(?:[a-zA-Z_0-9]+)\b[ \t]*/g,
                },
            ]
        },
        atStatement,
        withStatement,
    ]
};

export const styleProperty: TokenPattern = {
    patterns: [
        {
            debugName: "styleProperty.patterns![0]",

            token: EntityTokenType.TagName, /*support.constant.property-key.renpy entity.name.tag.css.style.renpy*/
            match: /\b(?<!\.)((?:selected_)?(?:hover_|idle_|insensitive_|activate_)?(?:activate_sound|adjust_spacing|aft_bar|aft_gutter|align|alt|altruby_style|anchor|antialias|area|background|bar_invert|bar_resizing|bar_vertical|base_bar|black_color|bold|bottom_bar|bottom_gutter|bottom_margin|bottom_padding|box_first_spacing|box_layout|box_reverse|box_spacing|box_wrap|box_wrap_spacing|caret|child|clipping|color|debug|drop_shadow|drop_shadow_color|enable_hover|first_indent|first_spacing|fit_first|focus_mask|focus_rect|font|fore_bar|fore_gutter|foreground|hinting|hover_sound|hyperlink_functions|italic|justify|kerning|key_events|keyboard_focus|language|layout|left_bar|left_gutter|left_margin|left_padding|line_leading|line_overlap_split|line_spacing|margin|maximum|min_width|minimum|minwidth|mipmap|modal|mouse|newline_indent|offset|order_reverse|outline_scaling|outlines|padding|pos|rest_indent|right_bar|right_gutter|right_margin|right_padding|ruby_style|size|size_group|slow_abortable|slow_cps|slow_cps_multiplier|slow_speed|sound|spacing|strikethrough|subpixel|subtitle_width|text_align|text_y_fudge|textalign|thumb|thumb_offset|thumb_shadow|time_policy|top_bar|top_gutter|top_margin|top_padding|underline|unscrollable|vertical|xalign|xanchor|xcenter|xfill|xfit|xmargin|xmaximum|xminimum|xoffset|xpadding|xpos|xsize|xspacing|xysize|yalign|yanchor|ycenter|yfill|yfit|ymargin|ymaximum|yminimum|yoffset|ypadding|ypos|ysize|yspacing))\b/g,
        },
        {
            debugName: "styleProperty.patterns![1]",

            // Any other tokens are invalid
            token: MetaTokenType.Invalid, /*invalid.illegal.style-property.name.renpy*/
            match: /.+/g,
        },
    ]
};

export const styleClause: TokenPattern = {
    patterns: [
        {
            debugName: "styleClause.patterns![0]",

            match: /\b(?<!\.)(is)\b[ \t]*(\w*)/dg,
            captures: {
                1: { token: OperatorTokenType.Is, /*keyword.operator.is.renpy*/ },
                2: { token: EntityTokenType.StyleName, /*entity.name.type.style.parent.renpy*/ },
            },
        },
        {
            debugName: "styleClause.patterns![1]",

            token: KeywordTokenType.Clear, /*keyword.clear.renpy*/
            match: /\b(?<!\.)clear\b/g,
        },
        {
            debugName: "styleClause.patterns![2]",

            match: /\b(?<!\.)(take)\b[ \t]*(\w*)/dg,
            captures: {
                1: { token: KeywordTokenType.Take, /*keyword.take.renpy*/ },
                2: { patterns: [name] },
            },
        },
        {
            debugName: "styleClause.patterns![3]",

            match: /\b(?<!\.)(del)\b[ \t]*(\w*)/dg,
            captures: {
                1: { token: KeywordTokenType.Del, /*keyword.del.renpy*/ },
                2: { patterns: [styleProperty] },
            },
        },
        {
            debugName: "styleClause.patterns![4]",

            begin: /\b(?<!\.)(variant)\b/dg,
            beginCaptures: {
                1: { token: KeywordTokenType.Variant, /*keyword.variant.renpy*/ },
            },
            end: /(?!\G)/g,
            patterns: [simpleExpression]
        },
        {
            debugName: "styleClause.patterns![5]",

            begin: /\b(?<!\.)((?:selected_)?(?:hover_|idle_|insensitive_|activate_)?(?:activate_sound|adjust_spacing|aft_bar|aft_gutter|align|alt|altruby_style|anchor|antialias|area|background|bar_invert|bar_resizing|bar_vertical|base_bar|black_color|bold|bottom_bar|bottom_gutter|bottom_margin|bottom_padding|box_first_spacing|box_layout|box_reverse|box_spacing|box_wrap|box_wrap_spacing|caret|child|clipping|color|debug|drop_shadow|drop_shadow_color|enable_hover|first_indent|first_spacing|fit_first|focus_mask|focus_rect|font|fore_bar|fore_gutter|foreground|hinting|hover_sound|hyperlink_functions|italic|justify|kerning|key_events|keyboard_focus|language|layout|left_bar|left_gutter|left_margin|left_padding|line_leading|line_overlap_split|line_spacing|margin|maximum|min_width|minimum|minwidth|mipmap|modal|mouse|newline_indent|offset|order_reverse|outline_scaling|outlines|padding|pos|rest_indent|right_bar|right_gutter|right_margin|right_padding|ruby_style|size|size_group|slow_abortable|slow_cps|slow_cps_multiplier|slow_speed|sound|spacing|strikethrough|subpixel|subtitle_width|text_align|text_y_fudge|textalign|thumb|thumb_offset|thumb_shadow|time_policy|top_bar|top_gutter|top_margin|top_padding|underline|unscrollable|vertical|xalign|xanchor|xcenter|xfill|xfit|xmargin|xmaximum|xminimum|xoffset|xpadding|xpos|xsize|xspacing|xysize|yalign|yanchor|ycenter|yfill|yfit|ymargin|ymaximum|yminimum|yoffset|ypadding|ypos|ysize|yspacing))\b/dg,
            beginCaptures: {
                1: { token: EntityTokenType.TagName, /*support.constant.property-key.renpy entity.name.tag.css.style.renpy*/ },
            },
            end: /(?!\G)/g,
            patterns: [simpleExpression]
        },
        fallbackPatterns,
    ]
};

export const style: TokenPattern = {
    patterns: [
        {
            debugName: "style.patterns![0]",

            token: MetaTokenType.StyleStatement, /*meta.style.statement.renpy*/
            contentToken: MetaTokenType.StyleBlock, /*meta.style-block.renpy*/
            begin: /^([ \t]+)?(style)\b[ \t]*(\w*)(.*)(:)/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.renpy*/ },
                2: { token: KeywordTokenType.Style, /*storage.type.style.renpy*/ },
                3: { token: EntityTokenType.StyleName, /*entity.name.type.style.renpy*/ },
                4: { patterns: [styleClause] },
                5: { token: CharacterTokenType.Colon, /*punctuation.section.style.begin.renpy*/ },
            },
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: [styleClause]
        },
        {
            debugName: "style.patterns![1]",

            // `style` is not considered an illegal identifier, so we need to make sure it's not followed by a `.`
            token: MetaTokenType.StyleStatement, /*meta.style.statement.renpy*/
            begin: /(?<=^[ \t]*)(style)\b(?!\.)[ \t]*(\w*)/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Style, /*storage.type.style.renpy*/ },
                2: { token: EntityTokenType.StyleName, /*entity.name.type.style.renpy*/ },
            },
            end: /$/gm,
            patterns: [styleClause]
        },
    ]
};

export const useOld: TokenPattern = {
    debugName: "useOld",

    match: /^\s*(use)\s+([a-zA-Z_][a-zA-Z_0-9]*)/dgm,
    captures: {
        1: { token: KeywordTokenType.Python, /*keyword.python.renpy*/ },
        2: { token: EntityTokenType.ClassName, /*entity.name.class.python.renpy.screen.renpy*/ },
    },
};

export const builtinLabels: TokenPattern = {
    debugName: "builtinLabels",

    token: EntityTokenType.FunctionName, /*support.function.builtin.renpy*/
    match: /(?<!\.)\b(?:start|quit|after_load|splashscreen|before_main_menu|main_menu|after_warp|hide_windows)\b/g,
};

export const labelName: TokenPattern = {
    patterns: [
        builtinLabels,
        {
            debugName: "labelName.patterns![2]",

            token: EntityTokenType.FunctionName, /*entity.name.function.label.renpy*/
            match: /\b(?:[a-zA-Z_]\w*)\b/g,
        },
    ]
};

export const labelCall: TokenPattern = {
    debugName: "labelCall",

    // Note: label params are only allowed at the end of the access expression
    token: MetaTokenType.LabelCall, /*meta.function-call.label.renpy*/
    begin: /\b(?=([a-zA-Z_]\w*)\s*(\())/g,
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.renpy*/ },
    },
    patterns: [labelName]
};

export const labelAccess: TokenPattern = {
    debugName: "labelAccess",

    // Note: Labels can't be nested twice in a row!
    token: MetaTokenType.LabelAccess, /*meta.member.access.label.renpy*/
    begin: /(\.)\s*(?!\.)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.Period, /*punctuation.separator.period.renpy*/ },
    },
    end: /(?<=\S)(?=\W)|(^|(?<=\s))(?=[^\\\w\s])|$/gm,
    patterns: [
        labelCall,
        labelName,
    ]
};

export const labelDefName: TokenPattern = {
    // Note: Labels can't be nested twice in a row!
    patterns: [
        builtinLabels,
        {
            debugName: "labelDefName.patterns![2]",

            match: /(?<=^|[ \t])(\b(?:[a-zA-Z_]\w*)\b)?(\.)?(\b(?:[a-zA-Z_]\w*)\b)/dgm,
            captures: {
                1: { token: EntityTokenType.FunctionName, /*entity.name.function.label.renpy*/ },
                2: { token: CharacterTokenType.Period, /*punctuation.separator.period.renpy*/ },
                3: { token: EntityTokenType.FunctionName, /*entity.name.function.label.renpy*/ },
            },
        },
    ]
};

export const label: TokenPattern = {
    debugName: "label",

    token: MetaTokenType.LabelStatement, /*meta.label.statement.renpy*/
    match: /(?<=^[ \t]*)(label)\b[ \t]*(.*?)(?:[ \t]*(hide))?(:)/dgm,
    captures: {
        1: { token: KeywordTokenType.Label, /*storage.type.function.label.renpy*/ },
        2: {
            patterns: [
                labelDefName,
                invalidToken,
            ]
        },
        3: { token: KeywordTokenType.Hide, /*keyword.hide.renpy*/ },
        4: { token: CharacterTokenType.Colon, /*punctuation.section.label.begin.renpy*/ },
    },
};

export const returnStatements: TokenPattern = {
    debugName: "returnStatements",

    begin: /(?<=^[ \t]+)(return)\b[ \t]*/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Return, /*keyword.control.flow.return.renpy*/ },
    },
    end: /$/gm,
    patterns: [renpyOnlyExpressions]
};

export const callJumpExpression: TokenPattern = {
    debugName: "callJumpExpression",

    begin: /\b(?<!\.)(expression)\b/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.Expression, /*keyword.expression.renpy*/ },
    },
    end: /(?=\b(?<!\.)(?:pass|from)\b)|$/gm,
    patterns: [renpyOnlyExpressions]
};

export const jump: TokenPattern = {
    debugName: "jump",

    token: MetaTokenType.JumpStatement, /*meta.jump.statement.renpy*/
    begin: /(?<=^[ \t]+)(jump)\b[ \t]*/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Jump, /*keyword.control.flow.jump.renpy*/ },
    },
    end: /(?=#)|$/dgm,
    endCaptures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.renpy*/ },
    },
    patterns: [
        callJumpExpression,
        {
            debugName: "jump.patterns![1]",

            // Label expression
            begin: /(?=[a-zA-Z_.])/g,
            end: /(?![a-zA-Z_.])(?![ \t]*\.[ \t]*)/g,
            patterns: [
                labelAccess,
                labelName,
            ]
        },
    ]
};

export const callPass: TokenPattern = {
    debugName: "callPass",

    begin: /\b(?<!\.)(pass)\b[ \t]*(?=\()/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.Pass, /*keyword.control.flow.pass.renpy*/ },
    },
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.renpy*/ },
    },
    patterns: [
    ]
};

export const callFrom: TokenPattern = {
    debugName: "callFrom",

    begin: /\b(?<!\.)(from)\b[ \t]*/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.From, /*keyword.control.flow.from.renpy*/ },
    },
    end: /(?=\W|$)/gm,
    patterns: [labelName]
};

export const call: TokenPattern = {
    debugName: "call",

    token: MetaTokenType.CallStatement, /*meta.call.statement.renpy*/
    begin: /(?<=^[ \t]+)(call)\b(?:[ \t]+(screen))?/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Call, /*keyword.control.flow.call.renpy*/ },
        2: { token: KeywordTokenType.Screen, /*keyword.screen.renpy*/ },
    },
    end: /(?=#)|$/dgm,
    endCaptures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.renpy*/ },
    },
    patterns: [
        callJumpExpression,
        callPass,
        {
            debugName: "call.patterns![2]",

            // Label expression
            begin: /(?=[a-zA-Z_.])/g,
            end: /(?![a-zA-Z_.])(?![ \t]*\.[ \t]*)/g,
            patterns: [
                labelCall,
                labelAccess,
                labelName,
            ]
        },
        callFrom,
    ]
};

export const menuOption: TokenPattern = {
    debugName: "menuOption",

    contentToken: MetaTokenType.MenuOptionBlock, /*meta.menu-option.block.renpy*/
    begin: /^([ \t]+)?((?:".*")|(?:'.*')|(?:""".*"""))[ \t]*(.+)?(:)/dgm,
    beginCaptures: {
        1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.menu-option.leading.renpy*/ },
        2: {
            token: MetaTokenType.MenuOption, /*meta.menu-option.renpy*/
            patterns: [strings]
        },
        3: {
            token: MetaTokenType.PythonLine, /*meta.embedded.line.python*/
            patterns: [
                {
                    debugName: "menuOption.beginCaptures![3].patterns![1]",

                    // if condition
                    match: /\b(if)[ \t]+(.+)?/dg,
                    captures: {
                        1: { token: KeywordTokenType.If, /*keyword.control.conditional.renpy*/ },
                        2: {
                            patterns: [
                            ]
                        },
                    },
                },
                {
                    debugName: "menuOption.beginCaptures![3].patterns![2]",

                    token: MetaTokenType.Invalid, /*invalid.illegal.unexpected-characters-in-menu-arguments.renpy*/
                    match: /[^ \t]+/g,
                },
            ]
        },
        4: { token: CharacterTokenType.Colon, /*punctuation.section.menu-option.begin.renpy*/ },
    },
    end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
    patterns: [
    ]
};

export const menuSet: TokenPattern = {
    debugName: "menuSet",

    match: /(?<=^[ \t]+)(set)[ \t]+(.+)?/dgm,
    captures: {
        1: { token: KeywordTokenType.Set, /*keyword.set.renpy*/ },
        2: {
            token: MetaTokenType.PythonLine, /*meta.embedded.line.python*/
            patterns: [
            ]
        },
    },
};

export const menu: TokenPattern = {
    debugName: "menu",

    token: MetaTokenType.MenuStatement, /*meta.menu.statement.renpy*/
    contentToken: MetaTokenType.MenuBlock, /*meta.menu.block.renpy*/
    begin: /^([ \t]+)?(menu)[ \t]*(.+)?(:)/dgm,
    beginCaptures: {
        1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.menu.leading.renpy*/ },
        2: { token: KeywordTokenType.Def, /*storage.type.function.renpy*/ },
        3: {
            patterns: [
                {
                    debugName: "menu.beginCaptures![3].patterns![0]",

                    // Menu name
                    token: EntityTokenType.FunctionName, /*entity.name.function.menu.renpy*/
                    match: /[a-zA-Z_.]\w*/g,
                },
            ]
        },
        4: { token: CharacterTokenType.Colon, /*punctuation.section.menu.begin.renpy*/ },
    },
    end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
    patterns: [
        comments,
        menuOption,
        sayStatements,
        menuSet,
        fallbackCharacters,
    ]
};

export const builtinAudioChannels: TokenPattern = {
    debugName: "builtinAudioChannels",

    token: MetaTokenType.BuiltinType, /*support.type.audio.channel.renpy*/
    match: /(?<!\.)\b(?:music|sound|voice|audio)\b/g,
};

export const audioChannel: TokenPattern = {
    patterns: [
        builtinAudioChannels,
        {
            debugName: "audioChannel.patterns![1]",

            token: EntityTokenType.AudioName, /*entity.name.type.audio.channel.renpy*/
            match: /.+/g,
        },
    ]
};

export const audioParams: TokenPattern = {
    patterns: [
        {
            debugName: "audioParams.patterns![0]",

            token: KeywordTokenType.OtherAudio, /*keyword.other.audio.renpy*/
            match: /\b(?<!\.)(?:fadeout|fadein|volume|loop|noloop)\b/g,
        },
    ]
};

export const play: TokenPattern = {
    patterns: [
        {
            debugName: "play.patterns![0]",

            token: MetaTokenType.PlayAudioStatement, /*meta.play.audio.statement.renpy*/
            begin: /(?<=^[ \t]*)(play)\b[ \t]+\b([a-zA-Z_0-9]*)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Play, /*keyword.play.renpy*/ },
                2: { patterns: [audioChannel] },
            },
            end: /(?=[ \t]*#)|$/gm,
            patterns: [
                strings,
                audioParams,
            ]
        },
    ]
};

export const queue: TokenPattern = {
    patterns: [
        {
            debugName: "queue.patterns![0]",

            token: MetaTokenType.QueueAudioStatement, /*meta.queue.audio.statement.renpy*/
            begin: /(?<=^[ \t]*)(queue)\b[ \t]+\b([a-zA-Z_0-9]*)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Queue, /*keyword.queue.renpy*/ },
                2: { patterns: [audioChannel] },
            },
            end: /(?=[ \t]*#)|$/gm,
            patterns: [
                strings,
                audioParams,
            ]
        },
    ]
};

export const stop: TokenPattern = {
    patterns: [
        {
            debugName: "stop.patterns![0]",

            token: MetaTokenType.StopAudioStatement, /*meta.stop.audio.statement.renpy*/
            begin: /(?<=^[ \t]*)(stop)\b[ \t]+\b([a-zA-Z_0-9]*)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Stop, /*keyword.stop.renpy*/ },
                2: { patterns: [audioChannel] },
            },
            end: /(?=[ \t]*#)|$/gm,
            patterns: [
                {
                    debugName: "stop.patterns![0].patterns![0]",

                    token: KeywordTokenType.Fadeout, /*keyword.fadeout.renpy*/
                    match: /\b(?<!\.)(?:fadeout)\b/g,
                },
            ]
        },
    ]
};

export const audio: TokenPattern = {
    patterns: [
        play,
        queue,
        stop,
    ]
};

export const renpyStatements: TokenPattern = {
    patterns: [
        label,
        menu,
        image,
        audio,
        pause,
        style,
        scene,
        camera,
        show,
        withStatement,
        useOld,
        returnStatements,
        jump,
        call,
    ]
};

export const basePatterns: TokenPattern = {
    patterns: [
        statements,
        expressions,
    ]
};

// Push pattern references that were not defined on include
statements.patterns!.push(renpyStatements, pythonStatements, conditionals, keywords, sayStatements);
expressions.patterns!.push(renpyPythonExpressions, fallbackCharacters);
renpyOnlyExpressions.patterns!.push(comments, strings, literal);
fallbackPatterns.patterns!.splice(0, 0, comments);
stringsInterior.patterns!.splice(2, 0, stringTags);
pythonStatements.patterns!.push(define, defaultStatement, oneLinePython);
menuOption.patterns!.push(basePatterns);