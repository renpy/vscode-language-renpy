/* eslint-disable no-useless-escape */
/* eslint-disable no-useless-backreference */
/* eslint-disable @typescript-eslint/no-non-null-assertion */

// THIS FILE HAS BEEN GENERATED BY THE `syntax-to-token-pattern.py` GENERATOR
// DO NOT EDIT THIS FILE DIRECTLY! INSTEAD RUN THE PYTHON SCRIPT.
// ANY MANUAL EDITS MADE TO THIS FILE WILL BE OVERWRITTEN. YOU HAVE BEEN WARNED.
// Last generated: 15/08/2024 21:19:25 (UTC+0)

import { MetaTokenType, CharacterTokenType, LiteralTokenType, EntityTokenType, KeywordTokenType, EscapedCharacterTokenType, OperatorTokenType } from "./renpy-tokens";
import { TokenPattern } from "./token-pattern-types";

export const statements: TokenPattern = {
    patterns: []
};

export const expressions: TokenPattern = {
    patterns: [
    ]
};

export const renpyOnlyExpressions: TokenPattern = {
    patterns: [
    ]
};

export const renpyPythonExpressions: TokenPattern = {
    patterns: [
        renpyOnlyExpressions]
};

export const invalidToken: TokenPattern = {
    debugName: "invalidToken",

    token: MetaTokenType.Invalid, /*invalid.unknown.token.renpy*/
    match: /\b\w+\b|.+?/g,
};

export const newLine: TokenPattern = {
    debugName: "newLine",

    token: CharacterTokenType.NewLine, /*punctuation.new-line.renpy*/
    match: /\r\n|\r|\n/g,
};

export const whitespace: TokenPattern = {
    debugName: "whitespace",

    token: CharacterTokenType.Whitespace, /*punctuation.whitespace.renpy*/
    match: /[ \t]+/g,
};

export const singleCharacters: TokenPattern = {
    // NOTE: Having these patterns separated increases performance. Benchmark before making a change!
    patterns: [
        newLine,
        whitespace,
        {
            debugName: "singleCharacters.patterns![2]",

            token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.renpy*/
            match: /\(/g,
        },
        {
            debugName: "singleCharacters.patterns![3]",

            token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.renpy*/
            match: /\)/g,
        },
        {
            debugName: "singleCharacters.patterns![4]",

            token: CharacterTokenType.OpenBracket, /*punctuation.bracket.begin.renpy*/
            match: /{/g,
        },
        {
            debugName: "singleCharacters.patterns![5]",

            token: CharacterTokenType.CloseBracket, /*punctuation.bracket.end.renpy*/
            match: /}/g,
        },
        {
            debugName: "singleCharacters.patterns![6]",

            token: CharacterTokenType.OpenSquareBracket, /*punctuation.square-bracket.begin.renpy*/
            match: /\[/g,
        },
        {
            debugName: "singleCharacters.patterns![7]",

            token: CharacterTokenType.CloseSquareBracket, /*punctuation.square-bracket.end.renpy*/
            match: /\]/g,
        },
        {
            debugName: "singleCharacters.patterns![8]",

            token: CharacterTokenType.Dot, /*punctuation.dot.renpy*/
            match: /\./g,
        },
        {
            debugName: "singleCharacters.patterns![9]",

            token: CharacterTokenType.Colon, /*punctuation.colon.renpy*/
            match: /:/g,
        },
        {
            debugName: "singleCharacters.patterns![10]",

            token: CharacterTokenType.Semicolon, /*punctuation.semicolon.renpy*/
            match: /;/g,
        },
        {
            debugName: "singleCharacters.patterns![11]",

            token: CharacterTokenType.Comma, /*punctuation.comma.renpy*/
            match: /,/g,
        },
        {
            debugName: "singleCharacters.patterns![12]",

            token: CharacterTokenType.Hashtag, /*punctuation.hashtag.renpy*/
            match: /#/g,
        },
        {
            debugName: "singleCharacters.patterns![13]",

            token: CharacterTokenType.Quote, /*punctuation.quote.renpy*/
            match: /'/g,
        },
        {
            debugName: "singleCharacters.patterns![14]",

            token: CharacterTokenType.DoubleQuote, /*punctuation.double-quote.renpy*/
            match: /"/g,
        },
        {
            debugName: "singleCharacters.patterns![15]",

            token: CharacterTokenType.BackQuote, /*punctuation.back-quote.renpy*/
            match: /`/g,
        },
        {
            debugName: "singleCharacters.patterns![16]",

            token: CharacterTokenType.Backslash, /*punctuation.backslash.renpy*/
            match: /\\/g,
        },
        {
            debugName: "singleCharacters.patterns![17]",

            token: CharacterTokenType.ForwardSlash, /*punctuation.forward-slash.renpy*/
            match: /\//g,
        },
        {
            debugName: "singleCharacters.patterns![18]",

            token: CharacterTokenType.EqualsSymbol, /*punctuation.equals-symbol.renpy*/
            match: /=/g,
        },
    ]
};

export const fallbackPatterns: TokenPattern = {
    patterns: [
        singleCharacters,
        {
            debugName: "fallbackPatterns.patterns![2]",

            token: MetaTokenType.Invalid, /*debug.invalid.illegal.unmatched.renpy*/
            match: /\b\w+\b/g,
        },
        {
            debugName: "fallbackPatterns.patterns![3]",

            token: CharacterTokenType.Unknown, /*punctuation.unknown.renpy*/
            match: /./g,
        },
    ]
};

export const fallbackPatternsWithError: TokenPattern = {
    patterns: [
        singleCharacters,
        invalidToken,
    ]
};

export const literal: TokenPattern = {
    patterns: [
        {
            debugName: "literal.patterns![0]",

            // Python literals
            token: MetaTokenType.ConstantLiteral, /*constant.language.renpy*/
            match: /\b(?<!\.)(True|False|None)\b/g,
        },
    ]
};

export const numFloat: TokenPattern = {
    debugName: "numFloat",

    match: /([\+\-])?(\d+\.?\d*|\.\d+)([eE][\-\+]?\d+)?/dg,
    captures: {
        1: { token: MetaTokenType.ArithmeticOperator, /*keyword.operator.arithmetic.renpy*/ },
        2: { token: LiteralTokenType.Float, /*constant.numeric.float.renpy*/ },
        3: { token: LiteralTokenType.Float, /*constant.numeric.float.renpy*/ },
    },
};

export const numInt: TokenPattern = {
    debugName: "numInt",

    token: LiteralTokenType.Integer, /*constant.numeric.integer.renpy*/
    match: /(?<![\w.])(?:[1-9]+|0+|0([0-9]+)(?![eE.]))\b/dg,
    captures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.integer.renpy*/ },
    },
};

export const parenthesizedPython: TokenPattern = {
    patterns: [
        {
            debugName: "parenthesizedPython.patterns![0]",

            begin: /\(/dg,
            beginCaptures: {
                0: { token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.python.renpy*/ },
            },
            end: /\)/dg,
            endCaptures: {
                0: { token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.python.renpy*/ },
            },
            patterns: [
            ]
        },
        {
            debugName: "parenthesizedPython.patterns![1]",

            begin: /\[/dg,
            beginCaptures: {
                0: { token: CharacterTokenType.OpenSquareBracket, /*punctuation.square-bracket.begin.python.renpy*/ },
            },
            end: /\]/dg,
            endCaptures: {
                0: { token: CharacterTokenType.CloseSquareBracket, /*punctuation.square-bracket.end.python.renpy*/ },
            },
            patterns: [
            ]
        },
        {
            debugName: "parenthesizedPython.patterns![2]",

            begin: /\{/dg,
            beginCaptures: {
                0: { token: CharacterTokenType.OpenBracket, /*punctuation.bracket.begin.python.renpy*/ },
            },
            end: /\}/dg,
            endCaptures: {
                0: { token: CharacterTokenType.CloseBracket, /*punctuation.bracket.end.python.renpy*/ },
            },
            patterns: []
        }]
};

export const identifier: TokenPattern = {
    debugName: "identifier",

    token: EntityTokenType.Identifier, /*variable.name.renpy*/
    match: /\b[\p{XID_Start}_]\p{XID_Continue}*\b/gu,
};

export const illegalIdentifiers: TokenPattern = {
    patterns: [
        {
            debugName: "illegalIdentifiers.patterns![0]",

            token: MetaTokenType.Invalid, /*invalid.illegal.identifier.renpy*/
            match: /\b(as|at|behind|call|expression|hide|if|in|image|init|jump|menu|onlayer|python|return|scene|show|with|while|zorder)\b/g,
        },
    ]
};

export const name: TokenPattern = {
    patterns: [
        illegalIdentifiers,
        identifier,
    ]
};

export const simpleExpression: TokenPattern = {
    debugName: "simpleExpression",

    token: MetaTokenType.SimpleExpression, /*meta.simple-expression.renpy*/
    begin: /[ \t]*/g,
    end: /(?!\G)(?![.\[\(\{])|$/gm,
    patterns: [
        literal,
        numFloat,
        identifier,
        parenthesizedPython,
        whitespace,
    ]
};

export const keywords: TokenPattern = {
    // Fallback patterns for unmatched keywords
    patterns: [
        {
            debugName: "keywords.patterns![0]",

            // Control flow keywords
            token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.renpy*/
            match: /\b(?<!\.)(?:pass|return|pause|if|elif|else|while|for)\b/g,
        },
        {
            debugName: "keywords.patterns![1]",

            // Python statement keywords
            token: KeywordTokenType.OtherPython, /*keyword.other.python.renpy*/
            match: /\b(?<!\.)(define|default|early|hide|in|init|python)\b/g,
        },
        {
            debugName: "keywords.patterns![2]",

            // Renpy keywords
            token: KeywordTokenType.Other, /*keyword.other.renpy*/
            match: /\b(?<!\.)(?:camera|image|label|layeredimage|menu|nvl[ \t]+clear|play|queue|scene|screen|show|transform|translate|voice(?:[ \t]+sustain)?)\b/g,
        },
        {
            debugName: "keywords.patterns![3]",

            // [TODO: Should probably only be a keyword in the expression] Renpy sub expression keywords
            token: KeywordTokenType.Other, /*keyword.other.renpy*/
            match: /\b(?<!\.)(?:set|expression|from|style_prefix|spacing|textbutton)\b/g,
        },
        {
            debugName: "keywords.patterns![4]",

            // [TODO: Should probably only be a keyword in the expression] Renpy sub expression keywords
            token: KeywordTokenType.Other, /*keyword.control.flow.other.renpy*/
            match: /\b(?<!\.)(?:action|at|with)\b/g,
        },
    ]
};

export const regionComment: TokenPattern = {
    debugName: "regionComment",

    token: MetaTokenType.Comment, /*comment.line.number-sign.renpy*/
    match: /(?<=^[ \t]*)(#[ \t]*(?:end)?region)\b.*$/dgm,
    captures: {
        1: { token: MetaTokenType.CommentRegionTag, /*punctuation.definition.tag.region.renpy*/ },
    },
};

export const codetags: TokenPattern = {
    debugName: "codetags",

    match: /(?:\b(NOTE|XXX|HACK|FIXME|BUG|TODO)\b)/dg,
    captures: {
        1: { token: MetaTokenType.CommentCodeTag, /*keyword.codetag.notation.renpy*/ },
    },
};

export const commentsBase: TokenPattern = {
    debugName: "commentsBase",

    token: MetaTokenType.Comment, /*comment.line.number-sign.renpy*/
    begin: /#/dg,
    beginCaptures: {
        0: { token: CharacterTokenType.Hashtag, /*punctuation.definition.comment.renpy*/ },
    },
    end: /$/gm,
    patterns: [codetags]
};

export const comments: TokenPattern = {
    patterns: [
        regionComment,
        commentsBase,
    ]
};

export const escapedChar: TokenPattern = {
    debugName: "escapedChar",

    match: /(\\")|(\\')|(\\ )|(\\n)|(\\\\)|(\[\[)|({{)|(%%)/dg,
    captures: {
        1: { token: EscapedCharacterTokenType.EscDoubleQuote, /*constant.character.escape.double-quote.python.renpy*/ },
        2: { token: EscapedCharacterTokenType.EscQuote, /*constant.character.escape.quote.python.renpy*/ },
        3: { token: EscapedCharacterTokenType.EscWhitespace, /*constant.character.escape.whitespace.python.renpy*/ },
        4: { token: EscapedCharacterTokenType.EscNewline, /*constant.character.escape.newline.python.renpy*/ },
        5: { token: EscapedCharacterTokenType.EscBackslash, /*constant.character.escape.backslash.python.renpy*/ },
        6: { token: EscapedCharacterTokenType.EscOpenBracket, /*constant.character.escape.open.bracket.python.renpy*/ },
        7: { token: EscapedCharacterTokenType.EscOpenSquareBracket, /*constant.character.escape.open.square-bracket.python.renpy*/ },
        8: { token: EscapedCharacterTokenType.EscPercent, /*constant.character.escape.percent.python.renpy*/ },
    },
};

export const constantPlaceholder: TokenPattern = {
    debugName: "constantPlaceholder",

    // Python value interpolation using [ ... ]
    token: MetaTokenType.ConstantCaps, /*constant.other.placeholder.tags.renpy*/
    contentToken: MetaTokenType.PythonLine, /*meta.embedded.line.python*/
    begin: /(?<=[^\[])\[/dg,
    beginCaptures: {
        0: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.begin.renpy*/ },
    },
    end: /\]/dg,
    endCaptures: {
        0: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.end.renpy*/ },
    },
    patterns: [
        {
            debugName: "constantPlaceholder.patterns![0]",

            token: MetaTokenType.InterpolateFlags, /*meta.interpolate.flags.renpy*/
            match: /(!)([rstiqulc]+)/dg,
            captures: {
                1: { token: CharacterTokenType.ExclamationMark, /*punctuation.definition.interpolate.flags.begin.renpy*/ },
                2: { token: MetaTokenType.ModifierFlagStorageType, /*storage.modifier.flag.renpy*/ },
            },
        },
    ]
};

export const escapedUnicodeChar: TokenPattern = {
    debugName: "escapedUnicodeChar",

    match: /(\\U[0-9A-Fa-f]{8})|(\\u[0-9A-Fa-f]{4})|(\\N\{[a-zA-Z ]+\})/dg,
    captures: {
        1: { token: MetaTokenType.EscapeSequence, /*constant.character.unicode.16-bit-hex.python.renpy*/ },
        2: { token: MetaTokenType.EscapeSequence, /*constant.character.unicode.32-bit-hex.python.renpy*/ },
        3: { token: MetaTokenType.EscapeSequence, /*constant.character.unicode.name.python.renpy*/ },
    },
};

export const hexLiteral: TokenPattern = {
    patterns: [
        {
            debugName: "hexLiteral.patterns![0]",

            // rgb, rgba, rrggbb, rrggbbaa
            token: LiteralTokenType.Color, /*constant.color.renpy*/
            match: /#(?:[a-f0-9]{8}|[a-f0-9]{6}|[a-f0-9]{3,4})\b/gi,
        },
        {
            debugName: "hexLiteral.patterns![1]",

            token: MetaTokenType.Invalid, /*invalid.illegal.unexpected-number-of-hex-values.renpy*/
            match: /#[a-f0-9]+\b/gi,
        },
        {
            debugName: "hexLiteral.patterns![2]",

            match: /(#[a-f0-9]*)?(.+?)\b/dgi,
            captures: {
                1: { token: LiteralTokenType.Color, /*constant.color.renpy*/ },
                2: { token: MetaTokenType.Invalid, /*invalid.illegal.character-not-allowed-here.renpy*/ },
            },
        },
    ]
};

export const stringsInterior: TokenPattern = {
    patterns: [
        newLine,
        escapedChar,
        constantPlaceholder,
    ]
};

export const stringTagsBroken: TokenPattern = {
    patterns: [
        {
            debugName: "stringTagsBroken.patterns![0]",

            // Valid tags without params (optional close)
            contentToken: MetaTokenType.TaggedString, /*renpy.meta.${2:/downcase} meta.tagged.string.renpy*/
            begin: /({)\s*(u|i|b|s|plain|alt|noalt|art|rb|rt)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTagsBroken.patterns![1]",

            // Valid tags with numeric params (optional close)
            contentToken: MetaTokenType.TaggedString, /*renpy.meta.${2:/downcase} meta.tagged.string.renpy*/
            begin: /({)\s*(alpha|cps|k)(=)(?:(\*)|(\-)|(\+))?(\d*(?:.\d+)?)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: OperatorTokenType.Multiply, /*keyword.operator.arithmetic.Multiply.renpy*/ },
                5: { token: OperatorTokenType.Minus, /*keyword.operator.arithmetic.Minus.renpy*/ },
                6: { token: OperatorTokenType.Plus, /*keyword.operator.arithmetic.Plus.renpy*/ },
                7: { token: MetaTokenType.ConstantNumeric, /*support.constant.property-value.renpy constant.numeric.renpy*/ },
                8: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTagsBroken.patterns![2]",

            // Valid tags with numeric params (optional close)
            contentToken: MetaTokenType.TaggedString, /*renpy.meta.${2:/downcase} meta.tagged.string.renpy*/
            begin: /({)\s*(size)(=)([\-+]?)(\d+)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: MetaTokenType.ArithmeticOperator, /*keyword.operator.arithmetic.renpy*/ },
                5: { token: LiteralTokenType.Integer, /*support.constant.property-value.renpy constant.numeric.integer.renpy*/ },
                6: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTagsBroken.patterns![3]",

            // Valid tags with file param (optional close)
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            begin: /({)\s*(font)(=)([\w.]+)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: LiteralTokenType.String, /*support.constant.property-value.renpy string.unquoted.renpy*/ },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTagsBroken.patterns![4]",

            // Color tag
            contentToken: MetaTokenType.TaggedString, /*renpy.meta.${2:/downcase}.${4:/downcase} meta.tagged.string.renpy*/
            begin: /({)\s*(color|outlinecolor)(=)(#?[a-zA-Z0-9]+)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { patterns: [hexLiteral] },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTagsBroken.patterns![5]",

            // a tag
            contentToken: MetaTokenType.TaggedString, /*renpy.meta.${2:/downcase} meta.tagged.string.renpy*/
            begin: /({)\s*(a)(=)(.*?)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: {
                    token: LiteralTokenType.String, /*support.constant.property-value.renpy string.unquoted.renpy*/
                    patterns: [
                    ]
                },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
    ]
};

export const stringTags: TokenPattern = {
    patterns: [
        {
            debugName: "stringTags.patterns![0]",

            // Valid tags without params (self-closing)
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            match: /({)\s*(nw|done|fast|p|w|clear)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![1]",

            // Valid tags with numeric params (self-closing)
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            match: /({)\s*(p|w)(=)(\+)?(\d*(?:.\d+)?)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: OperatorTokenType.Plus, /*keyword.operator.arithmetic.plus.renpy*/ },
                5: { token: LiteralTokenType.Float, /*support.constant.property-value.renpy constant.numeric.float.renpy*/ },
                6: { token: CharacterTokenType.CloseBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![2]",

            // Valid tags with numeric params (self-closing)
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            match: /({)\s*(v?space)(=)(\+)?(\d+)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: OperatorTokenType.Plus, /*keyword.operator.arithmetic.plus.renpy*/ },
                5: { token: LiteralTokenType.Integer, /*support.constant.property-value.renpy constant.numeric.integer.renpy*/ },
                6: { token: CharacterTokenType.CloseBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![3]",

            // Comment tag (self-closing)
            token: MetaTokenType.StringTag, /*meta.string.tag.comment.self-closing.renpy*/
            match: /({)\s*(#)\s*(.*?)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.begin.renpy*/ },
                2: { token: CharacterTokenType.Hashtag, /*comment.line.number-sign.renpy punctuation.definition.comment.renpy*/ },
                3: { token: MetaTokenType.Comment, /*comment.line.number-sign.renpy*/ },
                4: { token: CharacterTokenType.CloseBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![4]",

            // Valid tags with file param
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            match: /({)\s*(image)(=)([\w.]+)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: LiteralTokenType.String, /*support.constant.property-value.renpy string.unquoted.renpy*/ },
                5: { token: CharacterTokenType.CloseBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![5]",

            // Valid tags without params (optional close)
            match: /({)\s*(u|i|b|s|plain|alt|noalt|art|rb|rt)\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![6]",

            // Valid tags with numeric params (optional close)
            match: /({)\s*(alpha|cps|k)(=)(?:(\*)|(\-)|(\+))?(\d*(?:.\d+)?)\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: OperatorTokenType.Multiply, /*keyword.operator.arithmetic.Multiply.renpy*/ },
                5: { token: OperatorTokenType.Minus, /*keyword.operator.arithmetic.Minus.renpy*/ },
                6: { token: OperatorTokenType.Plus, /*keyword.operator.arithmetic.Plus.renpy*/ },
                7: { token: MetaTokenType.ConstantNumeric, /*support.constant.property-value.renpy constant.numeric.renpy*/ },
                8: { token: CharacterTokenType.CloseBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![7]",

            // Valid tags with numeric params (optional close)
            match: /({)\s*(size)(=)([\-+]?)(\d+)\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: MetaTokenType.ArithmeticOperator, /*keyword.operator.arithmetic.renpy*/ },
                5: { token: LiteralTokenType.Integer, /*support.constant.property-value.renpy constant.numeric.integer.renpy*/ },
                6: { token: CharacterTokenType.CloseBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![8]",

            // Valid tags with file param (optional close)
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            match: /({)\s*(font)(=)([\w.]+)\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: LiteralTokenType.String, /*support.constant.property-value.renpy string.unquoted.renpy*/ },
                5: { token: CharacterTokenType.CloseBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![9]",

            // Color tag
            match: /({)\s*(color|outlinecolor)(=)(#?[a-zA-Z0-9]+)\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { patterns: [hexLiteral] },
                5: { token: CharacterTokenType.CloseBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![10]",

            // a tag
            match: /({)\s*(a)(=)(.*?)\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: {
                    patterns: [
                        {
                            debugName: "stringTags.patterns![10].captures![4].patterns![0]",

                            match: /\b(jump)\b(:)([a-zA-Z_]\w*)/dg,
                            captures: {
                                1: { token: KeywordTokenType.Jump, /*keyword.control.flow.jump.renpy*/ },
                                2: { token: CharacterTokenType.Colon, /*keyword.operator.jump.renpy punctuation.colon.renpy*/ },
                                3: { patterns: [fallbackPatterns] },
                            },
                        },
                        {
                            debugName: "stringTags.patterns![10].captures![4].patterns![1]",

                            token: LiteralTokenType.String, /*support.constant.property-value.renpy string.unquoted.renpy*/
                            match: /.*/g,
                        },
                    ]
                },
                5: { token: CharacterTokenType.CloseBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![11]",

            // Close tags
            match: /({\/)\s*([a-zA-Z_]\w*)?(=)?(.*?)?\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: LiteralTokenType.String, /*support.constant.property-value.renpy string.unquoted.renpy*/ },
                5: { token: CharacterTokenType.CloseBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![12]",

            // Custom tags (optional close)
            match: /({)\s*([a-zA-Z_]\w*)?(=)?(.*?)?\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: LiteralTokenType.String, /*support.constant.property-value.renpy string.unquoted.renpy*/ },
                5: { token: CharacterTokenType.CloseBracket, /*constant.character.format.placeholder.other.renpy punctuation.definition.tag.end.renpy*/ },
            },
        },
    ]
};

export const strings: TokenPattern = {
    debugName: "strings",

    token: LiteralTokenType.String, /*string.quoted.renpy*/
    begin: /"""|"|'''|'|```|`/dg,
    beginCaptures: {
        0: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.renpy*/ },
    },
    end: /(?<![^\\]\\)(((?<=\0)\0)|\0)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.renpy*/ },
        2: { token: MetaTokenType.EmptyString, /*meta.empty-string.renpy*/ },
    },
    patterns: [stringsInterior]
};

export const pythonStatements: TokenPattern = {
    patterns: [
        {
            debugName: "pythonStatements.patterns![0]",

            match: /(?<=^[ \t]*)(init)([ \t]+)(offset)([ \t]*)(=)([ \t]*)(-)?([^#]*?)$/dgm,
            captures: {
                1: { token: KeywordTokenType.Init, /*keyword.init.renpy*/ },
                2: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.renpy*/ },
                3: { token: KeywordTokenType.Offset, /*keyword.offset.renpy*/ },
                4: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.renpy*/ },
                5: { token: OperatorTokenType.Assignment, /*keyword.operator.assignment.renpy*/ },
                6: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.renpy*/ },
                7: { token: OperatorTokenType.Minus, /*keyword.operator.arithmetic.minus.renpy*/ },
                8: {
                    patterns: [
                        numInt,
                        invalidToken,
                    ]
                },
            },
        },
        {
            debugName: "pythonStatements.patterns![1]",

            // Renpy python block
            contentToken: MetaTokenType.PythonBlock, /*meta.embedded.block.python*/
            begin: /(?<=(^[ \t]*))(?:(init)(?:([ \t]+)(-)?(\d+))?([ \t]+))?(python)(.*)?(:)/dgm,
            beginCaptures: {
                2: { token: KeywordTokenType.Init, /*keyword.init.renpy*/ },
                3: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.renpy*/ },
                4: { token: OperatorTokenType.Minus, /*keyword.operator.arithmetic.minus.renpy*/ },
                5: { token: LiteralTokenType.Integer, /*constant.numeric.integer.renpy*/ },
                6: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.renpy*/ },
                7: { token: KeywordTokenType.Python, /*keyword.python.renpy*/ },
                8: {
                    token: MetaTokenType.Arguments, /*meta.python.block.arguments.renpy*/
                    patterns: [
                        {
                            debugName: "pythonStatements.patterns![1].beginCaptures![8].patterns![0]",

                            // in statement
                            begin: /\b(in)\b/dg,
                            beginCaptures: {
                                1: { token: KeywordTokenType.In, /*keyword.control.flow.in.renpy*/ },
                            },
                            end: /(?!\G)(?<=[^ \t])|$/gm,
                            patterns: [
                                {
                                    debugName: "pythonStatements.patterns![1].beginCaptures![8].patterns![0].patterns![0]",

                                    token: EntityTokenType.NamespaceName, /*entity.name.namespace*/
                                    match: /\b[\p{XID_Start}_]\p{XID_Continue}*\b/gu,
                                },
                                fallbackPatterns,
                            ]
                        },
                        {
                            debugName: "pythonStatements.patterns![1].beginCaptures![8].patterns![1]",

                            // keywords
                            match: /\b(hide)|(early)|(in)\b/dg,
                            captures: {
                                1: { token: KeywordTokenType.Hide, /*keyword.hide.renpy*/ },
                                2: { token: KeywordTokenType.Early, /*keyword.early.renpy*/ },
                                3: { token: KeywordTokenType.In, /*keyword.control.flow.in.renpy*/ },
                            },
                        },
                    ]
                },
                9: { token: CharacterTokenType.Colon, /*punctuation.section.python.begin.renpy*/ },
            },
            // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: []
        }]
};

export const pythonBlockTester: TokenPattern = {
    patterns: [
        {
            debugName: "pythonBlockTester.patterns![0]",

            // Check for assignments that support python expressions
            contentToken: MetaTokenType.PythonExpression, /*meta.python.expression.renpy*/
            begin: /(?<=(^[ \t]*)(?:image)\b.*?)(=)/dgm,
            beginCaptures: {
                2: { token: OperatorTokenType.Assignment, /*keyword.operator.assignment.renpy*/ },
            },
            // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: [
            ]
        },
        {
            debugName: "pythonBlockTester.patterns![1]",

            contentToken: MetaTokenType.PythonBlock, /*meta.embedded.block.python*/
            begin: /(?<=(^[ \t]*).*?python\b\s*)(:)/dgm,
            beginCaptures: {
                2: { token: CharacterTokenType.Colon, /*punctuation.section.python.begin.renpy*/ },
            },
            // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: []
        }]
};

export const define: TokenPattern = {
    debugName: "define",

    begin: /(?<=^[ \t]*)(define)\b/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Define, /*keyword.define.renpy*/ },
    },
    end: /$/gm,
    patterns: [
        numInt,
        strings,
        {
            debugName: "define.patterns![3]",

            contentToken: MetaTokenType.PythonExpression, /*meta.python.expression.renpy*/
            begin: /(\+=)|(\|=)|(=)/dg,
            beginCaptures: {
                1: { token: OperatorTokenType.PlusAssign, /*keyword.operator.plus.assign.renpy*/ },
                2: { token: MetaTokenType.BitwiseOperatorKeyword, /*keyword.operator.bitwise.or.assign.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*keyword.operator.assignment.renpy*/ },
            },
            end: /$/gm,
            patterns: [whitespace]
        },
        fallbackPatterns,
    ]
};

export const defaultStatement: TokenPattern = {
    debugName: "defaultStatement",

    begin: /(?<=^[ \t]*)(default)\b/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Default, /*keyword.default.renpy*/ },
    },
    end: /$/gm,
    patterns: [
        strings,
        {
            debugName: "defaultStatement.patterns![2]",

            contentToken: MetaTokenType.PythonExpression, /*meta.python.expression.renpy*/
            begin: /=/dg,
            beginCaptures: {
                0: { token: OperatorTokenType.Assignment, /*keyword.operator.assignment.renpy*/ },
            },
            end: /$/gm,
            patterns: [whitespace]
        },
        whitespace,
    ]
};

export const oneLinePython: TokenPattern = {
    debugName: "oneLinePython",

    begin: /(?<=^[ \t]*)(\$)(?=[ \t]|$)/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.DollarSign, /*keyword.dollar.sign.renpy*/ },
    },
    end: /$/gm,
    patterns: [
        strings,
        fallbackPatterns,
    ]
};

export const sayStatements: TokenPattern = {
    patterns: [
        {
            debugName: "sayStatements.patterns![0]",

            token: MetaTokenType.SayStatement, /*meta.say.statement.renpy*/
            contentToken: LiteralTokenType.String, /*renpy.meta.say.$1 string.quoted.renpy*/
            begin: /(?<=^[ \t]+)(?:([a-zA-Z_]\w*)\b|"([a-zA-Z_]\w*)\b")((?:[ \t]+(?:@|\w+))*)?[ \t]*("""|"|'''|'|```|`)/dgm,
            beginCaptures: {
                1: {
                    token: EntityTokenType.Identifier, /*renpy.meta.character.$1 variable.other.renpy*/
                    patterns: [
                        {
                            debugName: "sayStatements.patterns![0].beginCaptures![1].patterns![0]",

                            token: KeywordTokenType.Extend, /*keyword.extend.renpy*/
                            match: /extend/g,
                        },
                        {
                            debugName: "sayStatements.patterns![0].beginCaptures![1].patterns![1]",

                            token: KeywordTokenType.Voice, /*keyword.voice.renpy*/
                            match: /voice/g,
                        },
                        {
                            debugName: "sayStatements.patterns![0].beginCaptures![1].patterns![2]",

                            // Match special characters
                            token: EntityTokenType.Identifier, /*variable.other.constant.renpy*/
                            match: /adv|nvl|narrator|name_only|centered|vcentered/g,
                        },
                    ]
                },
                2: { token: MetaTokenType.CharacterNameString, /*meta.string.character.$2.renpy*/ },
                3: {
                    token: MetaTokenType.Arguments, /*meta.arguments.renpy*/
                    patterns: [
                        {
                            debugName: "sayStatements.patterns![0].beginCaptures![3].patterns![0]",

                            token: KeywordTokenType.At, /*keyword.at.renpy*/
                            match: /@/g,
                        },
                    ]
                },
                4: { token: MetaTokenType.StringBegin, /*string.quoted.renpy punctuation.definition.string.begin.renpy*/ },
            },
            // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
            end: /(?<![^\\]\\)(((?<=\4)\4)|\4)([ \t]*\(.*?\)(?![^\(]*?\)))?/dg,
            endCaptures: {
                1: { token: MetaTokenType.StringEnd, /*string.quoted.renpy punctuation.definition.string.end.renpy*/ },
                2: { token: MetaTokenType.EmptyString, /*meta.empty-string.renpy*/ },
                3: {
                    token: MetaTokenType.Arguments, /*meta.say.arguments.renpy*/
                    patterns: [
                    ]
                },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "sayStatements.patterns![1]",

            token: MetaTokenType.SayStatement, /*meta.say.narrator.renpy meta.say.statement.renpy*/
            begin: /(?<=^[ \t]+)(?=r?(?:"|'|`))/gm,
            end: /$/gm,
            patterns: [
                strings,
                fallbackPatterns,
            ]
        },
    ]
};

export const pause: TokenPattern = {
    debugName: "pause",

    token: MetaTokenType.PauseStatement, /*meta.pause.statement.renpy*/
    contentToken: MetaTokenType.PauseParameters, /*meta.pause.parameters.renpy*/
    begin: /(?<=^[ \t]+)(pause)\b/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Pause, /*keyword.control.flow.pause.renpy*/ },
    },
    end: /(?=#)|$/gm,
    patterns: [simpleExpression]
};

export const renpyBlockTester: TokenPattern = {
    debugName: "renpyBlockTester",

    contentToken: MetaTokenType.RenpyBlock, /*meta.renpy.block.renpy*/
    begin: /(?<=(^[ \t]*)(?:if|elif|else|for|while|label)\b.*?)(:)/dgm,
    beginCaptures: {
        2: { token: CharacterTokenType.Colon, /*punctuation.section.block.begin.renpy*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
    patterns: [
    ]
};

export const conditionals: TokenPattern = {
    debugName: "conditionals",

    begin: /(?<=^[ \t]+)(if|elif|else|while|for)\b/dgm,
    beginCaptures: {
        1: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.renpy*/ },
    },
    end: /(?=#|:)|$/gm,
    patterns: [fallbackPatterns]
};

export const atStatement: TokenPattern = {
    debugName: "atStatement",

    token: MetaTokenType.AtStatement, /*meta.at.statement.renpy*/
    contentToken: MetaTokenType.AtParameters, /*meta.at.parameters.renpy*/
    begin: /\b(?!\.)(at)\b/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.At, /*keyword.control.flow.at.renpy*/ },
    },
    end: /(?=\b(at|as|behind|onlayer|expression|with|zorder)\b|#|=|:)|$/gm,
    patterns: [simpleExpression]
};

export const asStatement: TokenPattern = {
    debugName: "asStatement",

    token: MetaTokenType.AsStatement, /*meta.as.statement.renpy*/
    contentToken: MetaTokenType.AsParameters, /*meta.as.parameters.renpy*/
    begin: /\b(?!\.)(as)\b/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.As, /*keyword.control.flow.as.renpy*/ },
    },
    end: /(?=\b(at|as|behind|onlayer|expression|with|zorder)\b|#|=|:)|$/gm,
    patterns: [
        whitespace,
        simpleExpression,
    ]
};

export const withStatement: TokenPattern = {
    debugName: "withStatement",

    token: MetaTokenType.WithStatement, /*meta.with.statement.renpy*/
    contentToken: MetaTokenType.WithParameters, /*meta.with.parameters.renpy*/
    begin: /\b(?!\.)(with)\b/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.With, /*keyword.control.flow.with.renpy*/ },
    },
    end: /(?=\b(at|as|behind|onlayer|expression|with|zorder)\b|#|=|:)|$/gm,
    patterns: [
        whitespace,
        simpleExpression,
    ]
};

export const behind: TokenPattern = {
    debugName: "behind",

    token: MetaTokenType.BehindStatement, /*meta.behind.statement.renpy*/
    contentToken: MetaTokenType.BehindParameters, /*meta.behind.parameters.renpy*/
    begin: /\b(?!\.)(behind)\b/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.Behind, /*keyword.control.flow.behind.renpy*/ },
    },
    end: /(?=\b(at|as|behind|onlayer|expression|with|zorder)\b|#|=|:)|$/gm,
    patterns: [
        whitespace,
        simpleExpression,
    ]
};

export const onlayer: TokenPattern = {
    debugName: "onlayer",

    token: MetaTokenType.OnlayerStatement, /*meta.onlayer.statement.renpy*/
    contentToken: MetaTokenType.OnlayerParameters, /*meta.onlayer.parameters.renpy*/
    begin: /\b(?!\.)(onlayer)\b/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.Onlayer, /*keyword.control.flow.onlayer.renpy*/ },
    },
    end: /(?=\b(at|as|behind|onlayer|expression|with|zorder)\b|#|=|:)|$/gm,
    patterns: [
        whitespace,
        simpleExpression,
    ]
};

export const zorder: TokenPattern = {
    debugName: "zorder",

    token: MetaTokenType.ZorderStatement, /*meta.zorder.statement.renpy*/
    contentToken: MetaTokenType.ZorderParameters, /*meta.zorder.parameters.renpy*/
    begin: /\b(?!\.)(zorder)\b/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.Zorder, /*keyword.control.flow.zorder.renpy*/ },
    },
    end: /(?=\b(at|as|behind|onlayer|expression|with|zorder)\b|#|=|:)|$/gm,
    patterns: [
        whitespace,
        simpleExpression,
    ]
};

export const image: TokenPattern = {
    patterns: [
        {
            debugName: "image.patterns![0]",

            token: MetaTokenType.ImageStatement, /*meta.image.statement.renpy*/
            begin: /(?<=^[ \t]*)(image)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Image, /*keyword.image.renpy*/ },
            },
            end: /(?=\b(at|with)\b|#|=|:)|$/gm,
            patterns: [
                strings,
                {
                    debugName: "image.patterns![0].patterns![1]",

                    token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/
                    match: /\b(?:[a-zA-Z_0-9]+)\b[ \t]*/g,
                },
            ]
        },
        atStatement,
        withStatement,
    ]
};

export const layeredimageBlockTester: TokenPattern = {
    debugName: "layeredimageBlockTester",

    contentToken: MetaTokenType.LayeredimageBlock, /*meta.layeredimage.block.renpy*/
    begin: /(?<=(^[ \t]*)(?:layeredimage|group|always|attribute)\b.*?)(:)/dgm,
    beginCaptures: {
        2: { token: CharacterTokenType.Colon, /*punctuation.section.block.begin.renpy*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
    patterns: [
        {
            debugName: "layeredimageBlockTester.patterns![0]",

            token: KeywordTokenType.Always, /*keyword.always.renpy*/
            match: /\b(?:always)\b/g,
        },
        {
            debugName: "layeredimageBlockTester.patterns![1]",

            token: KeywordTokenType.Always, /*keyword.always.renpy*/
            match: /\b(?:pos)\b/g,
        },
    ]
};

export const layeredimageGroup: TokenPattern = {
    patterns: [
        {
            debugName: "layeredimageGroup.patterns![0]",

            token: MetaTokenType.LayeredimageGroupStatement, /*meta.layeredimage.group.statement.renpy*/
            contentToken: MetaTokenType.LayeredimageGroupParameters, /*meta.layeredimage.group.parameters.renpy*/
            begin: /(?<=^[ \t]*)(group)\b/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Group, /*keyword.group.renpy*/ },
            },
            end: /(?=#|:)|$/gm,
            patterns: [
                {
                    debugName: "layeredimageGroup.patterns![0].patterns![0]",

                    token: EntityTokenType.LayeredimageName, /*entity.name.type.layeredimage..renpy*/
                    match: /\b([a-zA-Z_]\w*)\b/g,
                },
                fallbackPatterns,
            ]
        },
        layeredimageBlockTester,
    ]
};

export const layeredimageAttribute: TokenPattern = {
    patterns: [
        {
            debugName: "layeredimageAttribute.patterns![0]",

            token: MetaTokenType.LayeredimageAttributeStatement, /*meta.layeredimage.attribute.statement.renpy*/
            contentToken: MetaTokenType.LayeredimageAttributeParameters, /*meta.layeredimage.attribute.parameters.renpy*/
            begin: /(?<=^[ \t]*)(attribute)\b/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Attribute, /*keyword.attribute.renpy*/ },
            },
            end: /(?=#|:)|$/gm,
            patterns: [
                {
                    debugName: "layeredimageAttribute.patterns![0].patterns![0]",

                    token: KeywordTokenType.Default, /*keyword.default.renpy*/
                    match: /\b(default)\b/g,
                },
                {
                    debugName: "layeredimageAttribute.patterns![0].patterns![1]",

                    token: EntityTokenType.LayeredimageName, /*entity.name.type.layeredimage.attribute.renpy*/
                    match: /\b([a-zA-Z_]\w*)\b/g,
                },
                fallbackPatterns,
            ]
        },
        layeredimageBlockTester,
    ]
};

export const layeredimage: TokenPattern = {
    patterns: [
        {
            debugName: "layeredimage.patterns![0]",

            token: MetaTokenType.LayeredimageStatement, /*meta.layeredimage.statement.renpy*/
            contentToken: MetaTokenType.LayeredimageParameters, /*meta.layeredimage.parameters.renpy*/
            begin: /(?<=^[ \t]*)(layeredimage)\b/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Layeredimage, /*keyword.layeredimage.renpy*/ },
            },
            end: /(?=#|:)|$/gm,
            patterns: [
                {
                    debugName: "layeredimage.patterns![0].patterns![0]",

                    token: EntityTokenType.LayeredimageName, /*entity.name.type.layeredimage.renpy*/
                    match: /\b([a-zA-Z_]\w*)\b/g,
                },
                fallbackPatterns,
            ]
        },
        layeredimageBlockTester,
    ]
};

export const translateBlockTester: TokenPattern = {
    patterns: [
        {
            debugName: "translateBlockTester.patterns![0]",

            contentToken: MetaTokenType.TranslateBlock, /*meta.translate.block.renpy*/
            begin: /(?<=(^[ \t]*)(?:translate)\b.*?)(:)/dgm,
            beginCaptures: {
                2: { token: CharacterTokenType.Colon, /*punctuation.section.block.begin.renpy*/ },
            },
            // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: []
        }]
};

export const translate: TokenPattern = {
    patterns: [
        {
            debugName: "translate.patterns![0]",

            token: MetaTokenType.TranslateStatement, /*meta.translate.statement.renpy*/
            contentToken: MetaTokenType.TranslateParameters, /*meta.translate.parameters.renpy*/
            begin: /(?<=^[ \t]*)(translate)\b/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Translate, /*keyword.translate.renpy*/ },
            },
            end: /(?=#|:)|$/gm,
            patterns: [
                {
                    debugName: "translate.patterns![0].patterns![0]",

                    token: MetaTokenType.ConstantLiteral, /*constant.language.renpy*/
                    match: /\b(?<!\.)(None)\b/g,
                },
                {
                    debugName: "translate.patterns![0].patterns![1]",

                    token: KeywordTokenType.Other, /*keyword.other.renpy*/
                    match: /\b(?<!\.)(strings|style|default|python)\b/g,
                },
                {
                    debugName: "translate.patterns![0].patterns![2]",

                    // Only the first word is the language name
                    token: EntityTokenType.LanguageName, /*entity.name.type.language.translate.renpy*/
                    match: /(?<=translate[ \t]+)\b([a-zA-Z_]\w*)\b/g,
                },
                fallbackPatterns,
            ]
        },
        pythonBlockTester,
        translateBlockTester,
    ]
};

export const show: TokenPattern = {
    patterns: [
        {
            debugName: "show.patterns![0]",

            token: MetaTokenType.ShowStatement, /*meta.show.statement.renpy*/
            begin: /(?<=^[ \t]*)(show)\b/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Show, /*keyword.control.flow.show.renpy*/ },
            },
            end: /(?=#|:)|$/gm,
            patterns: [
                strings,
                {
                    debugName: "show.patterns![0].patterns![2]",

                    token: KeywordTokenType.Layer, /*keyword.layer.renpy*/
                    match: /\b(layer)\b/g,
                },
                {
                    debugName: "show.patterns![0].patterns![3]",

                    token: KeywordTokenType.Nopredict, /*keyword.nopredict.renpy*/
                    match: /\b(nopredict)\b/g,
                },
                atStatement,
                asStatement,
                withStatement,
                behind,
                onlayer,
                zorder,
                {
                    debugName: "show.patterns![0].patterns![10]",

                    token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/
                    match: /\b(?:[a-zA-Z_0-9]+)\b/g,
                },
                fallbackPatterns,
            ]
        },
    ]
};

export const window: TokenPattern = {
    patterns: [
        {
            debugName: "window.patterns![0]",

            token: MetaTokenType.WindowStatement, /*meta.window.statement.renpy*/
            begin: /(?<=^[ \t]*)(window)/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Window, /*keyword.window.renpy*/ },
            },
            end: /$/gm,
            patterns: [
                {
                    debugName: "window.patterns![0].patterns![0]",

                    token: KeywordTokenType.Auto, /*keyword.auto.renpy*/
                    match: /(?<=window[ \t]+)\b(auto)\b/g,
                },
                {
                    debugName: "window.patterns![0].patterns![1]",

                    token: KeywordTokenType.Show, /*keyword.control.flow.show.renpy*/
                    match: /(?<=(?:window|auto)[ \t]+)\b(show)\b/g,
                },
                {
                    debugName: "window.patterns![0].patterns![2]",

                    token: KeywordTokenType.Hide, /*keyword.control.flow.hide.renpy*/
                    match: /(?<=window[ \t]+)\b(hide)\b/g,
                },
                whitespace,
                simpleExpression,
            ]
        },
    ]
};

export const hide: TokenPattern = {
    patterns: [
        {
            debugName: "hide.patterns![0]",

            token: MetaTokenType.HideStatement, /*meta.hide.statement.renpy*/
            begin: /(?<=^[ \t]*)(hide)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Hide, /*keyword.control.flow.hide.renpy*/ },
            },
            end: /$/gm,
            patterns: [
                strings,
                withStatement,
                behind,
                zorder,
                {
                    debugName: "hide.patterns![0].patterns![5]",

                    token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/
                    match: /\b(?:[a-zA-Z_0-9]+)\b[ \t]*/g,
                },
                fallbackPatterns,
            ]
        },
    ]
};

export const scene: TokenPattern = {
    patterns: [
        {
            debugName: "scene.patterns![0]",

            token: MetaTokenType.SceneStatement, /*meta.scene.statement.renpy*/
            begin: /(?<=^[ \t]*)(scene)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Scene, /*keyword.scene.renpy*/ },
            },
            end: /(?=\b(at|as|behind|onlayer|expression|with|zorder)\b|#|:)|$/gm,
            patterns: [
                strings,
                {
                    debugName: "scene.patterns![0].patterns![1]",

                    token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/
                    match: /\b(?:[a-zA-Z_0-9]+)\b[ \t]*/g,
                },
            ]
        },
        withStatement,
        behind,
        onlayer,
        zorder,
    ]
};

export const camera: TokenPattern = {
    patterns: [
        {
            debugName: "camera.patterns![0]",

            token: MetaTokenType.CameraStatement, /*meta.camera.statement.renpy*/
            begin: /(?<=^[ \t]*)(camera)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Camera, /*keyword.camera.renpy*/ },
            },
            end: /(?=\b(at|with)\b|#|:)|$/gm,
            patterns: [
                {
                    debugName: "camera.patterns![0].patterns![0]",

                    token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/
                    match: /\b(?:[a-zA-Z_0-9]+)\b[ \t]*/g,
                },
            ]
        },
        atStatement,
        withStatement,
    ]
};

export const screenCall: TokenPattern = {
    debugName: "screenCall",

    token: MetaTokenType.ScreenCall, /*meta.screen.call.renpy*/
    begin: /(?<=(?:call|show|hide)[ \t]+)(screen)\b/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.Screen, /*keyword.screen.renpy*/ },
    },
    end: /(?!\G)(?<=[^ \t])/g,
    patterns: [
        {
            debugName: "screenCall.patterns![0]",

            // Label expression
            begin: /(?<=screen[ \t]+)(?=[a-zA-Z_.])/g,
            end: /(?![a-zA-Z_.])(?![ \t]*\.[ \t]*)/g,
            patterns: [
            ]
        },
        withStatement,
        whitespace,
    ]
};

export const builtinLabels: TokenPattern = {
    debugName: "builtinLabels",

    token: EntityTokenType.FunctionName, /*support.function.builtin.renpy*/
    match: /(?<!\.)\b(?:start|quit|after_load|splashscreen|before_main_menu|main_menu|after_warp|hide_windows)\b/g,
};

export const labelName: TokenPattern = {
    patterns: [
        builtinLabels,
        {
            debugName: "labelName.patterns![2]",

            token: EntityTokenType.FunctionName, /*entity.name.function.label.renpy*/
            match: /\b(?:[a-zA-Z_]\w*)\b/g,
        },
    ]
};

export const labelCall: TokenPattern = {
    debugName: "labelCall",

    // Note: label params are only allowed at the end of the access expression
    token: MetaTokenType.LabelCall, /*meta.function-call.label.renpy*/
    begin: /\b(?=([a-zA-Z_]\w*)\s*(\())/g,
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.renpy*/ },
    },
    patterns: [labelName]
};

export const labelAccess: TokenPattern = {
    debugName: "labelAccess",

    // Note: Labels can't be nested twice in a row!
    token: MetaTokenType.LabelAccess, /*meta.member.access.label.renpy*/
    begin: /(\.)\s*(?!\.)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.Dot, /*punctuation.separator.dot.renpy*/ },
    },
    end: /(?<=\S)(?=\W)|(^|(?<=\s))(?=[^\\\w\s])|$/gm,
    patterns: [
        labelCall,
        labelName,
    ]
};

export const labelDefName: TokenPattern = {
    // Note: Labels can't be nested twice in a row!
    patterns: [
        builtinLabels,
        {
            debugName: "labelDefName.patterns![2]",

            match: /(?<=^|[ \t])(\b(?:[a-zA-Z_]\w*)\b)?(\.)?(\b(?:[a-zA-Z_]\w*)\b)/dgm,
            captures: {
                1: { token: EntityTokenType.FunctionName, /*entity.name.function.label.renpy*/ },
                2: { token: CharacterTokenType.Dot, /*punctuation.separator.dot.renpy*/ },
                3: { token: EntityTokenType.FunctionName, /*entity.name.function.label.renpy*/ },
            },
        },
    ]
};

export const label: TokenPattern = {
    debugName: "label",

    token: MetaTokenType.LabelStatement, /*meta.label.statement.renpy*/
    begin: /(?<=^[ \t]*)(label)\b/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Label, /*storage.type.function.label.renpy*/ },
    },
    end: /(?=#|:)|$/gm,
    patterns: [
        {
            debugName: "label.patterns![0]",

            token: KeywordTokenType.Hide, /*keyword.control.flow.hide.renpy*/
            match: /\b(?<!\.)(hide)\b/g,
        },
        labelDefName,
    ]
};

export const returnStatements: TokenPattern = {
    debugName: "returnStatements",

    begin: /(?<=^[ \t]+)(return)\b/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Return, /*keyword.control.flow.return.renpy*/ },
    },
    end: /$/gm,
    patterns: [renpyOnlyExpressions]
};

export const callJumpExpression: TokenPattern = {
    debugName: "callJumpExpression",

    begin: /\b(?<!\.)(expression)\b/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.Expression, /*keyword.expression.renpy*/ },
    },
    end: /(?=\b(?<!\.)(?:pass|from)\b)|$/gm,
    patterns: [renpyOnlyExpressions]
};

export const jump: TokenPattern = {
    debugName: "jump",

    token: MetaTokenType.JumpStatement, /*meta.jump.statement.renpy*/
    begin: /(?<=^[ \t]+)(jump)\b/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Jump, /*keyword.control.flow.jump.renpy*/ },
    },
    end: /(?=#)|$/dgm,
    endCaptures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.renpy*/ },
    },
    patterns: [
        callJumpExpression,
        {
            debugName: "jump.patterns![1]",

            // Label expression
            begin: /(?=[a-zA-Z_.])/g,
            end: /(?![a-zA-Z_.])(?![ \t]*\.[ \t]*)/g,
            patterns: [
                labelAccess,
                labelName,
            ]
        },
        whitespace,
    ]
};

export const callPass: TokenPattern = {
    debugName: "callPass",

    begin: /\b(?<!\.)(pass)\b(?=[ \t]*\()/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.Pass, /*keyword.control.flow.pass.renpy*/ },
    },
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.renpy*/ },
    },
    patterns: [whitespace]
};

export const callFrom: TokenPattern = {
    debugName: "callFrom",

    token: MetaTokenType.FromClause, /*meta.from.clause.renpy*/
    contentToken: MetaTokenType.Arguments, /*meta.from.arguments.renpy*/
    begin: /\b(?<!\.)(from)\b/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.From, /*keyword.control.flow.from.renpy*/ },
    },
    end: /(?!\G)(?<=[^ \t])|$/gm,
    patterns: [
        labelName,
        fallbackPatterns,
    ]
};

export const call: TokenPattern = {
    debugName: "call",

    token: MetaTokenType.CallStatement, /*meta.call.statement.renpy*/
    contentToken: MetaTokenType.Arguments, /*meta.call.arguments.renpy*/
    begin: /(?<=^[ \t]+)(call)\b/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Call, /*keyword.control.flow.call.renpy*/ },
    },
    end: /$/dgm,
    endCaptures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.renpy*/ },
    },
    patterns: [
        callJumpExpression,
        callPass,
        callFrom,
        screenCall,
        {
            debugName: "call.patterns![4]",

            token: KeywordTokenType.Nopredict, /*keyword.nopredict.renpy*/
            match: /\b(nopredict)\b/g,
        },
        withStatement,
        {
            debugName: "call.patterns![6]",

            // Label expression
            begin: /(?<=call[ \t]+)(?=[a-zA-Z_.])/g,
            end: /(?![a-zA-Z_.])(?![ \t]*\.[ \t]*)/g,
            patterns: [
                labelCall,
                labelAccess,
                labelName,
            ]
        },
        whitespace,
        comments,
        {
            debugName: "call.patterns![9]",

            token: MetaTokenType.Invalid, /*invalid.illegal.unexpected-characters-call-arguments.renpy*/
            match: /[^ \t]+/g,
        },
    ]
};

export const menuOption: TokenPattern = {
    debugName: "menuOption",

    contentToken: MetaTokenType.MenuOptionBlock, /*meta.menu-option.block.renpy*/
    begin: /(?<=(^[ \t]+))((?:".*")|(?:'.*')|(?:""".*"""))(.+)?(:)/dgm,
    beginCaptures: {
        2: {
            token: MetaTokenType.MenuOption, /*meta.menu-option.renpy*/
            patterns: [strings]
        },
        3: {
            token: MetaTokenType.PythonLine, /*meta.embedded.line.python*/
            patterns: [
                {
                    debugName: "menuOption.beginCaptures![3].patterns![1]",

                    // if condition
                    begin: /\b(if)\b/dg,
                    beginCaptures: {
                        1: { token: KeywordTokenType.If, /*keyword.control.conditional.renpy*/ },
                    },
                    end: /(?=#|:)|$/gm,
                    patterns: []
                }]
        },
        4: { token: CharacterTokenType.Colon, /*punctuation.section.menu-option.begin.renpy*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
    patterns: [
    ]
};

export const menuSet: TokenPattern = {
    debugName: "menuSet",

    contentToken: MetaTokenType.PythonLine, /*meta.embedded.line.python*/
    begin: /(?<=^[ \t]+)(set)\b/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Set, /*keyword.set.renpy*/ },
    },
    end: /$/gm,
    patterns: [
    ]
};

export const menu: TokenPattern = {
    debugName: "menu",

    token: MetaTokenType.MenuStatement, /*meta.menu.statement.renpy*/
    contentToken: MetaTokenType.MenuBlock, /*meta.menu.block.renpy*/
    begin: /(?<=(^[ \t]*))(menu)[ \t]*(.+)?(:)/dgm,
    beginCaptures: {
        2: { token: KeywordTokenType.Def, /*storage.type.function.renpy*/ },
        3: {
            patterns: [
                {
                    debugName: "menu.beginCaptures![3].patterns![0]",

                    // Menu name
                    token: EntityTokenType.FunctionName, /*entity.name.function.menu.renpy*/
                    match: /[a-zA-Z_.]\w*/g,
                },
                {
                    debugName: "menu.beginCaptures![3].patterns![1]",

                    token: MetaTokenType.FunctionCall, /*meta.function-call.python*/
                    begin: /(?<=\bmenu\s*)(?=\()/g,
                    end: /(\))/dg,
                    endCaptures: {
                        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.python*/ },
                    },
                    patterns: []
                }]
        },
        4: { token: CharacterTokenType.Colon, /*punctuation.section.menu.begin.renpy*/ },
    },
    // @ts-ignore: Back references in end patterns are replaced by begin matches at runtime
    end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
    patterns: [
        comments,
        menuOption,
        sayStatements,
        menuSet,
        fallbackPatterns,
    ]
};

export const builtinAudioChannels: TokenPattern = {
    debugName: "builtinAudioChannels",

    token: MetaTokenType.BuiltinType, /*support.type.audio.channel.renpy*/
    match: /(?<!\.)\b(?:music|sound|voice|audio)\b/g,
};

export const audioChannel: TokenPattern = {
    patterns: [
        builtinAudioChannels,
        {
            debugName: "audioChannel.patterns![1]",

            token: EntityTokenType.AudioName, /*entity.name.type.audio.channel.renpy*/
            match: /.+/g,
        },
    ]
};

export const audioParams: TokenPattern = {
    patterns: [
        {
            debugName: "audioParams.patterns![0]",

            token: KeywordTokenType.OtherAudio, /*keyword.other.audio.renpy*/
            match: /\b(?<!\.)(?:fadeout|fadein|volume|loop|noloop)\b/g,
        },
    ]
};

export const play: TokenPattern = {
    patterns: [
        {
            debugName: "play.patterns![0]",

            token: MetaTokenType.PlayAudioStatement, /*meta.play.audio.statement.renpy*/
            begin: /(?<=^[ \t]*)(play)\b[ \t]+\b([a-zA-Z_0-9]*)\b/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Play, /*keyword.play.renpy*/ },
                2: { patterns: [audioChannel] },
            },
            end: /(?=#)|$/gm,
            patterns: [
                strings,
                audioParams,
                whitespace,
            ]
        },
    ]
};

export const queue: TokenPattern = {
    patterns: [
        {
            debugName: "queue.patterns![0]",

            token: MetaTokenType.QueueAudioStatement, /*meta.queue.audio.statement.renpy*/
            begin: /(?<=^[ \t]*)(queue)\b[ \t]+\b([a-zA-Z_0-9]*)\b/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Queue, /*keyword.queue.renpy*/ },
                2: { patterns: [audioChannel] },
            },
            end: /(?=#)|$/gm,
            patterns: [
                strings,
                audioParams,
                whitespace,
            ]
        },
    ]
};

export const stop: TokenPattern = {
    patterns: [
        {
            debugName: "stop.patterns![0]",

            token: MetaTokenType.StopAudioStatement, /*meta.stop.audio.statement.renpy*/
            begin: /(?<=^[ \t]*)(stop)\b[ \t]+\b([a-zA-Z_0-9]*)\b/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Stop, /*keyword.stop.renpy*/ },
                2: { patterns: [audioChannel] },
            },
            end: /(?=#)|$/gm,
            patterns: [
                {
                    debugName: "stop.patterns![0].patterns![0]",

                    token: KeywordTokenType.Fadeout, /*keyword.fadeout.renpy*/
                    match: /\b(?<!\.)(?:fadeout)\b/g,
                },
                whitespace,
            ]
        },
    ]
};

export const audio: TokenPattern = {
    patterns: [
        play,
        queue,
        stop,
    ]
};

export const renpyStatements: TokenPattern = {
    patterns: [
        label,
        menu,
        image,
        layeredimage,
        translate,
        audio,
        pause,
        renpyBlockTester,
        scene,
        camera,
        window,
        show,
        hide,
        withStatement,
        returnStatements,
        jump,
        call,
    ]
};

export const basePatterns: TokenPattern = {
    patterns: [
        statements,
        expressions,
    ]
};

// Push pattern references that were not defined on include
statements.patterns!.push(renpyStatements, pythonStatements, conditionals, keywords, sayStatements);
expressions.patterns!.push(renpyPythonExpressions, fallbackPatterns);
renpyOnlyExpressions.patterns!.push(comments, strings, literal);
fallbackPatterns.patterns!.splice(0, 0, comments);
fallbackPatternsWithError.patterns!.splice(0, 0, comments);
simpleExpression.patterns!.splice(7, 0, comments);
stringsInterior.patterns!.splice(2, 0, stringTags);
stringTags.patterns![10].captures![4].patterns![0].captures![3].patterns!.splice(0, 0, labelName);
pythonStatements.patterns!.push(define, defaultStatement, oneLinePython, pythonBlockTester);
sayStatements.patterns![1].patterns!.splice(2, 0, withStatement);
renpyBlockTester.patterns!.push(basePatterns);
layeredimageBlockTester.patterns!.push(layeredimageGroup, layeredimageAttribute, basePatterns);
translateBlockTester.patterns![0].patterns!.push(basePatterns);
translate.patterns![0].patterns!.splice(3, 0, labelAccess);
translate.patterns![0].patterns!.splice(4, 0, labelName);
show.patterns![0].patterns!.splice(0, 0, screenCall);
hide.patterns![0].patterns!.splice(0, 0, screenCall);
screenCall.patterns![0].patterns!.push(labelCall, labelAccess, labelName);
menuOption.patterns!.push(basePatterns);