/* eslint-disable no-useless-escape */
/* eslint-disable no-useless-backreference */
/* eslint-disable @typescript-eslint/no-non-null-assertion */

// THIS FILE HAS BEEN GENERATED BY THE `syntax-to-token-pattern.py` GENERATOR
// DO NOT EDIT THIS FILE DIRECTLY! INSTEAD RUN THE PYTHON SCRIPT.
// ANY MANUAL EDITS MADE TO THIS FILE WILL BE OVERWRITTEN. YOU HAVE BEEN WARNED.
// Last generated: 26/05/2023 14:14:22 (UTC+0)

import { MetaTokenType, CharacterTokenType, LiteralTokenType, KeywordTokenType, EscapedCharacterTokenType, EntityTokenType, OperatorTokenType } from "./renpy-tokens";
import { pythonExpression, python, pythonFunctionArguments, pythonBuiltinPossibleCallables, pythonLiteral, pythonMemberAccess, pythonIllegalOperator, pythonOperator, pythonCurlyBraces, pythonItemAccess, pythonList, pythonOddFunctionCall, pythonRoundBraces, pythonFunctionCall, pythonBuiltinFunctions, pythonBuiltinTypes, pythonBuiltinExceptions, pythonMagicNames, pythonSpecialNames, pythonIllegalNames, pythonSpecialVariables, pythonEllipsis, pythonPunctuation, pythonLineContinuation, pythonParameters, pythonExpressionBare, pythonNumber } from "./python-token-patterns";
import { atl } from "./atl-token-patterns.g";
import { TokenPattern } from "./token-pattern-types";

export const statements: TokenPattern = {
    patterns: [
    ]
};

export const expressions: TokenPattern = {
    patterns: [
    ]
};

export const invalidToken: TokenPattern = {
    debugName: "invalidToken",

    token: MetaTokenType.Invalid, /*invalid.unknown.token.renpy*/
    match: /.+/g,
};

export const newLine: TokenPattern = {
    debugName: "newLine",

    token: CharacterTokenType.NewLine, /*punctuation.new-line.renpy*/
    match: /\r\n|\r|\n/g,
};

export const whitespace: TokenPattern = {
    debugName: "whitespace",

    token: CharacterTokenType.Whitespace, /*punctuation.whitespace.renpy*/
    match: /[ \t]+/g,
};

export const fallbackCharacters: TokenPattern = {
    // NOTE: Having these patterns separated increases performance. Benchmark before making a change!
    patterns: [
        newLine,
        whitespace,
        {
            debugName: "fallbackCharacters.patterns![2]",

            token: CharacterTokenType.OpenParentheses, /*punctuation.parenthesis.begin.renpy*/
            match: /\(/g,
        },
        {
            debugName: "fallbackCharacters.patterns![3]",

            token: CharacterTokenType.CloseParentheses, /*punctuation.parenthesis.end.renpy*/
            match: /\)/g,
        },
        {
            debugName: "fallbackCharacters.patterns![4]",

            token: CharacterTokenType.OpenBracket, /*punctuation.bracket.begin.renpy*/
            match: /{/g,
        },
        {
            debugName: "fallbackCharacters.patterns![5]",

            token: CharacterTokenType.CloseBracket, /*punctuation.bracket.end.renpy*/
            match: /}/g,
        },
        {
            debugName: "fallbackCharacters.patterns![6]",

            token: CharacterTokenType.OpenSquareBracket, /*punctuation.square-bracket.begin.renpy*/
            match: /\[/g,
        },
        {
            debugName: "fallbackCharacters.patterns![7]",

            token: CharacterTokenType.CloseSquareBracket, /*punctuation.square-bracket.end.renpy*/
            match: /\]/g,
        },
        {
            debugName: "fallbackCharacters.patterns![8]",

            token: CharacterTokenType.Period, /*punctuation.period.renpy*/
            match: /\./g,
        },
        {
            debugName: "fallbackCharacters.patterns![9]",

            token: CharacterTokenType.Colon, /*punctuation.colon.renpy*/
            match: /:/g,
        },
        {
            debugName: "fallbackCharacters.patterns![10]",

            token: CharacterTokenType.Semicolon, /*punctuation.semicolon.renpy*/
            match: /;/g,
        },
        {
            debugName: "fallbackCharacters.patterns![11]",

            token: CharacterTokenType.Comma, /*punctuation.comma.renpy*/
            match: /,/g,
        },
        {
            debugName: "fallbackCharacters.patterns![12]",

            token: CharacterTokenType.Hashtag, /*punctuation.hashtag.renpy*/
            match: /#/g,
        },
        {
            debugName: "fallbackCharacters.patterns![13]",

            token: CharacterTokenType.Quote, /*punctuation.quote.renpy*/
            match: /'/g,
        },
        {
            debugName: "fallbackCharacters.patterns![14]",

            token: CharacterTokenType.DoubleQuote, /*punctuation.double-quote.renpy*/
            match: /"/g,
        },
        {
            debugName: "fallbackCharacters.patterns![15]",

            token: CharacterTokenType.BackQuote, /*punctuation.back-quote.renpy*/
            match: /`/g,
        },
        {
            debugName: "fallbackCharacters.patterns![16]",

            token: CharacterTokenType.Backslash, /*punctuation.backslash.renpy*/
            match: /\\/g,
        },
        {
            debugName: "fallbackCharacters.patterns![17]",

            token: CharacterTokenType.ForwardSlash, /*punctuation.forward-slash.renpy*/
            match: /\//g,
        },
        {
            debugName: "fallbackCharacters.patterns![18]",

            token: CharacterTokenType.EqualsSymbol, /*punctuation.equals-symbol.renpy*/
            match: /=/g,
        },
        {
            debugName: "fallbackCharacters.patterns![19]",

            token: MetaTokenType.Invalid, /*invalid.illegal.word.renpy*/
            match: /\b\w+\b/g,
        },
        {
            debugName: "fallbackCharacters.patterns![20]",

            token: CharacterTokenType.Unknown, /*punctuation.unknown.renpy*/
            match: /./g,
        },
    ]
};

export const literal: TokenPattern = {
    patterns: [
        {
            debugName: "literal.patterns![0]",

            // Python literals
            token: MetaTokenType.ConstantLiteral, /*constant.language.renpy*/
            match: /\b(?<!\.)(True|False|None)\b/g,
        },
    ]
};

export const numFloat: TokenPattern = {
    debugName: "numFloat",

    token: LiteralTokenType.Float, /*constant.numeric.float.renpy*/
    match: /(?<!\w)(?:\.[0-9]*|[0-9]*\.[0-9]*|[0-9]*\.)\b/g,
};

export const numInt: TokenPattern = {
    debugName: "numInt",

    token: LiteralTokenType.Integer, /*constant.numeric.integer.renpy*/
    match: /(?<![\w.])(?:[1-9]*|0+|0([0-9]+)(?![eE.]))\b/dg,
    captures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.integer.renpy*/ },
    },
};

export const keywords: TokenPattern = {
    // Fallback patterns for unmatched keywords
    patterns: [
        {
            debugName: "keywords.patterns![0]",

            // Control flow keywords
            token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.renpy*/
            match: /\b(?<!\.)(?:pass|return|pause)\b/g,
        },
        {
            debugName: "keywords.patterns![1]",

            // Control flow keywords with block
            contentToken: MetaTokenType.PythonLine, /*meta.embedded.line.python*/
            begin: /\b(?<!\.)(?:(if|elif|else)|(for|while))\b/dg,
            beginCaptures: {
                1: { token: KeywordTokenType.If, /*keyword.control.conditional.renpy*/ },
                2: { token: MetaTokenType.ControlFlowKeyword, /*keyword.control.flow.renpy*/ },
            },
            end: /:|$/dgm,
            endCaptures: {
                0: { token: CharacterTokenType.Colon, /*punctuation.section.block.begin.renpy*/ },
            },
            patterns: [
                expressions,
                pythonExpression,
            ]
        },
        {
            debugName: "keywords.patterns![2]",

            // Python statement keywords
            token: KeywordTokenType.OtherPython, /*keyword.other.python.renpy*/
            match: /\b(?<!\.)(define|default|early|hide|in|init|python)\b/g,
        },
        {
            debugName: "keywords.patterns![3]",

            // Renpy keywords
            token: KeywordTokenType.Other, /*keyword.other.renpy*/
            match: /\b(?<!\.)(?:camera|image|label|layeredimage|menu|nvl[ \t]+clear|play|queue|scene|screen|show|transform|translate|voice(?:[ \t]+sustain)?|window|frame)\b/g,
        },
        {
            debugName: "keywords.patterns![4]",

            // [TODO: Should probably only be a keyword in the expression] Renpy sub expression keywords
            token: KeywordTokenType.Other, /*keyword.other.renpy*/
            match: /\b(?<!\.)(?:set|expression|at|with|from)\b/g,
        },
    ]
};

export const comments: TokenPattern = {
    patterns: [
        {
            debugName: "comments.patterns![0]",

            token: MetaTokenType.Comment, /*comment.line.number-sign.renpy*/
            match: /(?<=^[ \t]*)(#[ \t]*(?:end)?region)\b.*$/dgm,
            captures: {
                1: { token: MetaTokenType.CommentRegionTag, /*punctuation.definition.tag.region*/ },
            },
        },
        {
            debugName: "comments.patterns![1]",

            token: MetaTokenType.Comment, /*comment.line.number-sign.renpy*/
            match: /(#)(.*)$/dgm,
            captures: {
                1: { token: CharacterTokenType.Hashtag, /*punctuation.definition.comment.renpy*/ },
                2: {
                    patterns: [
                        {
                            debugName: "comments.patterns![1].captures![2].patterns![0]",

                            // Code Tags
                            match: /(?:\b(NOTE|XXX|HACK|FIXME|BUG|TODO)\b)/dg,
                            captures: {
                                1: { token: MetaTokenType.CommentCodeTag, /*keyword.codetag.notation.renpy*/ },
                            },
                        },
                    ]
                },
            },
        },
    ]
};

export const escapedChar: TokenPattern = {
    debugName: "escapedChar",

    match: /(\\")|(\\')|(\\ )|(\\n)|(\\\\)|(\[\[)|({{)/dg,
    captures: {
        1: { token: EscapedCharacterTokenType.EscDoubleQuote, /*constant.character.escape.double-quote.python.renpy*/ },
        2: { token: EscapedCharacterTokenType.EscQuote, /*constant.character.escape.quote.python.renpy*/ },
        3: { token: EscapedCharacterTokenType.EscWhitespace, /*constant.character.escape.whitespace.python.renpy*/ },
        4: { token: EscapedCharacterTokenType.EscNewline, /*constant.character.escape.newline.python.renpy*/ },
        5: { token: EscapedCharacterTokenType.EscBackslash, /*constant.character.escape.backslash.python.renpy*/ },
        6: { token: EscapedCharacterTokenType.EscOpenBracket, /*constant.character.escape.open.bracket.python.renpy*/ },
        7: { token: EscapedCharacterTokenType.EscOpenSquareBracket, /*constant.character.escape.open.square-bracket.python.renpy*/ },
    },
};

export const constantPlaceholder: TokenPattern = {
    debugName: "constantPlaceholder",

    // Python value interpolation using [ ... ]
    token: MetaTokenType.ConstantCaps, /*constant.other.placeholder.tags.renpy*/
    match: /(\[)(.*?)(\])(?![^\[]*?\])/dg,
    captures: {
        1: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.renpy*/ },
        2: {
            token: MetaTokenType.PythonLine, /*meta.embedded.line.python*/
            patterns: [pythonExpression]
        },
        3: { token: MetaTokenType.Placeholder, /*constant.character.format.placeholder.other.renpy*/ },
    },
};

export const escapedUnicodeChar: TokenPattern = {
    debugName: "escapedUnicodeChar",

    match: /(\\U[0-9A-Fa-f]{8})|(\\u[0-9A-Fa-f]{4})|(\\N\{[a-zA-Z ]+\})/dg,
    captures: {
        1: { token: MetaTokenType.EscapeSequence, /*constant.character.unicode.16-bit-hex.python.renpy*/ },
        2: { token: MetaTokenType.EscapeSequence, /*constant.character.unicode.32-bit-hex.python.renpy*/ },
        3: { token: MetaTokenType.EscapeSequence, /*constant.character.unicode.name.python.renpy*/ },
    },
};

export const hexLiteral: TokenPattern = {
    // Note: This pattern has no end check. Only use as include pattern!
    patterns: [
        {
            debugName: "hexLiteral.patterns![0]",

            // rgb, rgba, rrggbb, rrggbbaa
            token: LiteralTokenType.Color, /*constant.color.renpy*/
            match: /#(?:[a-f0-9]{8}|[a-f0-9]{6}|[a-f0-9]{3,4})\b/gi,
        },
        {
            debugName: "hexLiteral.patterns![1]",

            token: MetaTokenType.Invalid, /*invalid.illegal.unexpected-number-of-hex-values.renpy*/
            match: /#[a-f0-9]+\b/gi,
        },
        {
            debugName: "hexLiteral.patterns![2]",

            token: LiteralTokenType.Color, /*constant.color.renpy*/
            match: /(?:#[a-f0-9]*)?(.+)/dgi,
            captures: {
                1: { token: MetaTokenType.Invalid, /*invalid.illegal.character-not-allowed-here.renpy*/ },
            },
        },
    ]
};

export const stringsInterior: TokenPattern = {
    patterns: [
        newLine,
        escapedChar,
        constantPlaceholder,
    ]
};

export const stringTags: TokenPattern = {
    patterns: [
        {
            debugName: "stringTags.patterns![0]",

            // Valid tags without params (self-closing)
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            match: /({)\s*(nw|done|fast|p|w|clear)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![1]",

            // Valid tags with numeric params (self-closing)
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            match: /({)\s*(p|w)(=)(\+?)(\d*(?:.\d+)?)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: OperatorTokenType.Plus, /*keyword.operator.arithmetic.plus.renpy*/ },
                5: { token: LiteralTokenType.Float, /*support.constant.property-value.renpy constant.numeric.float.renpy*/ },
                6: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![2]",

            // Valid tags with numeric params (self-closing)
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            match: /({)\s*(v?space)(=)(\+?)(\d+)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: OperatorTokenType.Plus, /*keyword.operator.arithmetic.plus.renpy*/ },
                5: { token: LiteralTokenType.Integer, /*support.constant.property-value.renpy constant.numeric.integer.renpy*/ },
                6: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![3]",

            // Comment tag (self-closing)
            token: MetaTokenType.StringTag, /*meta.string.tag.comment.self-closing.renpy*/
            match: /({)\s*(#)\s*(.*?)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: CharacterTokenType.Hashtag, /*comment.line.number-sign.renpy punctuation.definition.comment.renpy*/ },
                3: { token: MetaTokenType.Comment, /*comment.line.number-sign.renpy*/ },
                4: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![4]",

            // Valid tags with file param
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            match: /({)\s*(image)(=)([\w.]+)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: LiteralTokenType.String, /*support.constant.property-value.renpy string.unquoted.renpy*/ },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![5]",

            // Valid tags without params (close required)
            contentToken: MetaTokenType.TaggedString, /*renpy.meta.${2:/downcase} meta.tagged.string.renpy*/
            begin: /({)\s*(u|i|b|s|plain|alt|noalt|art|rb|rt)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTags.patterns![6]",

            // Valid tags with numeric params (close required)
            contentToken: MetaTokenType.TaggedString, /*renpy.meta.${2:/downcase} meta.tagged.string.renpy*/
            begin: /({)\s*(alpha|cps|k)(=)(?:(\*)|(\-)|(\+))?(\d*(?:.\d+)?)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: OperatorTokenType.Multiply, /*keyword.operator.arithmetic.Multiply.renpy*/ },
                5: { token: OperatorTokenType.Minus, /*keyword.operator.arithmetic.Minus.renpy*/ },
                6: { token: OperatorTokenType.Plus, /*keyword.operator.arithmetic.Plus.renpy*/ },
                7: { token: MetaTokenType.ConstantNumeric, /*support.constant.property-value.renpy constant.numeric.renpy*/ },
                8: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTags.patterns![7]",

            // Valid tags with numeric params (close required)
            contentToken: MetaTokenType.TaggedString, /*renpy.meta.${2:/downcase} meta.tagged.string.renpy*/
            begin: /({)\s*(size)(=)([\-+]?)(\d+)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: MetaTokenType.ArithmeticOperator, /*keyword.operator.arithmetic.renpy*/ },
                5: { token: LiteralTokenType.Integer, /*support.constant.property-value.renpy constant.numeric.integer.renpy*/ },
                6: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTags.patterns![8]",

            // Valid tags with file param (close required)
            token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.self-closing.renpy*/
            begin: /({)\s*(font)(=)([\w.]+)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: LiteralTokenType.String, /*support.constant.property-value.renpy string.unquoted.renpy*/ },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTags.patterns![9]",

            // Color tag
            contentToken: MetaTokenType.TaggedString, /*renpy.meta.${2:/downcase}.${4:/downcase} meta.tagged.string.renpy*/
            begin: /({)\s*(color|outlinecolor)(=)(#?[a-zA-Z0-9]+)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: {
                    token: LiteralTokenType.Color, /*constant.color.renpy*/
                    patterns: [hexLiteral]
                },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTags.patterns![10]",

            // a tag
            contentToken: MetaTokenType.TaggedString, /*renpy.meta.${2:/downcase} meta.tagged.string.renpy*/
            begin: /({)\s*(a)(=)(.*?)\s*(})/dg,
            beginCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: {
                    token: LiteralTokenType.String, /*support.constant.property-value.renpy string.unquoted.renpy*/
                    patterns: [
                    ]
                },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            end: /({\/)\s*(\2)\s*(})/dg,
            endCaptures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "stringTags.patterns![11]",

            // Unknown tag (Single line support only cus \R does not work) (Since we don't know if a tag is self closing, we can't assume that an end pattern exists)
            match: /({)[ \t]*(\w+)\b(?:(=)(.*?))?\s*(})((?:.|\R)+?)\s*({\/)\s*(\2)\s*(})/dg,
            captures: {
                1: { token: CharacterTokenType.OpenBracket, /*meta.string.tag.${2:/downcase}.start.renpy punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*meta.string.tag.${2:/downcase}.start.renpy renpy.meta.u entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*meta.string.tag.${2:/downcase}.start.renpy punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: { token: MetaTokenType.ConstantCaps, /*meta.string.tag.${2:/downcase}.start.renpy constant.other.placeholder.tags.renpy*/ },
                5: { token: CharacterTokenType.CloseBracket, /*meta.string.tag.${2:/downcase}.start.renpy punctuation.definition.tag.end.renpy*/ },
                6: { token: MetaTokenType.TaggedString, /*renpy.meta.string.tag.custom.${2:/downcase } meta.tagged.string.renpy*/
                    patterns: [stringsInterior]
                },
                7: { token: CharacterTokenType.OpenBracket, /*meta.string.tag.${2:/downcase}.end.renpy punctuation.definition.tag.begin.renpy*/ },
                8: { token: EntityTokenType.TagName, /*meta.string.tag.${2:/downcase}.end.renpy renpy.meta.u entity.name.tag.${2:/downcase}.renpy*/ },
                9: { token: CharacterTokenType.CloseBracket, /*meta.string.tag.${2:/downcase}.end.renpy punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![12]",

            // Unknown tag start
            match: /({)\s*(\w*)(?:(=)(.*?))?\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.start.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*renpy.meta.u entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: OperatorTokenType.Assignment, /*punctuation.separator.key-value.renpy keyword.operator.assignment.renpy*/ },
                4: {
                    token: MetaTokenType.ConstantCaps, /*support.constant.property-value.renpy constant.other.placeholder.tags.renpy*/
                    patterns: [
                    ]
                },
                5: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
        {
            debugName: "stringTags.patterns![13]",

            // Unknown tag end
            match: /({\/)\s*(\w*?)\b\s*(})/dg,
            captures: {
                0: { token: MetaTokenType.StringTag, /*meta.string.tag.${2:/downcase}.end.renpy*/ },
                1: { token: CharacterTokenType.OpenBracket, /*punctuation.definition.tag.begin.renpy*/ },
                2: { token: EntityTokenType.TagName, /*renpy.meta.u entity.name.tag.${2:/downcase}.renpy*/ },
                3: { token: CharacterTokenType.CloseBracket, /*punctuation.definition.tag.end.renpy*/ },
            },
        },
    ]
};

export const strings: TokenPattern = {
    debugName: "strings",

    token: LiteralTokenType.String, /*string.quoted.renpy*/
    begin: /"""|"|'''|'|```|`/dg,
    beginCaptures: {
        0: { token: MetaTokenType.StringBegin, /*punctuation.definition.string.begin.renpy*/ },
    },
    end: /(?<![^\\]\\)(((?<=\0)\0)|\0)/dg,
    endCaptures: {
        1: { token: MetaTokenType.StringEnd, /*punctuation.definition.string.end.renpy*/ },
        2: { token: MetaTokenType.EmptyString, /*meta.empty-string.renpy*/ },
    },
    patterns: [stringsInterior]
};

export const pythonStatements: TokenPattern = {
    patterns: [
        {
            debugName: "pythonStatements.patterns![0]",

            match: /^([ \t]*)(init)[ \t]+(offset)[ \t]*(=)[ \t]*(-)?([^#]*?)$/dgm,
            captures: {
                1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.renpy*/ },
                2: { token: KeywordTokenType.Init, /*keyword.init.renpy*/ },
                3: { token: KeywordTokenType.Offset, /*keyword.offset.renpy*/ },
                4: { token: OperatorTokenType.Assignment, /*keyword.operator.assignment.renpy*/ },
                5: { token: OperatorTokenType.Minus, /*keyword.operator.arithmetic.minus.renpy*/ },
                6: {
                    patterns: [
                        numInt,
                        invalidToken,
                    ]
                },
            },
        },
        {
            debugName: "pythonStatements.patterns![1]",

            // Renpy python block
            contentToken: MetaTokenType.PythonBlock, /*meta.embedded.block.python*/
            begin: /^([ \t]+)?(?:(init)(?:[ \t]+(-)?(\d+))?[ \t]+)?(python)[ \t]*(.*)?(:)/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.embedded.leading.renpy*/ },
                2: { token: KeywordTokenType.Init, /*keyword.init.renpy*/ },
                3: { token: OperatorTokenType.Minus, /*keyword.operator.arithmetic.minus.renpy*/ },
                4: { token: LiteralTokenType.Integer, /*constant.numeric.integer.renpy*/ },
                5: { token: KeywordTokenType.Python, /*keyword.python.renpy*/ },
                6: {
                    token: MetaTokenType.Arguments, /*meta.python.block.arguments.renpy*/
                    patterns: [
                        {
                            debugName: "pythonStatements.patterns![1].beginCaptures![6].patterns![0]",

                            // in statement
                            match: /(?:\s*(in)\s*([a-zA-Z_]\w*)\b)/dg,
                            captures: {
                                1: { token: OperatorTokenType.In, /*keyword.operator.in.renpy*/ },
                                2: { token: EntityTokenType.NamespaceName, /*entity.name.namespace*/ },
                            },
                        },
                        {
                            debugName: "pythonStatements.patterns![1].beginCaptures![6].patterns![1]",

                            // keywords
                            match: /\b(hide)|(early)|(in)\b/dg,
                            captures: {
                                1: { token: KeywordTokenType.Hide, /*keyword.hide.renpy*/ },
                                2: { token: KeywordTokenType.Early, /*keyword.early.renpy*/ },
                                3: { token: OperatorTokenType.In, /*keyword.operator.in.renpy*/ },
                            },
                        },
                    ]
                },
                7: { token: CharacterTokenType.Colon, /*punctuation.section.python.begin.renpy*/ },
            },
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: [python]
        },
        {
            debugName: "pythonStatements.patterns![2]",

            // Match begin and end of python one line statements
            contentToken: MetaTokenType.PythonLine, /*meta.embedded.line.python*/
            begin: /(?<=^[ \t]*)(?:(\$)|(define)|(default))(?=[ \t])/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.DollarSign, /*keyword.dollar.sign.renpy*/ },
                2: { token: KeywordTokenType.Define, /*keyword.define.renpy*/ },
                3: { token: KeywordTokenType.Default, /*keyword.default.renpy*/ },
            },
            end: /$/gm,
            patterns: [
                {
                    debugName: "pythonStatements.patterns![2].patterns![0]",

                    // Type the first name as a variable (Probably not needed, but python doesn't seem to catch it)
                    token: EntityTokenType.VariableName, /*variable.other.renpy*/
                    match: /(?<!\.)\b([a-zA-Z_]\w*)(?=\s=\s)/g,
                },
                strings,
                pythonExpression,
                whitespace,
            ]
        },
    ]
};

export const sayStatements: TokenPattern = {
    patterns: [
        {
            debugName: "sayStatements.patterns![0]",

            token: MetaTokenType.SayStatement, /*meta.say.statement.renpy*/
            contentToken: LiteralTokenType.String, /*renpy.meta.say.$1 string.quoted.renpy*/
            begin: /(?<=^[ \t]+)(?:([a-zA-Z_]\w*)\b|"([a-zA-Z_]\w*)\b")((?:[ \t]+(?:@|\w+))*)?[ \t]*("""|"|'''|'|```|`)/dgm,
            beginCaptures: {
                1: {
                    token: EntityTokenType.VariableName, /*renpy.meta.character.$1 variable.other.renpy*/
                    patterns: [
                        {
                            debugName: "sayStatements.patterns![0].beginCaptures![1].patterns![0]",

                            token: KeywordTokenType.Extend, /*keyword.extend.renpy*/
                            match: /extend/g,
                        },
                        {
                            debugName: "sayStatements.patterns![0].beginCaptures![1].patterns![1]",

                            token: KeywordTokenType.Voice, /*keyword.voice.renpy*/
                            match: /voice/g,
                        },
                        {
                            debugName: "sayStatements.patterns![0].beginCaptures![1].patterns![2]",

                            // Match special characters
                            token: EntityTokenType.VariableName, /*variable.other.constant.renpy*/
                            match: /adv|nvl|narrator|name_only|centered|vcentered/g,
                        },
                    ]
                },
                2: { token: MetaTokenType.CharacterNameString, /*meta.string.character.$2.renpy*/ },
                3: {
                    token: MetaTokenType.Arguments, /*meta.arguments.renpy*/
                    patterns: [
                        {
                            debugName: "sayStatements.patterns![0].beginCaptures![3].patterns![0]",

                            token: KeywordTokenType.At, /*keyword.at.renpy*/
                            match: /@/g,
                        },
                    ]
                },
                4: { token: MetaTokenType.StringBegin, /*string.quoted.renpy punctuation.definition.string.begin.renpy*/ },
            },
            end: /(?<![^\\]\\)(((?<=\4)\4)|\4)[ \t]*(\(.*?\)(?![^\(]*?\)))?/dg,
            endCaptures: {
                1: { token: MetaTokenType.StringEnd, /*string.quoted.renpy punctuation.definition.string.end.renpy*/ },
                2: { token: MetaTokenType.EmptyString, /*meta.empty-string.renpy*/ },
                3: { patterns: [pythonFunctionArguments] },
            },
            patterns: [stringsInterior]
        },
        {
            debugName: "sayStatements.patterns![1]",

            token: MetaTokenType.SayNarrator, /*meta.say.narrator.renpy*/
            contentToken: LiteralTokenType.String, /*string.quoted.narrator.renpy*/
            begin: /(?<=^[ \t]+)("""|"|'''|'|```|`)/dgm,
            beginCaptures: {
                1: { token: MetaTokenType.StringBegin, /*string.quoted.renpy punctuation.definition.string.begin.renpy*/ },
            },
            end: /(?<![^\\]\\)(((?<=\1)\1)|\1)[ \t]*(\(.*?\)(?![^\(]*?\)))?/dg,
            endCaptures: {
                1: { token: MetaTokenType.StringEnd, /*string.quoted.renpy punctuation.definition.string.end.renpy*/ },
                2: { token: MetaTokenType.EmptyString, /*meta.empty-string.renpy*/ },
                3: { patterns: [pythonFunctionArguments] },
            },
            patterns: [stringsInterior]
        },
    ]
};

export const pause: TokenPattern = {
    debugName: "pause",

    match: /^([ \t]+)(pause)\b([ \t]+[^#\n]*)?$/dgm,
    captures: {
        1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.renpy*/ },
        2: { token: KeywordTokenType.Pause, /*keyword.control.flow.pause.renpy*/ },
        3: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.renpy*/ },
        4: {
            token: MetaTokenType.Arguments, /*meta.pause.arguments.renpy*/
            patterns: [
                whitespace,
                numFloat,
                numInt,
                invalidToken,
            ]
        },
    },
};

export const transform: TokenPattern = {
    debugName: "transform",

    begin: /^([ \t]+)?(transform)\b[ \t]*(.*)?(:)/dgm,
    beginCaptures: {
        1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.renpy*/ },
        2: { token: KeywordTokenType.Transform, /*keyword.transform.renpy*/ },
        3: {
            patterns: [
                {
                    debugName: "transform.beginCaptures![3].patterns![0]",

                    token: EntityTokenType.VariableName, /*variable.name.transform.renpy*/
                    match: /\b([[:alpha:]_]\w*)\b/g,
                },
            ]
        },
        4: { token: CharacterTokenType.Colon, /*punctuation.section.atl.begin.renpy*/ },
    },
    end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
    patterns: [atl]
};

export const atStatement: TokenPattern = {
    debugName: "atStatement",

    token: MetaTokenType.AtStatement, /*meta.at.statement.renpy*/
    match: /\b(at)\b[ \t]*(.+)?/dg,
    captures: {
        1: { token: KeywordTokenType.At, /*keyword.at.renpy*/ },
        2: {
            token: MetaTokenType.AtParameters, /*meta.at.parameters.renpy*/
            patterns: [statements]
        },
    },
};

export const asStatement: TokenPattern = {
    debugName: "asStatement",

    token: MetaTokenType.AsStatement, /*meta.as.statement.renpy*/
    match: /\b(as)\b[ \t]*(.+)?/dg,
    captures: {
        1: { token: KeywordTokenType.As, /*keyword.as.renpy*/ },
        2: {
            token: MetaTokenType.AsParameters, /*meta.as.parameters.renpy*/
            patterns: [statements]
        },
    },
};

export const withStatement: TokenPattern = {
    debugName: "withStatement",

    token: MetaTokenType.WithStatement, /*meta.with.statement.renpy*/
    match: /\b(with)\b[ \t]*(.+)?/dg,
    captures: {
        1: { token: KeywordTokenType.With, /*keyword.with.renpy*/ },
        2: {
            token: MetaTokenType.WithParameters, /*meta.with.parameters.renpy*/
            patterns: [expressions]
        },
    },
};

export const behind: TokenPattern = {
    debugName: "behind",

    token: MetaTokenType.BehindStatement, /*meta.behind.statement.renpy*/
    match: /\b(behind)\b[ \t]*(.+)?/dg,
    captures: {
        1: { token: KeywordTokenType.Behind, /*keyword.behind.renpy*/ },
        2: {
            token: MetaTokenType.BehindParameters, /*meta.behind.parameters.renpy*/
            patterns: [statements]
        },
    },
};

export const onlayer: TokenPattern = {
    debugName: "onlayer",

    token: MetaTokenType.OnlayerStatement, /*meta.onlayer.statement.renpy*/
    match: /\b(onlayer)\b[ \t]*(.+)?/dg,
    captures: {
        1: { token: KeywordTokenType.Onlayer, /*keyword.onlayer.renpy*/ },
        2: {
            token: MetaTokenType.OnlayerParameters, /*meta.onlayer.parameters.renpy*/
            patterns: [statements]
        },
    },
};

export const zorder: TokenPattern = {
    debugName: "zorder",

    token: MetaTokenType.ZorderStatement, /*meta.zorder.statement.renpy*/
    match: /\b(zorder)\b[ \t]*(.+)?/dg,
    captures: {
        1: { token: KeywordTokenType.Zorder, /*keyword.zorder.renpy*/ },
        2: {
            token: MetaTokenType.ZorderParameters, /*meta.zorder.parameters.renpy*/
            patterns: [statements]
        },
    },
};

export const image: TokenPattern = {
    patterns: [
        {
            debugName: "image.patterns![0]",

            token: MetaTokenType.ImageStatement, /*meta.image.statement.renpy*/
            contentToken: MetaTokenType.ATLBlock, /*meta.atl-block.renpy*/
            begin: /^([ \t]+)?(image)\b[ \t]*([a-zA-Z_0-9 ]*)(:)/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.renpy*/ },
                2: { token: KeywordTokenType.Image, /*keyword.image.renpy*/ },
                3: { token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/ },
                4: { token: CharacterTokenType.Colon, /*punctuation.section.atl.begin.renpy*/ },
            },
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: [atl]
        },
        {
            debugName: "image.patterns![1]",

            token: MetaTokenType.ImageStatement, /*meta.image.statement.renpy*/
            begin: /(?<=^[ \t]*)(image)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Image, /*keyword.image.renpy*/ },
            },
            end: /(?!\G)(?=\b(at)\b|#|=)|$/gm,
            patterns: [
                strings,
                {
                    debugName: "image.patterns![1].patterns![1]",

                    token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/
                    match: /\b(?:[a-zA-Z_0-9]+)\b[ \t]*/g,
                },
            ]
        },
        atStatement,
        withStatement,
    ]
};

export const show: TokenPattern = {
    patterns: [
        {
            debugName: "show.patterns![0]",

            token: MetaTokenType.ShowStatement, /*meta.show.statement.renpy*/
            contentToken: MetaTokenType.ATLBlock, /*meta.atl-block.renpy*/
            begin: /^([ \t]+)?(show)\b[ \t]*([a-zA-Z_0-9 ]*)(:)/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.renpy*/ },
                2: { token: KeywordTokenType.Show, /*keyword.show.renpy*/ },
                3: { token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/ },
                4: { token: CharacterTokenType.Colon, /*punctuation.section.atl.begin.renpy*/ },
            },
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: [atl]
        },
        {
            debugName: "show.patterns![1]",

            token: MetaTokenType.ShowStatement, /*meta.show.statement.renpy*/
            begin: /(?<=^[ \t]*)(show)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Show, /*keyword.show.renpy*/ },
            },
            end: /(?=\b(at|as|behind|onlayer|expression|with|zorder)\b|#)|$/gm,
            patterns: [
                strings,
                {
                    debugName: "show.patterns![1].patterns![1]",

                    token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/
                    match: /\b(?:[a-zA-Z_0-9]+)\b[ \t]*/g,
                },
            ]
        },
        atStatement,
        asStatement,
        withStatement,
        behind,
        onlayer,
        zorder,
    ]
};

export const scene: TokenPattern = {
    patterns: [
        {
            debugName: "scene.patterns![0]",

            token: MetaTokenType.SceneStatement, /*meta.scene.statement.renpy*/
            contentToken: MetaTokenType.ATLBlock, /*meta.atl-block.renpy*/
            begin: /^([ \t]+)?(scene)\b[ \t]*([a-zA-Z_0-9 ]*)(:)/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.renpy*/ },
                2: { token: KeywordTokenType.Scene, /*keyword.scene.renpy*/ },
                3: { token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/ },
                4: { token: CharacterTokenType.Colon, /*punctuation.section.atl.begin.renpy*/ },
            },
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: [atl]
        },
        {
            debugName: "scene.patterns![1]",

            token: MetaTokenType.SceneStatement, /*meta.scene.statement.renpy*/
            begin: /(?<=^[ \t]*)(scene)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Scene, /*keyword.scene.renpy*/ },
            },
            end: /(?=\b(at|as|behind|onlayer|expression|with|zorder)\b|#)|$/gm,
            patterns: [
                strings,
                {
                    debugName: "scene.patterns![1].patterns![1]",

                    token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/
                    match: /\b(?:[a-zA-Z_0-9]+)\b[ \t]*/g,
                },
            ]
        },
        atStatement,
        asStatement,
        withStatement,
        behind,
        onlayer,
        zorder,
    ]
};

export const camera: TokenPattern = {
    patterns: [
        {
            debugName: "camera.patterns![0]",

            token: MetaTokenType.CameraStatement, /*meta.camera.statement.renpy*/
            contentToken: MetaTokenType.ATLBlock, /*meta.atl-block.renpy*/
            begin: /^([ \t]+)?(camera)\b[ \t]*(:)/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.renpy*/ },
                2: { token: KeywordTokenType.Camera, /*keyword.camera.renpy*/ },
                3: { token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/ },
                4: { token: CharacterTokenType.Colon, /*punctuation.section.atl.begin.renpy*/ },
            },
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: [atl]
        },
        {
            debugName: "camera.patterns![1]",

            token: MetaTokenType.CameraStatement, /*meta.camera.statement.renpy*/
            begin: /(?<=^[ \t]*)(camera)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Camera, /*keyword.camera.renpy*/ },
            },
            end: /(?=\b(at|with)\b|#)|$/gm,
            patterns: [
                {
                    debugName: "camera.patterns![1].patterns![0]",

                    token: EntityTokenType.ImageName, /*entity.name.type.image.renpy*/
                    match: /\b(?:[a-zA-Z_0-9]+)\b[ \t]*/g,
                },
            ]
        },
        atStatement,
        withStatement,
    ]
};

export const styleOld: TokenPattern = {
    debugName: "styleOld",

    match: /^\s*(style)\s+([a-zA-Z_][a-zA-Z_0-9]*)/dgm,
    captures: {
        1: { token: KeywordTokenType.Python, /*keyword.python.renpy*/ },
        2: { token: EntityTokenType.TagName, /*entity.name.tag.python.renpy.style.renpy*/ },
    },
};

export const useOld: TokenPattern = {
    debugName: "useOld",

    match: /^\s*(use)\s+([a-zA-Z_][a-zA-Z_0-9]*)/dgm,
    captures: {
        1: { token: KeywordTokenType.Python, /*keyword.python.renpy*/ },
        2: { token: EntityTokenType.ClassName, /*entity.name.class.python.renpy.screen.renpy*/ },
    },
};

export const builtinScreens: TokenPattern = {
    debugName: "builtinScreens",

    // TODO: Should combine this with builtin-labels
    token: EntityTokenType.FunctionName, /*support.function.builtin.renpy*/
    match: /(?<!\.)\b(?:start|quit|after_load|splashscreen|before_main_menu|main_menu|after_warp|hide_windows)\b/g,
};

export const screenLanguage: TokenPattern = {
    // https://www.renpy.org/doc/html/screens.html#screen-language
    patterns: [
    ]
};

export const screenDefName: TokenPattern = {
    // TODO: Should combine this with label-def-name
    patterns: [
        pythonBuiltinPossibleCallables,
        builtinScreens,
        {
            debugName: "screenDefName.patterns![2]",

            match: /(?<=^|[ \t])(\b(?:[a-zA-Z_]\w*)\b)?(\.)?(\b(?:[a-zA-Z_]\w*)\b)/dgm,
            captures: {
                1: { token: EntityTokenType.FunctionName, /*entity.name.function.renpy*/ },
                2: { token: CharacterTokenType.Period, /*punctuation.separator.period.renpy*/ },
                3: { token: EntityTokenType.FunctionName, /*entity.name.function.renpy*/ },
            },
        },
    ]
};

export const screenSimpleExpression: TokenPattern = {
    patterns: [
        expressions,
        pythonLiteral,
        pythonMemberAccess,
        pythonIllegalOperator,
        pythonOperator,
        pythonCurlyBraces,
        pythonItemAccess,
        pythonList,
        pythonOddFunctionCall,
        pythonRoundBraces,
        pythonFunctionCall,
        pythonBuiltinFunctions,
        pythonBuiltinTypes,
        pythonBuiltinExceptions,
        pythonMagicNames,
        pythonSpecialNames,
        pythonIllegalNames,
        pythonSpecialVariables,
        pythonEllipsis,
        pythonPunctuation,
        pythonLineContinuation,
    ]
};

export const screenKeywords: TokenPattern = {
    // https://www.renpy.org/doc/html/screens.html#screen-statement
    patterns: [
        {
            debugName: "screenKeywords.patterns![0]",

            contentToken: MetaTokenType.ScreenSensitive, /*meta.screen.sensitive.renpy*/
            begin: /(?<=^[ \t]*)(sensitive)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Sensitive, /*keyword.sensitive.renpy*/ },
            },
            end: /$/gm,
            patterns: [screenSimpleExpression]
        },
        {
            debugName: "screenKeywords.patterns![1]",

            token: KeywordTokenType.Other, /*keyword.other.renpy*/
            match: /\b(?<!\.)(?:modal|sensitive|tag|zorder|variant|layer|roll_forward|text)\b/g,
        },
        {
            debugName: "screenKeywords.patterns![2]",

            token: KeywordTokenType.Other, /*keyword.other.renpy*/
            match: /\b(?<!\.)(?:style|style_group|style_prefix)\b/g,
        },
        {
            debugName: "screenKeywords.patterns![3]",

            token: KeywordTokenType.Other, /*keyword.other.renpy*/
            match: /\b(?<!\.)(?:has|vbox|label|add|xfill)\b/g,
        },
    ]
};

export const screenFrame: TokenPattern = {
    debugName: "screenFrame",

    contentToken: MetaTokenType.ScreenFrame, /*meta.screen.frame.renpy*/
    begin: /^([ \t]+)?(frame)\b[ \t]*(:)/dgm,
    beginCaptures: {
        1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.block.renpy*/ },
        2: { token: KeywordTokenType.Frame, /*keyword.frame.renpy*/ },
        3: { token: CharacterTokenType.Colon, /*punctuation.section.block.begin.renpy*/ },
    },
    end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
    patterns: [screenLanguage]
};

export const screenWindow: TokenPattern = {
    debugName: "screenWindow",

    contentToken: MetaTokenType.ScreenWindow, /*meta.screen.window.renpy*/
    begin: /^([ \t]+)?(window)\b[ \t]*(:)/dgm,
    beginCaptures: {
        1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.block.renpy*/ },
        2: { token: KeywordTokenType.Window, /*keyword.window.renpy*/ },
        3: { token: CharacterTokenType.Colon, /*punctuation.section.block.begin.renpy*/ },
    },
    end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
    patterns: [screenLanguage]
};

export const screenText: TokenPattern = {
    debugName: "screenText",

    contentToken: MetaTokenType.ScreenText, /*meta.screen.text.renpy*/
    begin: /^([ \t]+)?(text)\b[ \t]*(:)/dgm,
    beginCaptures: {
        1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.block.renpy*/ },
        2: { token: KeywordTokenType.Text, /*keyword.text.renpy*/ },
        3: { token: CharacterTokenType.Colon, /*punctuation.section.block.begin.renpy*/ },
    },
    end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
    patterns: [
        {
            debugName: "screenText.patterns![0]",

            token: MetaTokenType.ScreenText, /*meta.screen.text.renpy*/
            contentToken: MetaTokenType.ATLBlock, /*meta.atl-block.renpy*/
            begin: /^([ \t]+)?(text)\b[ \t]*([a-zA-Z_0-9 ]*)(:)/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.renpy*/ },
                2: { token: KeywordTokenType.Text, /*keyword.text.renpy*/ },
                3: { token: EntityTokenType.TextName, /*entity.name.type.text.renpy*/ },
                4: { token: CharacterTokenType.Colon, /*punctuation.section.atl.begin.renpy*/ },
            },
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: [atl]
        },
        {
            debugName: "screenText.patterns![1]",

            token: MetaTokenType.ScreenText, /*meta.screen.text.renpy*/
            begin: /(?<=^[ \t]*)(text)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Text, /*keyword.text.renpy*/ },
            },
            end: /(?!\G)(?=\b(at)\b|#|=)|$/gm,
            patterns: [
                strings,
                {
                    debugName: "screenText.patterns![1].patterns![1]",

                    token: EntityTokenType.TextName, /*entity.name.type.text.renpy*/
                    match: /\b(?:[a-zA-Z_0-9]+)\b[ \t]*/g,
                },
            ]
        },
        atStatement,
    ]
};

export const screen: TokenPattern = {
    patterns: [
        {
            debugName: "screen.patterns![0]",

            // See https://www.renpy.org/doc/html/screens.html
            contentToken: MetaTokenType.ScreenBlock, /*meta.screen.block.renpy*/
            begin: /^([ \t]+)?(screen)\b[ \t]*(.*?)(:)/dgm,
            beginCaptures: {
                1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.leading.block.renpy*/ },
                2: { token: KeywordTokenType.Def, /*storage.type.function.renpy*/ },
                3: {
                    patterns: [
                        screenDefName,
                        pythonParameters,
                        invalidToken,
                    ]
                },
                4: { token: CharacterTokenType.Colon, /*punctuation.section.block.begin.renpy*/ },
            },
            end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
            patterns: [screenLanguage]
        },
    ]
};

export const builtinLabels: TokenPattern = {
    debugName: "builtinLabels",

    token: EntityTokenType.FunctionName, /*support.function.builtin.renpy*/
    match: /(?<!\.)\b(?:start|quit|after_load|splashscreen|before_main_menu|main_menu|after_warp|hide_windows)\b/g,
};

export const labelName: TokenPattern = {
    patterns: [
        pythonBuiltinPossibleCallables,
        builtinLabels,
        {
            debugName: "labelName.patterns![2]",

            token: EntityTokenType.FunctionName, /*entity.name.function.renpy*/
            match: /\b(?:[a-zA-Z_]\w*)\b/g,
        },
    ]
};

export const labelCall: TokenPattern = {
    debugName: "labelCall",

    // Note: label params are only allowed at the end of the access expression
    token: MetaTokenType.LabelCall, /*meta.function-call.label.renpy*/
    begin: /\b(?=([a-zA-Z_]\w*)\s*(\())/g,
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.renpy*/ },
    },
    patterns: [
        pythonSpecialVariables,
        labelName,
        pythonFunctionArguments,
    ]
};

export const labelAccess: TokenPattern = {
    debugName: "labelAccess",

    // Note: Labels can't be nested twice in a row!
    token: MetaTokenType.LabelAccess, /*meta.member.access.label.renpy*/
    begin: /(\.)\s*(?!\.)/dg,
    beginCaptures: {
        1: { token: CharacterTokenType.Period, /*punctuation.separator.period.renpy*/ },
    },
    end: /(?<=\S)(?=\W)|(^|(?<=\s))(?=[^\\\w\s])|$/gm,
    patterns: [
        labelCall,
        labelName,
    ]
};

export const labelDefName: TokenPattern = {
    // Note: Labels can't be nested twice in a row!
    patterns: [
        pythonBuiltinPossibleCallables,
        builtinLabels,
        {
            debugName: "labelDefName.patterns![2]",

            match: /(?<=^|[ \t])(\b(?:[a-zA-Z_]\w*)\b)?(\.)?(\b(?:[a-zA-Z_]\w*)\b)/dgm,
            captures: {
                1: { token: EntityTokenType.FunctionName, /*entity.name.function.renpy*/ },
                2: { token: CharacterTokenType.Period, /*punctuation.separator.period.renpy*/ },
                3: { token: EntityTokenType.FunctionName, /*entity.name.function.renpy*/ },
            },
        },
    ]
};

export const label: TokenPattern = {
    debugName: "label",

    token: MetaTokenType.LabelStatement, /*meta.label.statement.renpy*/
    match: /(?<=^[ \t]*)(label)\b[ \t]*(.*?)(?:[ \t]*(hide))?(:)/dgm,
    captures: {
        1: { token: KeywordTokenType.Label, /*storage.type.function.label.renpy*/ },
        2: {
            patterns: [
                labelDefName,
                pythonParameters,
                invalidToken,
            ]
        },
        3: { token: KeywordTokenType.Hide, /*keyword.hide.renpy*/ },
        4: { token: CharacterTokenType.Colon, /*punctuation.section.label.begin.renpy*/ },
    },
};

export const returnStatements: TokenPattern = {
    debugName: "returnStatements",

    begin: /(?<=^[ \t]+)(return)\b[ \t]*/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Return, /*keyword.control.flow.return.renpy*/ },
    },
    end: /$/gm,
    patterns: [
        expressions,
        pythonExpression,
    ]
};

export const callJumpExpression: TokenPattern = {
    debugName: "callJumpExpression",

    begin: /\b(?<!\.)(expression)\b/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.Expression, /*keyword.expression.renpy*/ },
    },
    end: /(?=\b(?<!\.)(?:pass|from)\b)|$/gm,
    patterns: [
        expressions,
        pythonExpression,
    ]
};

export const jump: TokenPattern = {
    debugName: "jump",

    token: MetaTokenType.JumpStatement, /*meta.jump.statement.renpy*/
    begin: /(?<=^[ \t]+)(jump)\b[ \t]*/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Jump, /*keyword.control.flow.jump.renpy*/ },
    },
    end: /(?!\G)[ \t]*(.*?)?(?=#|$)/dgm,
    endCaptures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.renpy*/ },
    },
    patterns: [
        callJumpExpression,
        {
            debugName: "jump.patterns![1]",

            // Label expression
            begin: /\G/g,
            end: /(?!\G)(?![ \t]*\.[ \t]*)/g,
            patterns: [
                labelAccess,
                labelName,
            ]
        },
    ]
};

export const callPass: TokenPattern = {
    debugName: "callPass",

    begin: /\b(?<!\.)(pass)\b[ \t]*(?=\()/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.Pass, /*keyword.pass.renpy*/ },
    },
    end: /(\))/dg,
    endCaptures: {
        1: { token: CharacterTokenType.CloseParentheses, /*punctuation.definition.arguments.end.renpy*/ },
    },
    patterns: [pythonFunctionArguments]
};

export const callFrom: TokenPattern = {
    debugName: "callFrom",

    begin: /\b(?<!\.)(from)\b[ \t]*/dg,
    beginCaptures: {
        1: { token: KeywordTokenType.From, /*keyword.control.flow.from.renpy*/ },
    },
    end: /(?=\W|$)/gm,
    patterns: [labelName]
};

export const call: TokenPattern = {
    debugName: "call",

    token: MetaTokenType.CallStatement, /*meta.call.statement.renpy*/
    begin: /(?<=^[ \t]+)(call)\b[ \t]*/dgm,
    beginCaptures: {
        1: { token: KeywordTokenType.Call, /*keyword.control.flow.call.renpy*/ },
    },
    end: /(?=#|$)/dgm,
    endCaptures: {
        1: { token: MetaTokenType.Invalid, /*invalid.illegal.renpy*/ },
    },
    patterns: [
        callJumpExpression,
        callPass,
        {
            debugName: "call.patterns![2]",

            // Label expression
            begin: /\G/g,
            end: /(?!\G)(?![ \t]*\.[ \t]*)/g,
            patterns: [
                labelCall,
                labelAccess,
                labelName,
            ]
        },
        callFrom,
    ]
};

export const menuOption: TokenPattern = {
    debugName: "menuOption",

    contentToken: MetaTokenType.MenuOptionBlock, /*meta.menu-option.block.renpy*/
    begin: /^([ \t]+)?((?:".*")|(?:'.*')|(?:""".*"""))[ \t]*(.+)?(:)/dgm,
    beginCaptures: {
        1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.menu-option.leading.renpy*/ },
        2: {
            token: MetaTokenType.MenuOption, /*meta.menu-option.renpy*/
            patterns: [strings]
        },
        3: {
            token: MetaTokenType.PythonLine, /*meta.embedded.line.python*/
            patterns: [
                pythonFunctionArguments,
                {
                    debugName: "menuOption.beginCaptures![3].patterns![1]",

                    // if condition
                    match: /\b(if)[ \t]+(.+)?/dg,
                    captures: {
                        1: { token: KeywordTokenType.If, /*keyword.control.conditional.renpy*/ },
                        2: { patterns: [pythonExpressionBare] },
                    },
                },
                {
                    debugName: "menuOption.beginCaptures![3].patterns![2]",

                    token: MetaTokenType.Invalid, /*invalid.illegal.unexpected-characters-in-menu-arguments.renpy*/
                    match: /[^ \t]+/g,
                },
            ]
        },
        4: { token: CharacterTokenType.Colon, /*punctuation.section.menu-option.begin.renpy*/ },
    },
    end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
    patterns: [
    ]
};

export const menuSet: TokenPattern = {
    debugName: "menuSet",

    match: /(?<=^[ \t]+)(set)[ \t]+(.+)?/dgm,
    captures: {
        1: { token: KeywordTokenType.Set, /*keyword.set.renpy*/ },
        2: {
            token: MetaTokenType.PythonLine, /*meta.embedded.line.python*/
            patterns: [pythonExpressionBare]
        },
    },
};

export const menu: TokenPattern = {
    debugName: "menu",

    token: MetaTokenType.MenuStatement, /*meta.menu.statement.renpy*/
    contentToken: MetaTokenType.MenuBlock, /*meta.menu.block.renpy*/
    begin: /^([ \t]+)?(menu)[ \t]*(.+)?(:)/dgm,
    beginCaptures: {
        1: { token: CharacterTokenType.Whitespace, /*punctuation.whitespace.menu.leading.renpy*/ },
        2: { token: KeywordTokenType.Def, /*storage.type.function.renpy*/ },
        3: {
            patterns: [
                {
                    debugName: "menu.beginCaptures![3].patterns![0]",

                    // Menu name
                    token: EntityTokenType.FunctionName, /*entity.name.function.renpy*/
                    match: /[a-zA-Z_.]\w*/g,
                },
                pythonFunctionArguments,
            ]
        },
        4: { token: CharacterTokenType.Colon, /*punctuation.section.menu.begin.renpy*/ },
    },
    end: /^(?=(?!\1)[ \t]*[^\s#]|\1[^\s#])/gm,
    patterns: [
        comments,
        menuOption,
        sayStatements,
        menuSet,
        fallbackCharacters,
    ]
};

export const builtinAudioChannels: TokenPattern = {
    debugName: "builtinAudioChannels",

    token: MetaTokenType.BuiltinType, /*support.type.audio.channel.renpy*/
    match: /(?<!\.)\b(?:music|sound|voice|audio)\b/g,
};

export const audioChannel: TokenPattern = {
    patterns: [
        builtinAudioChannels,
        {
            debugName: "audioChannel.patterns![1]",

            token: EntityTokenType.AudioName, /*entity.name.type.audio.channel.renpy*/
            match: /.+/g,
        },
    ]
};

export const audioParams: TokenPattern = {
    patterns: [
        {
            debugName: "audioParams.patterns![0]",

            token: KeywordTokenType.OtherAudio, /*keyword.other.audio.renpy*/
            match: /\b(?<!\.)(?:fadeout|fadein|volume|loop|noloop)\b/g,
        },
        pythonNumber,
    ]
};

export const play: TokenPattern = {
    patterns: [
        {
            debugName: "play.patterns![0]",

            token: MetaTokenType.PlayAudioStatement, /*meta.play.audio.statement.renpy*/
            begin: /(?<=^[ \t]*)(play)\b[ \t]+\b([a-zA-Z_0-9]*)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Play, /*keyword.play.renpy*/ },
                2: { patterns: [audioChannel] },
            },
            end: /(?=[ \t]*#)|$/gm,
            patterns: [
                strings,
                audioParams,
                pythonExpression,
            ]
        },
    ]
};

export const queue: TokenPattern = {
    patterns: [
        {
            debugName: "queue.patterns![0]",

            token: MetaTokenType.QueueAudioStatement, /*meta.queue.audio.statement.renpy*/
            begin: /(?<=^[ \t]*)(queue)\b[ \t]+\b([a-zA-Z_0-9]*)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Queue, /*keyword.queue.renpy*/ },
                2: { patterns: [audioChannel] },
            },
            end: /(?=[ \t]*#)|$/gm,
            patterns: [
                strings,
                audioParams,
                pythonExpression,
            ]
        },
    ]
};

export const stop: TokenPattern = {
    patterns: [
        {
            debugName: "stop.patterns![0]",

            token: MetaTokenType.StopAudioStatement, /*meta.stop.audio.statement.renpy*/
            begin: /(?<=^[ \t]*)(stop)\b[ \t]+\b([a-zA-Z_0-9]*)\b[ \t]*/dgm,
            beginCaptures: {
                1: { token: KeywordTokenType.Stop, /*keyword.stop.renpy*/ },
                2: { patterns: [audioChannel] },
            },
            end: /(?=[ \t]*#)|$/gm,
            patterns: [
                {
                    debugName: "stop.patterns![0].patterns![0]",

                    token: KeywordTokenType.Fadeout, /*keyword.fadeout.renpy*/
                    match: /\b(?<!\.)(?:fadeout)\b/g,
                },
                pythonNumber,
            ]
        },
    ]
};

export const audio: TokenPattern = {
    patterns: [
        play,
        queue,
        stop,
    ]
};

export const renpyStatements: TokenPattern = {
    patterns: [
        label,
        menu,
        image,
        audio,
        pause,
        transform,
        scene,
        camera,
        show,
        withStatement,
        styleOld,
        useOld,
        screen,
        returnStatements,
        jump,
        call,
    ]
};

export const basePatterns: TokenPattern = {
    patterns: [
        statements,
        expressions,
    ]
};

// Push pattern references that were not defined on include
statements.patterns!.push(renpyStatements, pythonStatements, keywords, sayStatements);
expressions.patterns!.push(comments, strings, literal, fallbackCharacters);
stringsInterior.patterns!.push(stringTags);
screenLanguage.patterns!.push(screenFrame, screenWindow, screenText, screenKeywords, screenSimpleExpression);
menuOption.patterns!.push(basePatterns);